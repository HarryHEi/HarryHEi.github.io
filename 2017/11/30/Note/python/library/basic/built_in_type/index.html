<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>内建类型 · Harryx</title><meta name="description" content="参考文档Built-in Types
真值检测所有对象都可以通过if或者while进行真值检测，在默认情况下，反回True。可以通过定义__bool__()方法决定其真值。
比较在Python中有8个比较符(comparison operation)：
&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=符号"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Harryx</a></h3><div class="description"><p>good good study good good play~</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/harryx520"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/Booooyakasha"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备19072417号-1</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/avator.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>内建类型</a></h3></div><div class="post-content"><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://docs.python.org/3.6/library/stdtypes.html" target="_blank" rel="noopener">Built-in Types</a></p>
<h1 id="真值检测"><a href="#真值检测" class="headerlink" title="真值检测"></a>真值检测</h1><p>所有对象都可以通过<code>if</code>或者<code>while</code>进行真值检测，在默认情况下，反回<code>True</code>。<br>可以通过定义<code>__bool__()</code>方法决定其真值。</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>在Python中有8个比较符(comparison operation)：</p>
<h2 id="lt-、-lt-、-gt-、-gt-符号"><a href="#lt-、-lt-、-gt-、-gt-符号" class="headerlink" title="&lt;、&lt;=、&gt;、&gt;=符号"></a><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>符号</h2><p>这些符号不能比较两个不同类型，否则会<code>TypeError</code>异常。<br>方法：</p>
<ul>
<li><code>x.__lt__(y)</code>相当于<code>x&lt;y</code></li>
<li><code>x.__le__(y)</code>相当于<code>x&lt;=y</code></li>
<li><code>x.__gt__(y)</code>相当于<code>x&gt;y</code></li>
<li><code>x.__ge__(y)</code>相当于<code>c&gt;=y</code></li>
</ul>
<p>PS：当定义了相应比较方法后，才可以进行排序操作。</p>
<h2 id="、-符号"><a href="#、-符号" class="headerlink" title="==、!=符号"></a><code>==</code>、<code>!=</code>符号</h2><p>默认情况下，<code>id</code>不通的两个同一对象的实例比较结果为不等。<br>可以通过定义<code>__eq__()</code>方法自定义对象的比较方式。</p>
<h2 id="is、is-not"><a href="#is、is-not" class="headerlink" title="is、is not"></a><code>is</code>、<code>is not</code></h2><p><code>is</code>和<code>is not</code>符号操作不能被自定义，但是可以用于两个不同的对象，且不会抛出异常。</p>
<h2 id="in、not"><a href="#in、not" class="headerlink" title="in、not"></a><code>in</code>、<code>not</code></h2><p>还有两个语法相似的符号<code>in</code>和<code>not in</code>，只能应用于序列类型(sequence types)</p>
<h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><p>比较明显的三种数值类型：整数类型(int)，浮点类型(float)，复数类型(complex)。<br>另外，布尔类型(bool)是特殊的整数类型。</p>
<p>整数类型具有无限精度。</p>
<p>浮点类型相当于 C 里面的<code>double</code>类型。具体精度细则可以通过<code>sys.float_info</code>获知。</p>
<p>复数类型具有实数部分(<code>real</code>)和虚数部分(<code>imag</code>)，虚数后添加一个<code>j</code>或者<code>J</code>符号。</p>
<p>Python完全支持混合计算。</p>
<p>Tips：</p>
<ol>
<li>负数使用整除时会被翻译为负无穷。<br><code>(-1)//2=&gt;-1</code>、<code>1//(-2)=&gt;-1</code>、<code>(-1)//(-2)=&gt;0</code></li>
<li>复数也可以使用<code>abs()</code>计算绝对值.</li>
<li>浮点小数到整数的转换和 C 类似。<br><code>round()</code>用于四舍五入，<code>math.trunc()</code>截断，<code>math.floor()</code>向下取整和<code>math.ceil()</code>向上取整。</li>
<li>float类型可以接收<code>nan</code>和<code>inf</code>(可以前置+或-)字符串表示<code>NaN</code>(Not a Number)非数值和正负无穷。</li>
<li><code>0 ** 0 =&gt; 1</code></li>
</ol>
<h2 id="整型位操作"><a href="#整型位操作" class="headerlink" title="整型位操作"></a>整型位操作</h2><p>只有整数类型可以进行位操作，负数的进行位操作时取补码值。</p>
<p>优先值比数值操作符低，比比较操作符高。</p>
<p>Tips：</p>
<ol>
<li>移位值位负数会抛出<code>ValueError</code>异常，例如<code>1 &lt;&lt; -2</code>。</li>
<li>没有溢出的话，左移<code>n</code>位相当于乘以<code>power(2, n)</code>。</li>
<li>没有溢出的话，右移<code>n</code>位相当于除以<code>power(2, n)</code>。</li>
</ol>
<h2 id="整型的其他方法"><a href="#整型的其他方法" class="headerlink" title="整型的其他方法"></a>整型的其他方法</h2><h3 id="int-bit-length"><a href="#int-bit-length" class="headerlink" title="int.bit_length()"></a><code>int.bit_length()</code></h3><p>返回整型数值转换成2进制所需最少位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int(123).bit_length()  # 输出7，123相当于0b1111011。</span><br></pre></td></tr></table></figure>

<h3 id="int-to-bytes-length-byteorder-signed-False"><a href="#int-to-bytes-length-byteorder-signed-False" class="headerlink" title="int.to_bytes(length, byteorder, *, signed=False)"></a><code>int.to_bytes(length, byteorder, *, signed=False)</code></h3><p>返回表示整型数值的<code>bytes</code>字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(20).to_bytes(2, byteorder=&apos;big&apos;)</span><br><span class="line">b&apos;\x00\x14&apos;</span><br><span class="line">&gt;&gt;&gt; int(20).to_bytes(2, byteorder=&apos;little&apos;)</span><br><span class="line">b&apos;\x14\x00&apos;</span><br></pre></td></tr></table></figure>

<p>如果所给位数<code>length</code>不够用来表达整数类型，会抛出<code>OverflowError</code>异常。</p>
<p>其中<code>byteorder</code>参数决定高位先行还是低位先行，或者使用系统相关<code>sys.byteorder</code>作为参数。</p>
<p><code>signed</code>参数决定是否表示负数，如果<code>signed=False</code>时，尝试转换一个负数会抛出<code>OverflowError</code>异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int(-1).to_bytes(2, byteorder=&apos;little&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">OverflowError: can&apos;t convert negative int to unsigned</span><br><span class="line">int(-1).to_bytes(2, byteorder=&apos;little&apos;, signed=True)</span><br><span class="line">b&apos;\xff\xff&apos;</span><br></pre></td></tr></table></figure>

<h3 id="classmethod-int-from-bytes-bytes-byteorder-signed-False"><a href="#classmethod-int-from-bytes-bytes-byteorder-signed-False" class="headerlink" title="classmethod int.from_bytes(bytes, byteorder, *, signed=False)"></a><code>classmethod int.from_bytes(bytes, byteorder, *, signed=False)</code></h3><p>将所给bytes字符串转换位整型。</p>
<h2 id="浮点型的其他方法"><a href="#浮点型的其他方法" class="headerlink" title="浮点型的其他方法"></a>浮点型的其他方法</h2><h3 id="float-as-integer-ratio"><a href="#float-as-integer-ratio" class="headerlink" title="float.as_integer_ratio()"></a><code>float.as_integer_ratio()</code></h3><p>返回一对比例等于这个浮点数的整数。</p>
<p>如果尝试转换<code>NaN</code>，会抛出<code>ValueError</code>异常。</p>
<h3 id="float-is-integer"><a href="#float-is-integer" class="headerlink" title="float.is_integer()"></a><code>float.is_integer()</code></h3><p>如果浮点类型只限为整数值，返回<code>True</code>。</p>
<h2 id="数值类型的哈希值"><a href="#数值类型的哈希值" class="headerlink" title="数值类型的哈希值"></a>数值类型的哈希值</h2><p>对于数值<code>x</code>和<code>y</code>，如果<code>x == y</code>，那么<code>hash(x) == hash(y)</code>。</p>
<h1 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h1><p>迭代器是基于容器的概念，为了使用户自定义的类支持迭代器，定义以下两种方法</p>
<h2 id="container-iter"><a href="#container-iter" class="headerlink" title="container.__iter__()"></a><code>container.__iter__()</code></h2><p>返回一个迭代器对象，返回的迭代器对象提供以下两个协议。如果容器提供各种不同类型的迭代器，可以使用额外的方式获取迭代器。</p>
<h3 id="iterator-iter"><a href="#iterator-iter" class="headerlink" title="iterator.__iter__()"></a><code>iterator.__iter__()</code></h3><p>返回迭代器本身，使容器和迭代器支持<code>for</code>和<code>in</code>操作。</p>
<h3 id="iterator-next"><a href="#iterator-next" class="headerlink" title="iterator.__next__()"></a><code>iterator.__next__()</code></h3><p>返回容器的下个元素，如果没有更多的元素，将会触发一个<code>StopIteration</code>异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lis = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; iter = lis.__iter__()</span><br><span class="line">&gt;&gt;&gt; iter.__next__()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; iter.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; iter.__next__()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<h1 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h1><h2 id="一般序列类型"><a href="#一般序列类型" class="headerlink" title="一般序列类型"></a>一般序列类型</h2><p>有三个基本的序列类型：<code>list</code>、<code>tuple</code>、<code>range</code>。两个特殊的一般序列<code>str</code>、<code>bytes</code>。</p>
<p>Tips：</p>
<p>分清序列的元素是拷贝还是引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lis = [[]]*3</span><br><span class="line">&gt;&gt;&gt; lis</span><br><span class="line">[[], [], []]</span><br><span class="line">&gt;&gt;&gt; lis[0].append(1)</span><br><span class="line">&gt;&gt;&gt; lis</span><br><span class="line">[[1], [1], [1]]</span><br></pre></td></tr></table></figure>

<p>这里的<code>[[]]*3</code>并不等同于<code>[[]] + [[]] + [[]]</code>，而相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l=[]</span><br><span class="line">&gt;&gt;&gt; lis = [l,l,l]</span><br></pre></td></tr></table></figure>

<p>因此以上方式是元素的引用，可以采用下面的方式创建不同数组组成的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lis = [[] for i in range(5)]</span><br><span class="line">&gt;&gt;&gt; lis</span><br><span class="line">[[], [], [], [], []]</span><br><span class="line">&gt;&gt;&gt; lis[0].append(1)</span><br><span class="line">&gt;&gt;&gt; lis</span><br><span class="line">[[1], [], [], [], []]</span><br></pre></td></tr></table></figure>

<h2 id="不可变序列类型"><a href="#不可变序列类型" class="headerlink" title="不可变序列类型"></a>不可变序列类型</h2><p>不可变序列通常执行的区别于可变序列操作是支持<code>hash()</code>。</p>
<p>这个支持使得不可变类型，比如<code>tuple</code>实例可以用作<code>dict</code>的键值，或者储存在<code>set</code>和<code>frozenset</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;a&apos;]=1</span><br><span class="line">&gt;&gt;&gt; d[(&apos;b&apos;, &apos;c&apos;)]=2</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;a&apos;: 1, (&apos;b&apos;, &apos;c&apos;): 2&#125;</span><br><span class="line">&gt;&gt;&gt; d[[&apos;d&apos;, &apos;e&apos;]]=3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br></pre></td></tr></table></figure>

<p>但是尝试获取包含不能获取哈希值的不可变类型序列也将抛出<code>TypeError</code>异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash((1,2,3))</span><br><span class="line">-378539185</span><br><span class="line">&gt;&gt;&gt; hash((1,2,[3]))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br></pre></td></tr></table></figure>

<h2 id="可变序列类型"><a href="#可变序列类型" class="headerlink" title="可变序列类型"></a>可变序列类型</h2><p>Tips：</p>
<ol>
<li>如果元素不存在，<code>remove</code>会抛出<code>ValueError</code>异常。</li>
<li>为了保证效率，<code>reverse()</code>方法进行地址操作，因此不会返回新的数组。</li>
<li>为了保证与不支持切片的序列类型的一致性，保留了<code>clear</code>和<code>copy</code>操作。</li>
</ol>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>列表是可变序列类型，一般用于保存多个同类型元素。</p>
<h3 id="sort-self-key-None-reverse-False"><a href="#sort-self-key-None-reverse-False" class="headerlink" title="sort(self, key=None, reverse=False)"></a><code>sort(self, key=None, reverse=False)</code></h3><p>将数组排序，需要元素之间支持<code>&lt;</code>比较。</p>
<p><code>key</code>参数指定一个函数提取用于比较的元素，每个元素只计算一次，默认直接使用元素值比较。比如<code>key=str.lower</code>，用于不区分大小写排序。</p>
<p><code>reverse</code>如果设置为<code>True</code>，反向排序。</p>
<h2 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h2><p>Tuples是一个不可变序列，一般用于保存各种不同类型数据。</p>
<h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p><code>class range(stop)</code><br><code>class range(start, stop[,step])</code></p>
<h1 id="文本序列类型"><a href="#文本序列类型" class="headerlink" title="文本序列类型"></a>文本序列类型</h1><p>Python中把文本数据处理为<code>str</code>对象或者字符串，字符串是unicode编码的不可变序列（字面值常量）。</p>
<p>三引号字符串一般跨越多行用连续的空格隔开。</p>
<p>字符串字面值是单个表达式，空格隔开的多个字符串会被处理为一个字符串字面值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (&quot;hello &quot; &quot;world&quot;) == &quot;hello world&quot;</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>为了向前兼容，允许添加<code>u</code>前缀，虽然没有什么影响，但是不能和<code>r</code>前缀组合。</p>
<p><code>class str(object=&#39;&#39;)</code><br><code>class str(object=b&#39;&#39;, encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;)</code></p>
<p>如果没有指定<code>encoding</code>和<code>errors</code>参数<code>str(object)</code>返回<code>object.__str__()</code>的值。<br>如果没有定义<code>__str__()</code>方法，会返回<code>repr(object)</code>，返回对象的基本描述。</p>
<p>如果指定了<code>encoding</code>或者<code>errors</code>，<code>object</code>必须是<code>bytes-like object</code>(bytes, bytearray, array.array)。如果<code>object</code>是<code>bytes</code>，相当于<code>bytes.decode(encoding, errors)</code>。</p>
<p>如果传入<code>bytes</code> 参数，没有指定<code>encoding</code>和<code>errors</code>参数，会进入第一种情况，返回对象的基本描述。</p>
<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>字符串支持所有一般序列的操作。</p>
<p>字符串支持两种风格构造格式，一种是用<code>str.format</code>，另外一种是 C <code>printf</code>风格。</p>
<h3 id="str-capitalize"><a href="#str-capitalize" class="headerlink" title="str.capitalize()"></a><code>str.capitalize()</code></h3><p>返回字符串的拷贝，第一个字母大写，其余小写。</p>
<h3 id="str-casefold"><a href="#str-casefold" class="headerlink" title="str.casefold()"></a><code>str.casefold()</code></h3><p>返回字符串小写的拷贝，且支持其他语言。</p>
<h3 id="str-center-width-fillchar"><a href="#str-center-width-fillchar" class="headerlink" title="str.center(width[, fillchar])"></a><code>str.center(width[, fillchar])</code></h3><p>返回固定长度字符串，该字符串放在中间，其余默认补空格，或者通过参数<code>fillchar</code>指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;hello&apos;.center(20)</span><br><span class="line">&apos;       hello        &apos;</span><br></pre></td></tr></table></figure>

<h3 id="str-count-sub-start-end"><a href="#str-count-sub-start-end" class="headerlink" title="str.count(sub[, start[, end]]"></a><code>str.count(sub[, start[, end]]</code></h3><p>返回<code>sub</code>指定的子串出现的次数。</p>
<h3 id="str-encode-encoding-39-utf-8-39-errors-39-strict-39"><a href="#str-encode-encoding-39-utf-8-39-errors-39-strict-39" class="headerlink" title="str.encode(encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;)"></a><code>str.encode(encoding=&#39;utf-8&#39;, errors=&#39;strict&#39;)</code></h3><p>返回字符串编码后的版本。<code>errors</code>参数指定编码错误后的错误处理方式，<code>strict</code>表示抛出<code>UnicodeError</code>，其他还有<code>ignore</code>，<code>replace</code>，<code>xmlcharrefreplace</code>，<code>backslashreplace</code>或者使用<code>codecs.register_error()</code>注册的处理方式。</p>
<h3 id="str-endswith-suffix-start-end"><a href="#str-endswith-suffix-start-end" class="headerlink" title="str.endswith(suffix[, start[, end]])"></a><code>str.endswith(suffix[, start[, end]])</code></h3><p>如果以<code>suffix</code>指定的字符串结尾，则返回true，否则返回false。<code>suffix</code>也可以是个元组，用于查找。</p>
<h3 id="str-find-sub-start-end"><a href="#str-find-sub-start-end" class="headerlink" title="str.find(sub[, start[, end]])"></a><code>str.find(sub[, start[, end]])</code></h3><p>返回能够查找到<code>sub</code>指定子串的最小索引。</p>
<h3 id="str-format-args-kwargs"><a href="#str-format-args-kwargs" class="headerlink" title="str.format(*args, **kwargs)"></a><code>str.format(*args, **kwargs)</code></h3><p>构造一个字符串。<br>格式说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&#123;&apos; [field_name] [&quot;!&quot; conversion] [&quot;:&quot; format_spec] &apos;&#125;&apos;</span><br></pre></td></tr></table></figure>

<p>其中<code>field_name</code>结构为：<code>arg_name(&quot;.&quot; attribute_name | &quot;[&quot; element_index &quot;]&quot;)</code></p>
<p><code>arg_name</code>是一个数字或者关键字，如果是一个数字，表示的是一个位置。如果是一个关键字，可以通过<code>format</code>字典参数指定关键字。</p>
<p><code>.attribute</code>对参数进行点操作。</p>
<p><code>!conversion</code>指定在构造之前进行过一个格式操作。<br><code>!s</code>调用<code>str()</code>，<code>!r</code>调用<code>repr()</code>，<code>!a</code>调用<code>ascii()</code></p>
<p><code>format_spec</code>指定值的显示方式，格式入下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[fill] align] [sign] [#] [0] [width] [grouping_option] [.precision] [type]</span><br></pre></td></tr></table></figure>

<p><code>fill</code>指定填充字符，可以是任意字符。</p>
<p><code>align</code>指定对其方式，其中<code>&lt;</code>(左对齐)，<code>&gt;</code>右对齐，<code>=</code>在<code>+</code>或<code>-</code>符号之后数字符号之前填充，<code>^</code>居中。</p>
<p><code>sign</code>指定符号显示方式，其中<code>+</code>正数也会显示<code>+</code>符号，<code>-</code>只有负数会显示<code>-</code>符号，正数不显示，空格同<code>-</code>。</p>
<p><code>#</code>会使得辅助符号显示，只<code>int</code>、<code>float</code>、<code>complex</code>、<code>decimal.Decimal</code>有效。对于整数类型，会添加比如<code>0b</code>、<code>0o</code>和<code>0c</code>符号。对于其他几个，会添加一个小数点，即使并没有小数部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;&#123;:#&#125;&apos;.format(1+2j)</span><br><span class="line">&apos;(1.+2.j)&apos;</span><br></pre></td></tr></table></figure>

<p>如果添加了<code>0</code>标识，并且通过<code>width</code>参数指定了长度，数值前的空缺位自动补0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;&#123;:#010&#125;&apos;.format(123.321)</span><br><span class="line">&apos;000123.321&apos;</span><br></pre></td></tr></table></figure>

<p><code>grouping_option</code>如果指定为<code>,</code>，整数位每千位会用逗号隔开。如果指定为<code>_</code>，则用下划线隔开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;&#123;:,&#125;&apos;.format(12313123123.3421323)</span><br><span class="line">&apos;12,313,123,123.342133&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;&#123;:_&#125;&apos;.format(1233213213)</span><br><span class="line">&apos;1_233_213_213&apos;</span><br></pre></td></tr></table></figure>

<p><code>precision</code>指定小数点后显示多少位。</p>
<p><code>type</code>如下：</p>
<p>对于整数类型：</p>
<ul>
<li><code>b</code>，二进制格式；</li>
<li><code>c</code>，整型转换成unicode字符；</li>
<li><code>d</code>，十进制整数；</li>
<li><code>o</code>，八进制；</li>
<li><code>x</code>，十六进制小写；</li>
<li><code>X</code>，十六进制大写；</li>
<li><code>n</code>，和<code>d</code>一样。</li>
</ul>
<p>对于浮点类型</p>
<ul>
<li><code>e</code>，指数格式；</li>
<li><code>E</code>，同<code>e</code>，使用大写的E；</li>
<li><code>f</code>，小数固定6位，不足补0；</li>
<li><code>F</code>，同上，但是<code>nan</code> 转为<code>NAN</code>，<code>inf</code>转为<code>INF</code>；</li>
<li><code>g</code>，固定显示数的数量，数量由<code>precise</code>指定。<code>&#39;{a:.2g}&#39;.format(a=123.32132) ==&gt; &#39;1.2e+02&#39;</code>；</li>
<li><code>G</code>，同上，使用大写的E；</li>
<li><code>n</code>，同<code>g</code>；</li>
<li><code>%</code>，乘以100，再相当于加上<code>f</code>，以百分号结尾。<code>&#39;{a:%}&#39;.format(a=0.676766) ==&gt; &#39;67.676600%&#39;</code></li>
</ul>
<h3 id="str-format-map-mapping"><a href="#str-format-map-mapping" class="headerlink" title="str.format_map(mapping)"></a><code>str.format_map(mapping)</code></h3><p>和<code>str.format(**mapping)</code>类似，直接传入一个字典参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=dict(a=1)</span><br><span class="line">&gt;&gt;&gt; &apos;&#123;a&#125;&apos;.format_map(d)</span><br><span class="line">&apos;1&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;&#123;a&#125;&apos;.format(d)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &apos;a&apos;</span><br></pre></td></tr></table></figure>

<h3 id="str-index-sub-start-end"><a href="#str-index-sub-start-end" class="headerlink" title="str.index(sub[, start[, end]])"></a><code>str.index(sub[, start[, end]])</code></h3><p>和<code>find()</code>类似，但是如果没有找到会抛出<code>ValueError</code>遗异常。</p>
<h3 id="str-isalnum"><a href="#str-isalnum" class="headerlink" title="str.isalnum()"></a><code>str.isalnum()</code></h3><p>全部都是字符或者数字，否则返回false。</p>
<h3 id="str-isalpha"><a href="#str-isalpha" class="headerlink" title="str.isalpha()"></a><code>str.isalpha()</code></h3><p>全是字母，否则返回false。</p>
<h3 id="str-isdecimal"><a href="#str-isdecimal" class="headerlink" title="str.isdecimal()"></a><code>str.isdecimal()</code></h3><p>全是全角数字或者Unicode数字，否则返回false。</p>
<h3 id="str-isdigit"><a href="#str-isdigit" class="headerlink" title="str.isdigit()"></a><code>str.isdigit()</code></h3><p>全是Unicode数字、bytes数字、全角数字或者罗马数字，否则返回false。</p>
<h3 id="str-isnumeric"><a href="#str-isnumeric" class="headerlink" title="str.isnumeric()"></a><code>str.isnumeric()</code></h3><p>全是Unicode数字、全角数字、罗马数字或者汉字数字。</p>
<h3 id="str-isidentifier"><a href="#str-isidentifier" class="headerlink" title="str.isidentifier()"></a><code>str.isidentifier()</code></h3><p>如果是合法的标识符，返回true。</p>
<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>在<code>collection.abc</code>中有两个抽象基类<code>Mapping</code>和<code>MutableMapping</code>，一般不被直接继承，定义了映射类型基本接口，可被用于isinstance判断某个数据是不是映射类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_dict = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; isinstance(my_dict, collection.abc.Mapping)</span><br></pre></td></tr></table></figure>

<h2 id="setdefault-k-default"><a href="#setdefault-k-default" class="headerlink" title="setdefault(k[, default])"></a>setdefault(k[, default])</h2><p><code>setdefault(k[, default])</code>方法相比较<code>get(k, default)</code>方法，不同点是在没有找到键<code>k</code>时能够更新映射对象的值。<br>使用get()方式更新字典中的一个数组，进行了两次查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lis = m.get(k, [])</span><br><span class="line">lis.append(val)</span><br><span class="line">m[k] = lis</span><br></pre></td></tr></table></figure>

<p>使用setdefault()方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.setdefault(k, []).append(val)</span><br></pre></td></tr></table></figure>

<p>相当于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if k not in m:</span><br><span class="line">    m[k] = []</span><br><span class="line">m[k].append(val)</span><br></pre></td></tr></table></figure>

<p>这种方式可能要进行三次查询。</p>
<h2 id="missing"><a href="#missing" class="headerlink" title="__missing__()"></a><code>__missing__()</code></h2><p>当<code>__getitem__()</code>方法找不到键时会调用<code>__missing__()</code>，对<code>get()</code>或者<code>__contains__()</code>等方法没有影响。</p>
<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>集合类型是哈希对象组成的无序容器，通常支持成员检测、删重以及形如交、并、差分、均匀差分等计算操作。</p>
<p>和其他容器类似，集合支持<code>in</code>、<code>len()</code>和<code>for in</code>操作。因为是无序容器，不记录元素位置和插入顺序，因此也不支持索引、分片或者其他类似有序容器的行为。</p>
<p>有两个内建set类型，<code>set</code>和<code>frozenset</code></p>
<h1 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h1><p>列表推导是构建list的快捷方法。比如把Unicode字符串变为码位表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&apos;12312#$%^&amp;*&apos;</span><br><span class="line">&gt;&gt;&gt; [ord(c) for c in s]</span><br><span class="line">[49, 50, 51, 49, 50, 35, 36, 37, 94, 38, 42]</span><br></pre></td></tr></table></figure>

<p>使用列表推导计算笛卡尔积，可以发现嵌套顺序和for语句出现的顺序一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; colors = [&apos;black&apos;, &apos;white&apos;]</span><br><span class="line">&gt;&gt;&gt; sizes = [&apos;M&apos;, &apos;L&apos;, &apos;XL&apos;]</span><br><span class="line">&gt;&gt;&gt; [(color, size) for color in colors for size in sizes]</span><br><span class="line">[(&apos;black&apos;, &apos;M&apos;), (&apos;black&apos;, &apos;L&apos;), (&apos;black&apos;, &apos;XL&apos;), (&apos;white&apos;, &apos;M&apos;), (&apos;white&apos;, &apos;L&apos;), (&apos;white&apos;, &apos;XL&apos;)]</span><br></pre></td></tr></table></figure>

<h1 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h1><p>生成器表达式可以用来创建其他任何类型的序列。虽然可以用列表推导初始化元组、数组或者其他类型，但是使用生成器的方式更节省内存。形式上只是换成了圆括号。</p>
<p>如果生成器表达式是函数的唯一参数，可以省略圆括号。</p>
<p>生成器逐个产出元素，并不会一次性产出所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for tshirt in (&apos;&#123;&#125;,&#123;&#125;&apos;.format(c, s) for c in colors for s in sizes):</span><br><span class="line">...     print(tshirt)</span><br><span class="line">...</span><br><span class="line">black,M</span><br><span class="line">black,L</span><br><span class="line">black,XL</span><br><span class="line">white,M</span><br><span class="line">white,L</span><br><span class="line">white,XL</span><br></pre></td></tr></table></figure>

</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-11-30</span><i class="fa fa-tag"></i><a class="tag" href="/tags/python/" title="python">python </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2017/11/30/Note/python/library/basic/built_in_type/,Harryx,内建类型,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/12/06/Note/tools/windows_installer/" title="windows程序打包">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/08/09/Note/cpp/timer/" title="timer">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
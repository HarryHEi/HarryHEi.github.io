<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>myblog-0d API · Harryx</title><meta name="description" content="应用编程接口业务逻辑越来越多的移动到了客户端一侧，开创出一种称为RIA(富互联网应用 Rich Internet Application)的架构，服务器主要功能是提供数据存取服务。在这种模式下，服务器变成了Web服务或者应用编程接口(API Application Programming Inter"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Harryx</a></h3><div class="description"><p>good good study good good play~</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/harryx520"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/Booooyakasha"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备19072417号-1</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/avator.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>myblog-0d API</a></h3></div><div class="post-content"><h1 id="应用编程接口"><a href="#应用编程接口" class="headerlink" title="应用编程接口"></a>应用编程接口</h1><p>业务逻辑越来越多的移动到了客户端一侧，开创出一种称为RIA(富互联网应用 Rich Internet Application)的架构，服务器主要功能是提供数据存取服务。<br>在这种模式下，服务器变成了Web服务或者应用编程接口(API Application Programming Interface)。</p>
<h2 id="REST简介"><a href="#REST简介" class="headerlink" title="REST简介"></a>REST简介</h2><p>REST(表现层状态转移, Representational State Transfer)架构特征</p>
<ul>
<li>客户端-服务器<br>客户端和服务器之间必须有明确的界线。</li>
<li>无状态<br>客户端发出的请求中必须包含所有必要的信息。服务器不能在两次请求之间保存客户端的任何状态。</li>
<li>缓存<br>服务器发出的响应可以标记为可缓存或不可缓存,这样出于优化目的,客户端(或客户端和服务器之间的中间服务)可以使用缓存。</li>
<li>接口统一<br>客户端访问服务器资源时使用的协议必须一致,定义良好,且已经标准化。REST Web服务最常使用的统一接口是 HTTP 协议。</li>
<li>系统分层<br>在客户端和服务器之间可以按需插入代理服务器、缓存或网关,以提高性能、稳定性和伸缩性。</li>
<li>按需代码<br>客户端可以选择从服务器上下载代码,在客户端的环境中执行。<h2 id="使用flask提供REST-Web服务"><a href="#使用flask提供REST-Web服务" class="headerlink" title="使用flask提供REST Web服务"></a>使用flask提供REST Web服务</h2><h3 id="API蓝本结构"><a href="#API蓝本结构" class="headerlink" title="API蓝本结构"></a>API蓝本结构</h3>API包的名字中有一个版本号，如果需要向前兼容，需要添加一个版本号的不同的包<br>在API蓝本中，各资源在不同模块实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-myblog</span><br><span class="line">    |-app/</span><br><span class="line">        |-api_1_0</span><br><span class="line">            |-__init__.py</span><br><span class="line">            |-users.py</span><br><span class="line">            |-posts.py</span><br><span class="line">            |-comments.py</span><br><span class="line">            |-authentication.py</span><br><span class="line">            |-errors.py</span><br><span class="line">            |-decorators.py</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>API蓝本构造文件<br>文件：<strong>app/api_1_0/<strong>init</strong>.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line"></span><br><span class="line">api = Blueprint(&apos;api&apos;, __name__)</span><br><span class="line"></span><br><span class="line">from . import authentication, posts, users, comments, errors</span><br></pre></td></tr></table></figure>

<p>注册API蓝本<br>文件：<strong>app/<strong>init</strong>.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def create_app(config_name):</span><br><span class="line">    #...</span><br><span class="line">    from .api_1_0 import api as api_1_0_blueprint</span><br><span class="line">    app.register_blueprint(api_1_0_blueprint, url_prefix=&apos;/api/v1.0&apos;)</span><br><span class="line">    #...</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在错误处理程序中根据客户端请求的格式改写响应，这种技术称为<strong>内容协商</strong><br>它向Web服务端发送JSON格式响应<br>文件：<strong>app/main/errors.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from flask import render_template, request, jsonify</span><br><span class="line"></span><br><span class="line">from . import main</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(404)</span><br><span class="line">def page_not_found(e):</span><br><span class="line">    if request.accept_mimetypes.accept_json and \</span><br><span class="line">            not request.accept_mimetypes.accept_html:</span><br><span class="line">        response = jsonify(&#123;&apos;error&apos;: &apos;not found&apos;&#125;)</span><br><span class="line">        response.status_code = 404</span><br><span class="line">        return response</span><br><span class="line">    return render_template(&apos;404.html&apos;), 404</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(403)</span><br><span class="line">def forbidden(e):</span><br><span class="line">    if request.accept_mimetypes.accept_json and \</span><br><span class="line">            not request.accept_mimetypes.accept_html:</span><br><span class="line">        response = jsonify(&#123;&apos;error&apos;: &apos;forbidden&apos;&#125;)</span><br><span class="line">        response.status_code = 403</span><br><span class="line">        return response</span><br><span class="line">    return render_template(&apos;403.html&apos;), 403</span><br><span class="line"></span><br><span class="line">@main.app_errorhandler(500)</span><br><span class="line">def internal_server_error(e):</span><br><span class="line">    if request.accept_mimetypes.accept_json and \</span><br><span class="line">            not request.accept_mimetypes.accept_html:</span><br><span class="line">        response = jsonify(&#123;&apos;error&apos;: &apos;internal server error&apos;&#125;)</span><br><span class="line">        response.status_code = 500</span><br><span class="line">        return response</span><br><span class="line">    return render_template(&apos;500.html&apos;), 500</span><br></pre></td></tr></table></figure>

<p>API蓝本中错误处理程序，Web服务的视图函数可以调用这些辅助函数生成错误响应<br>文件：<strong>app/api_1_0/errors.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from flask import jsonify</span><br><span class="line"></span><br><span class="line">def bad_request(message):</span><br><span class="line">    response = jsonify(&#123;&apos;error&apos;: &apos;bad request&apos;, &apos;message&apos;: message&#125;)</span><br><span class="line">    response.status_code = 400</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line">def unauthorized(message):</span><br><span class="line">    response = jsonify(&#123;&apos;error&apos;: &apos;unauthorized&apos;, &apos;message&apos;: message&#125;)</span><br><span class="line">    response.status_code = 401</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line">def forbidden(message):</span><br><span class="line">    response = jsonify(&#123;&apos;error&apos;: &apos;forbidden&apos;, &apos;message&apos;: message&#125;)</span><br><span class="line">    response.status_code = 403</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<h3 id="使用-Flask-HTTPAuth-认证用户"><a href="#使用-Flask-HTTPAuth-认证用户" class="headerlink" title="使用 Flask-HTTPAuth 认证用户"></a>使用 Flask-HTTPAuth 认证用户</h3><p>Web浏览器外的客户端很难提供对cookie的支持<br>因为REST架构基于HTTP协议，所以发送密令的最佳方式是使用HTTP认证<br>在HTTP认证中，用户密令包含在请求的Authorization首部中<br>Flask-HTTPAuth扩展提供了一个便利的包装，可以把协议的细节隐藏在修饰器之中<br>类似于Flask-Login提供的login_required修饰器<br>因为这种用户认证方法只在API蓝本中使用，所以Flask-HTTPAuth扩展只在蓝本包中初始化<br>验证回调函数把通过认证的用户保存在Flask的全局对象g中<br>文件：<strong>app/api_1_0/authentication.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from flask.ext.httpauth import HTTPBasicAuth</span><br><span class="line">from flask import g, jsonify</span><br><span class="line"></span><br><span class="line">from ..models import User, AnonymousUser</span><br><span class="line">from . import api</span><br><span class="line"></span><br><span class="line">auth = HTTPBasicAuth()</span><br><span class="line"></span><br><span class="line">@auth.verify_password</span><br><span class="line">def verify_password(email, password):</span><br><span class="line">    if email == &apos;&apos;: #匿名登录</span><br><span class="line">        g.current_user = AnonymousUser()</span><br><span class="line">        return True</span><br><span class="line">    user = User.query.filter_by(email=email_or_token).first()</span><br><span class="line">    if not user:</span><br><span class="line">        return False</span><br><span class="line">    g.current_user = user</span><br><span class="line">    return user.verify_password(password)</span><br></pre></td></tr></table></figure>

<p>如果认证密令不正确，服务器向客户端返回401错误，默认情况下，Flask-HTTPAuth自动生成这个状态码<br>为了和API返回的其他错误保持一致，可以自定义这个错误响应<br>由于这个蓝本的所有路由都要使用相同方式进行保护，可以在before_request处理程序中使用一次login_required修饰器，应用到整个蓝本<br>文件：<strong>app/api_1_0/authentication.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from .errors import unauthorized, forbidden</span><br><span class="line"></span><br><span class="line">@auth.error_handler</span><br><span class="line">def auth_error():</span><br><span class="line">    return unauthorized(&apos;Invalid credentials&apos;)</span><br><span class="line"></span><br><span class="line">@api.before_request</span><br><span class="line">@auth.login_required</span><br><span class="line">def before_request():</span><br><span class="line">    if not g.current_user.is_anonymous and \</span><br><span class="line">            not g.current_user.confirmed:</span><br><span class="line">        return forbidden(&apos;Unconfirmed account&apos;)</span><br></pre></td></tr></table></figure>

<h3 id="基于令牌的认证"><a href="#基于令牌的认证" class="headerlink" title="基于令牌的认证"></a>基于令牌的认证</h3><p>客户端首先把登录密令发送给一个特殊的URL，从而生成认证令牌<br>一旦用户获得令牌，就可用令牌代替登录密令的认证请求，处于安全考虑，令牌有过期时间<br>User模型添加新方法，generate_auth_token()使用编码后的用户id字段值生成一个签名令牌，还指定了以秒为单位的过期时间<br>verify_auth_token()接收参数是一个令牌，如果令牌可用就返回对应的用户<br>文件：<strong>app/models.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User(UserMixin, db.Model):</span><br><span class="line">    #....</span><br><span class="line">    def generate_auth_token(self, expiration):</span><br><span class="line">        s = Serializer(current_app.config[&apos;SECRET_KEY&apos;],</span><br><span class="line">                       expires_in=expiration)</span><br><span class="line">        return s.dumps(&#123;&apos;id&apos;: self.id&#125;).decode(&apos;ascii&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def verify_auth_token(token):</span><br><span class="line">        s = Serializer(current_app.config[&apos;SECRET_KEY&apos;])</span><br><span class="line">        try:</span><br><span class="line">            data = s.loads(token)</span><br><span class="line">        except:</span><br><span class="line">            return None</span><br><span class="line">        return User.query.get(data[&apos;id&apos;])</span><br></pre></td></tr></table></figure>

<p>更改回调函数，支持令牌<br>文件：<strong>app/api_1_0/authentication.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@auth.verify_password</span><br><span class="line">def verify_password(email_or_token, password):</span><br><span class="line">    if email_or_token == &apos;&apos;:</span><br><span class="line">        g.current_user = AnonymousUser()</span><br><span class="line">        return True</span><br><span class="line">    if password == &apos;&apos;:</span><br><span class="line">        g.current_user = User.verify_auth_token(email_or_token)</span><br><span class="line">        g.token_used = True</span><br><span class="line">        return g.current_user is not None</span><br><span class="line">    user = User.query.filter_by(email=email_or_token).first()</span><br><span class="line">    if not user:</span><br><span class="line">        return False</span><br><span class="line">    g.current_user = user</span><br><span class="line">    g.token_used = False</span><br><span class="line">    return user.verify_password(password)</span><br></pre></td></tr></table></figure>

<p>生成认证令牌，为了避免客户端使用旧令牌申请新令牌,要在视图函数中检查 g.token_used 变量的值,如果使用令牌进行认证就拒绝请求。<br>这个视图函数返回 JSON 格式的响应,其中包含了过期时间为 1 小时的令牌。JSON 格式的响应也包含过期时间。<br>文件：<strong>app/api_1_0/authentication.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@api.route(&apos;/token&apos;)</span><br><span class="line">def get_token():</span><br><span class="line">    if g.current_user.is_anonymous or g.token_used:</span><br><span class="line">        return unauthorized(&apos;Invalid credentials&apos;)</span><br><span class="line">    return jsonify(&#123;&apos;token&apos;: g.current_user.generate_auth_token(</span><br><span class="line">        expiration=3600), &apos;expiration&apos;: 3600&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="资源和JSON的序列化转换"><a href="#资源和JSON的序列化转换" class="headerlink" title="资源和JSON的序列化转换"></a>资源和JSON的序列化转换</h3><p>文件：<strong>app/models.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class User(UserMixin, db.Model):</span><br><span class="line">    #...</span><br><span class="line">    def to_json(self):</span><br><span class="line">        json_user = &#123;</span><br><span class="line">            &apos;url&apos;: url_for(&apos;api.get_post&apos;, id=self.id, _external=True),</span><br><span class="line">            &apos;name&apos;: self.name,</span><br><span class="line">            &apos;member_since&apos;: self.member_since,</span><br><span class="line">            &apos;last_seen&apos;: self.last_seen,</span><br><span class="line">            &apos;posts&apos;: url_for(&apos;api.get_user_posts&apos;, id=self.id, _external=True),</span><br><span class="line">            &apos;followed_posts&apos;: url_for(&apos;api.get_user_followed_posts&apos;,</span><br><span class="line">                                      id=self.id, _external=True),</span><br><span class="line">            &apos;post_count&apos;: self.posts.count()</span><br><span class="line">        &#125;</span><br><span class="line">        return json_user</span><br><span class="line"></span><br><span class="line">class Post(db.Model):</span><br><span class="line">    #...</span><br><span class="line">    def to_json(self):</span><br><span class="line">        json_post = &#123;</span><br><span class="line">            &apos;url&apos;: url_for(&apos;api.get_post&apos;, id=self.id, _external=True),</span><br><span class="line">            &apos;body&apos;: self.body,</span><br><span class="line">            &apos;body_html&apos;: self.body_html,</span><br><span class="line">            &apos;timestamp&apos;: self.timestamp,</span><br><span class="line">            &apos;author&apos;: url_for(&apos;api.get_user&apos;, id=self.author_id,</span><br><span class="line">                              _external=True),</span><br><span class="line">            &apos;comments&apos;: url_for(&apos;api.get_post_comments&apos;, id=self.id,</span><br><span class="line">                                _external=True),</span><br><span class="line">            &apos;comment_count&apos;: self.comments.count()</span><br><span class="line">        &#125;</span><br><span class="line">        return json_post</span><br></pre></td></tr></table></figure>

<p>从JSON格式数据创建一篇博客文章<br>文件：<strong>app/models.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Post(db.Model):</span><br><span class="line">    #...</span><br><span class="line">    @staticmethod</span><br><span class="line">    def from_json(json_post):</span><br><span class="line">        body = json_post.get(&apos;body&apos;)</span><br><span class="line">        if body is None or body == &apos;&apos;:</span><br><span class="line">            raise ValidationError(&apos;post does not have a body&apos;)</span><br><span class="line">        return Post(body=body)</span><br></pre></td></tr></table></figure>

<p>文件：<strong>app/exceptions.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ValidationError(ValueError):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>创建一个全局异常处理程序<br>文件：<strong>app/api_1_0/errors.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@api.errorhandler(ValidationError)</span><br><span class="line">def validation_error(e):</span><br><span class="line">    return bad_request(e.args[0])</span><br></pre></td></tr></table></figure>

<p>第一个路由处理获取文章集合的请求<br>第二个路由返回单个博客文章<br>文件：<strong>app/api_1_0/posts.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@api.route(&apos;/posts/&apos;)</span><br><span class="line">@auth.login_required</span><br><span class="line">def get_posts():</span><br><span class="line">    posts = Post.query.all()</span><br><span class="line">    return jsonify(&#123; &apos;posts&apos;: [post.to_json() for post in posts] &#125;)</span><br><span class="line"></span><br><span class="line">@api.route(&apos;/posts/&lt;int:id&gt;&apos;)</span><br><span class="line">def get_post(id):</span><br><span class="line">    post = Post.query.get_or_404(id)</span><br><span class="line">    return jsonify(post.to_json())</span><br></pre></td></tr></table></figure>

<p>POST请求处理程序把一篇新博客文章插入数据库<br>文件：<strong>app/api_1_0/posts.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@api.route(&apos;/posts/&apos;, methods=[&apos;POST&apos;])</span><br><span class="line">@permission_required(Permission.WRITE_ARTICLES)</span><br><span class="line">def new_post():</span><br><span class="line">    post = Post.from_json(request.json)</span><br><span class="line">    post.author = g.current_user</span><br><span class="line">    db.session.add(post)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    return jsonify(post.to_json()), 201, \</span><br><span class="line">        &#123;&apos;Location&apos;: url_for(&apos;api.get_post&apos;, id=post.id, _external=True)&#125;</span><br></pre></td></tr></table></figure>

<p>permission_required修饰器和程序中使用的类似，但会针对API蓝本进行自定义<br>文件：<strong>app/api_1_0/decorators.oy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">from flask import g</span><br><span class="line"></span><br><span class="line">from .errors import forbidden</span><br><span class="line"></span><br><span class="line">def permission_required(permission):</span><br><span class="line">    def decorator(f):</span><br><span class="line">        @wraps(f)</span><br><span class="line">        def decorated_function(*args, **kwargs):</span><br><span class="line">            if not g.current_user.can(permission):</span><br><span class="line">                return forbidden(&apos;Insufficient permissions&apos;)</span><br><span class="line">            return f(*args, **kwargs)</span><br><span class="line">        return decorated_function</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure>

<p>PUT请求处理程序，修饰器用来检查用户是否有写博客文章的权限<br>文件：<strong>app/api_1_0/posts.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@api.route(&apos;/posts/&lt;int:id&gt;&apos;, methods=[&apos;PUT&apos;])</span><br><span class="line">@permission_required(Permission.WRITE_ARTICLES)</span><br><span class="line">def edit_post(id):</span><br><span class="line">    post = Post.query.get_or_404(id)</span><br><span class="line">    if g.current_user != post.author and \</span><br><span class="line">            not g.current_user.can(Permission.ADMINISTER):</span><br><span class="line">        return forbidden(&apos;Insufficient permissions&apos;)</span><br><span class="line">    post.body = request.json.get(&apos;body&apos;, post.body)</span><br><span class="line">    db.session.add(post)</span><br><span class="line">    return jsonify(post.to_json())</span><br></pre></td></tr></table></figure>

<p>API资源</p>
<table>
<thead>
<tr>
<th>/users/<a href="int:id" target="_blank" rel="noopener">int:id</a></th>
<th>GET</th>
<th>一个用户</th>
</tr>
</thead>
<tbody><tr>
<td>/users/<a href="int:id" target="_blank" rel="noopener">int:id</a>/posts/</td>
<td>GET</td>
<td>一个用户发布的博客文章</td>
</tr>
<tr>
<td>/users/<a href="int:id" target="_blank" rel="noopener">int:id</a>/timeline/</td>
<td>GET</td>
<td>一个用户所关注用户发布的文章</td>
</tr>
<tr>
<td>/posts/</td>
<td>GET 、POST</td>
<td>所有博客文章</td>
</tr>
<tr>
<td>/posts/<a href="int:id" target="_blank" rel="noopener">int:id</a></td>
<td>GET 、PUT</td>
<td>一篇博客文章</td>
</tr>
<tr>
<td>/posts/<a href="int:id/" target="_blank" rel="noopener">int:id/</a>comments/</td>
<td>GET 、POST</td>
<td>一篇博客文章中的评论</td>
</tr>
<tr>
<td>/comments/</td>
<td>GET</td>
<td>所有评论</td>
</tr>
<tr>
<td>/comments/<a href="int:id" target="_blank" rel="noopener">int:id</a></td>
<td>GET</td>
<td>一篇评论</td>
</tr>
</tbody></table>
<h3 id="分页大型资源集合"><a href="#分页大型资源集合" class="headerlink" title="分页大型资源集合"></a>分页大型资源集合</h3><p>分页文章资源，JSON格式响应中的posts字段依旧包含各篇文章，但这只是完整集合的一部分<br>文件：<strong>app/api_1_0/posts.py</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@api.route(&apos;/posts/&apos;)</span><br><span class="line">def get_posts():</span><br><span class="line">    page = request.args.get(&apos;page&apos;, 1, type=int)</span><br><span class="line">    pagination = Post.query.paginate(</span><br><span class="line">        page, per_page=current_app.config[&apos;FLASKY_POSTS_PER_PAGE&apos;],</span><br><span class="line">        error_out=False)</span><br><span class="line">    posts = pagination.items</span><br><span class="line">    prev = None</span><br><span class="line">    if pagination.has_prev:</span><br><span class="line">        prev = url_for(&apos;api.get_posts&apos;, page=page-1, _external=True)</span><br><span class="line">    next = None</span><br><span class="line">    if pagination.has_next:</span><br><span class="line">        next = url_for(&apos;api.get_posts&apos;, page=page+1, _external=True)</span><br><span class="line">    return jsonify(&#123;</span><br><span class="line">        &apos;posts&apos;: [post.to_json() for post in posts],</span><br><span class="line">        &apos;prev&apos;: prev,</span><br><span class="line">        &apos;next&apos;: next,</span><br><span class="line">        &apos;count&apos;: pagination.total</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用HTTPie测试Web服务"><a href="#使用HTTPie测试Web服务" class="headerlink" title="使用HTTPie测试Web服务"></a>使用HTTPie测试Web服务</h3><p>用户登录发送GET请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ http --json --auth &lt;email&gt;:&lt;password&gt; GET http://localhost:5000/api/v1.0/posts/</span><br></pre></td></tr></table></figure>

<p>匿名用户发送GET请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ http --json --auth  :  GET http://localhost:5000/api/v1.0/posts/</span><br></pre></td></tr></table></figure>

<p>使用POST请求添加一篇新文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ http --json --auth harryx520@qq.com:admin POST http://localhost:5000/api/v1.0/posts/ &quot;body=lalala,post from json&quot;</span><br></pre></td></tr></table></figure>

<p>如果要使用认证令牌，可向/api/v1.0/token发送请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ http --json --auth &lt;email&gt;:&lt;password&gt; http://localhost:5000/api/v1.0/token</span><br></pre></td></tr></table></figure>

<p>在有效时间内，这里是一小时，这个令牌可用于访问API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv)$ http --json --auth eyJhbG...:  GET http://localhost:5000/api/v1.0/posts/</span><br></pre></td></tr></table></figure>

</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-04-23</span><i class="fa fa-tag"></i><a class="tag" href="/tags/flask/" title="flask">flask </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2016/04/23/Note/python/library/web/flask/flask-d/,Harryx,myblog-0d API,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2016/04/24/Note/python/library/web/flask/flask-e/" title="myblog-0e 部署">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2016/04/23/Note/python/library/web/flask/flask-c/" title="myblog-0c 评论">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
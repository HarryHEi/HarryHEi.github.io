<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>C++ Primer · Harryx</title><meta name="description" content="开发环境编译工具Linux下使用GCC编译器对C++程序进行编译1234g++ hello.cc -o hellog++ hello.cc students.cc -o hello //编译多个文件g++ -std=c++11 hello.cc -o hello // c++11 标准
makefi"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Harryx</a></h3><div class="description"><p>good good study good good play~</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/harryx520"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/Booooyakasha"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/avator.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>C++ Primer</a></h3></div><div class="post-content"><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p><code>Linux</code>下使用<code>GCC</code>编译器对<code>C++</code>程序进行编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g++ hello.cc -o hello</div><div class="line">g++ hello.cc students.cc -o hello //编译多个文件</div><div class="line"></div><div class="line">g++ -std=c++11 hello.cc -o hello // c++11 标准</div></pre></td></tr></table></figure></p>
<p><code>makefile</code>的编写</p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>使用sublime编辑器，ctrl+B可以直接编译</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="输入输出（iostream库）"><a href="#输入输出（iostream库）" class="headerlink" title="输入输出（iostream库）"></a>输入输出（iostream库）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int v1,v2;</div><div class="line">    std::cout &lt;&lt; &quot;Enter two numbers&quot; &lt;&lt; std::endl;</div><div class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</div><div class="line">    std::cout &lt;&lt;  &quot;the sum is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面两种流操作是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">std::cout &lt;&lt; &quot;Enter two numbers&quot; &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::cout &lt;&lt; &quot;Enter two numbers&quot;;</div><div class="line">std::cout &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p><code>std::</code>表示命名空间<code>std</code>，<code>::</code>是作用域操作符（scope operator）<br>或者使用using声明命名空间，<code>using std::string</code></p>
<h2 id="变量、基本类型"><a href="#变量、基本类型" class="headerlink" title="变量、基本类型"></a>变量、基本类型</h2><p>c++11 标准支持使用花括号初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int val&#123;0&#125;;</div></pre></td></tr></table></figure></p>
<p>变量声明和定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern int a; //声明，不定义</div></pre></td></tr></table></figure></p>
<p>类类型通过<strong>构造函数</strong>（constructor）初始化</p>
<p><code>const</code>定义的变量值不会被意外修改，如果定义为全局变量，不能被其他文件访问</p>
<p><code>const</code>必须初始化，一旦创建，值无法修改</p>
<p>多个文件共享const变量，需要添加<code>extern</code>关键字</p>
<p>在<code>****.cc</code>文件中定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern const int aaa=10;</div></pre></td></tr></table></figure></p>
<p>在<code>****.h</code>头文件中声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern const int aaa;</div></pre></td></tr></table></figure></p>
<p><code>&amp;</code>引用是对象（变量）的别名，这里的<code>i</code>是变量（对象），<code>ii</code>是引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char i=&apos;a&apos;;</div><div class="line">char &amp;ii = i;</div></pre></td></tr></table></figure></p>
<ul>
<li>引用不是对象，没有实际地址</li>
<li>引用一旦定义，无法再赋值</li>
</ul>
<p><code>const</code>引用可以绑定到相关类型对象或右值（字面值等）上，称为常量引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int &amp;a = 1; //错误，不能为非const引用绑定常量（字面值）</div><div class="line">const int &amp;a = 1; //正确，可以用const引用绑定常量</div><div class="line">double i=2.1;	//i =&gt; 2.1</div><div class="line">int &amp;ii = i; //错误，不能使用非const绑定临时量</div><div class="line">const int &amp;ii = i;	//ii =&gt; 2 这里的  2 只是一个临时量，所以必须使用const</div><div class="line">i++;	//i =&gt; 3.1 , ii =&gt; 2</div></pre></td></tr></table></figure></p>
<p>可以通过其他途径修改原变量的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int i = 42;</div><div class="line">int &amp;r1 = i;</div><div class="line">const int &amp;r2 = i;  //这里绑定了 i ，不过不能通过r2修改 i 的值</div><div class="line">r1 = 0; //通过 r1 修改了值</div><div class="line">cout &lt;&lt; &quot;r1: &quot; &lt;&lt; r1 &lt;&lt; &quot; r2: &quot; &lt;&lt; r2 &lt;&lt; endl; //输出: r1: 0 r2: 0</div></pre></td></tr></table></figure></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>定义一个指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string s(&quot;hello world&quot;);</div><div class="line">string *sp = &amp;s;</div></pre></td></tr></table></figure></p>
<p>定义一个空指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int  *p = 0;</div><div class="line">int *p = nullptr; //C++11标准</div></pre></td></tr></table></figure></p>
<p><code>void*</code>指针可以存放任意对象地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int i = 20;</div><div class="line">void *p = &amp;i;</div></pre></td></tr></table></figure></p>
<ul>
<li>迭代器用于访问容器内元素，指针指向单个对象，保存另一个对象地址</li>
<li>指向const的指针才能指向const对象，也可以指向非const对象，但是不能修改对象值，指针本身的值可以修改</li>
<li>const指针指针值不能修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const int s = 1;</div><div class="line">const int *sp = &amp;s;//指向const类型的指针，指针值可以修改（重新指向一个const int 变量</div><div class="line">                                        //但是不能修改原变量（不管原变量是不是const）</div><div class="line">int *const csp = &amp;s;//错误，const指针应该指向非const int</div><div class="line">const int *const  pa = &amp;a;//指向const int 的 const 指针</div></pre></td></tr></table></figure>
<ul>
<li>顶层<code>const</code>：指针本身是常量</li>
<li>底层<code>const</code>：指针所指对象是常量</li>
</ul>
<p>常量表达式<code>constexpr</code></p>
<p>常量表达式可以定义为<code>constexpr</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">constexpr int i = 20;</div><div class="line">constexpr int a = i + 2;</div><div class="line">constexpr int *ip = nullptr;//指向整数的常量指针</div></pre></td></tr></table></figure></p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>使用typedef定义类型别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef double wow, *p; //wow 等同于 double ，p等同于 double *</div><div class="line">wow val = 1.1; //double val = 1.1;</div><div class="line">p p1 = &amp;val; // double *p1 = &amp;val;</div></pre></td></tr></table></figure></p>
<p>C++11使用别名声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">using wow = double;</div><div class="line">wow val = 1.1;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong><br><code>pstring</code>是指向<code>char</code>的指针，数据类型是指针<br><code>const</code>修饰之后，<code>const pstring</code>是指向<code>char</code>的<code>const</code>指针（常数指针）<br><code>const pstring cstr</code>相当于<code>char *const cstr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef char *pstring; //pstring 相当于 char*</div><div class="line">char a=&apos;0&apos;,b=&apos;1&apos;; </div><div class="line">const pstring cstr = &amp;a; //这并不等于const char *cstr ，这样修饰类型变成char</div><div class="line">    //cstr是一个指向char的const指针，char *const cstr</div><div class="line">cstr = &amp;b; //错误，因为cstr是const指针，不能重新赋值</div></pre></td></tr></table></figure>
<p><code>auto</code>让编译器推算变量类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a&#123;1&#125;,b&#123;2&#125;;</div><div class="line">auto c = a + b, d = a * b; //如果有多个语句所有变量基本数据必须同一类型</div><div class="line">                                                //（编译器会适当改变结果）</div></pre></td></tr></table></figure>
<p>编译器会适当修改结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 1, &amp;r = a;</div><div class="line">auto b = r; //b是一个int 类型，并不是引用</div><div class="line">a += 1;</div><div class="line">cout &lt;&lt; a &lt;&lt; r &lt;&lt; b &lt;&lt; endl;//a r都是2，b为1</div></pre></td></tr></table></figure>
<p><code>auto</code>会忽略顶层<code>const</code>，留下底层<code>const</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">const int i = 1;</div><div class="line">auto j = i; // j 为int类型</div><div class="line">j += 1; //合法</div><div class="line">i += 1; //不合法，i 为const int 类型</div><div class="line">auto k = &amp;a; // k是 int 类型指针</div><div class="line">auto m = &amp;i; //m 是 const int 类型指针对const 的取址是底层const</div></pre></td></tr></table></figure>
<p>明确指出<code>const auto</code>，修饰为顶层<code>const</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const int i = 1; //是不是cosnt 都一样</div><div class="line">const auto j = i; //j 为 const auto类型</div></pre></td></tr></table></figure>
<p>如果给const 变量绑定引用，初始值顶层const保留，保留的const就是底层const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const int ci = 1; //const int 类型</div><div class="line">auto &amp;a = ci; //a为 const int 类型 的引用</div><div class="line">a += 1; //非法</div><div class="line"></div><div class="line">int i = 1; //int类型</div><div class="line">const int ci = i; //const int 类型</div><div class="line">auto &amp;j = i,*p = &amp;ci ; //非法，j 为 int 类型引用，p为const int 类型指针，不一致</div><div class="line">const auto &amp;j = i,*p = &amp;ci ; //合法，均为const int 类型</div></pre></td></tr></table></figure>
<p><code>decltype</code>返回操作数的数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int fun(int i)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;</div><div class="line">    return i+1;</div><div class="line">&#125;</div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    decltype(fun(1)) i = 10; //编译器并不会真的调用fun()函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>decltype</code>如果表达式是变量，会返回包括顶层const的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const int a=0;</div><div class="line">decltype(a) i = 10; //const int类型</div><div class="line">decltype(a) &amp;j = a; //const int 引用</div><div class="line">const int &amp;b = a; </div><div class="line">decltype(b) i = a; //const int 引用</div></pre></td></tr></table></figure>
<p><code>decltype</code>如果表达式不是变量：</p>
<ul>
<li>如果是表达式，为结果的类型</li>
<li>如果是解引用，为引用类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 0, *p = &amp;a, &amp;r = a;</div><div class="line">decltype(r + 0) b = 1; //b 是int类型</div><div class="line">decltype(*p) c = a; // c是int引用（int&amp;）</div></pre></td></tr></table></figure>
<p>注意：<br>变量加上括号就会被理解为表达式，变量作为表达式是赋值，会得到引用类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">decltype(a) c = a; //c是int类型</div><div class="line">decltype((a)) d = a; //d是int引用(int&amp;)</div></pre></td></tr></table></figure>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a><code>string</code>对象</h3><p>在头文件<code>string</code>中</p>
<p><strong>注意：string对象和字符串字面值不是一回事</strong></p>
<p>初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string s1&#123;&quot;hello,world&quot;&#125;;</div><div class="line">string s2 = &quot;hello world&quot;;</div><div class="line">string s3 = s2;</div><div class="line">string s4 = (10, &apos;h&apos;); // &quot;hhhhhhhhhhh&quot;</div></pre></td></tr></table></figure></p>
<p>string对象操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getline(cin,s)</code></td>
<td>读取一行内容给<code>s</code>直到换行符（不包括换行符）</td>
</tr>
<tr>
<td><code>s.empty()</code></td>
<td>如果s为空返回true</td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>返回长度，<code>string::size_type</code><strong>（一个无符号整型）</strong></td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>返回字符，下标为<code>string::size_type</code>类型，但可以使用任何整型</td>
</tr>
<tr>
<td><code>s1 + s2</code></td>
<td>拼接，至少有一个是string对象(左结合)</td>
</tr>
<tr>
<td><code>s1 = s2</code></td>
<td>替换<code>s1</code>内容</td>
</tr>
<tr>
<td><code>s1 == s2</code></td>
<td>判断相等 (&gt; &lt; &gt;= &lt;= !=大小写敏感)</td>
</tr>
</tbody>
</table>
<p>string对象中字符判断（cctype头文件中），一般返回int非0值或0</p>
<p><code>isalnum</code>        字母或数字<br><code>isalpha</code>        字母<br><code>isdigit</code>        数字<br><code>isgraph</code>        不是空格，可以打印<br>等</p>
<p>读取字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (cin &gt;&gt; s)&#123; \*   ...   *\ &#125; //每次读取一个单词（不包括空格）</div><div class="line">                //然后进入循环体，读取到结束符（ctrl D）退出循环</div><div class="line">getline(cin, s); //读取一行直到换行符（读取但是不保存换行符）</div></pre></td></tr></table></figure>
<p>比较大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string a&#123;&quot;abc&quot;&#125;;</div><div class="line">string b&#123;&quot;aac&quot;&#125;;</div><div class="line">string c&#123;&quot;ab&quot;&#125;;</div><div class="line">//a &gt; b &gt; c</div></pre></td></tr></table></figure>
<p>使用下标遍历修改字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">string s&#123;&quot;hello,world!&quot;&#125;;</div><div class="line">for (decltype(s.size()) index = 0; index != s.size(); ++index) //decltype 获取类型</div><div class="line">    if (isalpha(s[index]))</div><div class="line">        s[index] = toupper(s[index])s</div><div class="line">cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>C++11 提供新的语句：范围for语句，遍历一个序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (元素:序列)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>使用范围for遍历一个string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string s&#123;&quot;hello world&quot;&#125;;</div><div class="line">for (auto c: s) //使用auto让编译器自己决定变量类型</div><div class="line">    cout &lt;&lt; c &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>使用引用遍历并修改字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">string s&#123;&quot;hello,world!&quot;&#125;;</div><div class="line">for (auto &amp;c: s) //定义原字符的引用</div><div class="line">    if (isalpha(c))</div><div class="line">        c = toupper(c); //改为大写</div><div class="line">cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure>
<h3 id="vector对象"><a href="#vector对象" class="headerlink" title="vector对象"></a><code>vector</code>对象</h3><p><code>vector</code>对象在<code>vector</code>头文件中，一个容器只能保存同一种对象（类型），甚至可以是vector对象</p>
<p>定义时指定类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">std::vector&lt;int&gt; ivec&#123;1,2,3,4&#125;;</div><div class="line">std::vector&lt;int&gt; ivec = &#123;1,2,3,4&#125;;</div><div class="line">std::vector&lt;int&gt; ivec = (10);//10个元素，初始化为0</div><div class="line">std::vector&lt;int&gt; ivec(10, -1);//&#123;-1, -1,-1, -1, -1, -1, -1, -1, -1, -1&#125;;</div><div class="line">std::vector&lt;int&gt; iven(1,2,3,4);//错误</div><div class="line"></div><div class="line">std::vector&lt;string&gt; sven&#123;10&#125;;//因为10并不能赋值给string所以，编译器尝试默认初始化</div><div class="line">        //为10个默认初始化元素</div></pre></td></tr></table></figure>
<p>使用push_back添加元素，不能使用下标添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; ivec;</div><div class="line">for (int i = 0;i &lt; 100; ++i)</div><div class="line">&#123;</div><div class="line">    ivec.push_back(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>范围for循环访问，<strong>不能在范围for循环添加元素</strong>，因为范围for语句预存了end()的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (string s: svec)</div><div class="line">    cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p><code>vector</code>对象操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v.empty()</code></td>
<td>如果为空返回true</td>
</tr>
<tr>
<td><code>v.size()</code></td>
<td>返回长度，<code>vector&lt;...&gt;::size_type</code>类型，<strong>不能省略<code>&lt;...&gt;</code></strong></td>
</tr>
<tr>
<td><code>v.push_back(t)</code></td>
<td>在v尾部添加元素t</td>
</tr>
<tr>
<td><code>v[n]</code></td>
<td>返回元素</td>
</tr>
<tr>
<td><code>v1 = v2</code></td>
<td>v1元素替换</td>
</tr>
<tr>
<td><code>v1 == v2</code></td>
<td>相等返回true(&gt; &lt; &gt;= &lt;= !=)以字典顺序比较</td>
</tr>
</tbody>
</table>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>所有标准库容器都可以使用迭代器</p>
<p>string也可以使用迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">string s(&quot;hello world&quot;);</div><div class="line">auto si = s.begin(), se = s.end();</div><div class="line">while(si != se)</div><div class="line">&#123;</div><div class="line">    if (isalpha(*si))</div><div class="line">        *si = toupper(*si);</div><div class="line">    ++si;</div><div class="line">&#125;</div><div class="line">cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<p>迭代器有<code>iterator</code>和<code>const_iterator</code>（只读）类型</p>
<p>可以使用auto让编译器自己判断类型</p>
<p><code>iterator</code>类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt;::iterator iter = v.begin(); //初始化为起始位置</div><div class="line"></div><div class="line">auto b = v.begin(), e = v.end(); //起始元素位置和最后一个元素后一个位置（尾迭代器）</div><div class="line"></div><div class="line">++iter; //迭代器自增移动</div><div class="line">--iter;//自减移动</div><div class="line"></div><div class="line">std::cout &lt;&lt; *iter; //使用解引用操作符（`*`操作符）访问元素</div></pre></td></tr></table></figure>
<p>循环迭代到最后一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(vector&lt;int&gt;::iterator iter = v.begin();iter != v.end();++iter)</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; *iter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>const_iterator</code>类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const vector&lt;int&gt; iv&#123;1,2,3,4,5&#125;;//当定义为常量容器时</div><div class="line">auto v = iv.begin(), ve = iv.end();//下面两句等价</div><div class="line">vector&lt;int&gt;:: const_iterator v = iv.begin(), ve = iv.end();</div></pre></td></tr></table></figure>
<p><code>cbigin</code>和<code>cend</code>获取<code>const_iterator</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto v = iv.begin(), ve = iv.end();</div></pre></td></tr></table></figure>
<p>元素访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;string&gt; iv&#123;&quot;hello&quot;,&quot;world&quot;,&quot;&quot;,&quot;ok&quot;&#125;;</div><div class="line">auto v = iv.begin(), ve = iv.end();</div><div class="line">(*v).empty();使用字符串的empty方法检查是否为空</div><div class="line">v -&gt; empty();和上面等价</div></pre></td></tr></table></figure>
<h3 id="bitset对象"><a href="#bitset对象" class="headerlink" title="bitset对象"></a><code>bitset</code>对象</h3><p><code>bitset</code>对象在头文件<code>bitset</code>中</p>
<p>定义<code>bitset</code>对象时指定长度： <code>bitset&lt;32&gt; b;</code></p>
<p><code>bitset</code>对象操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b.any</code></td>
<td>是否存在1</td>
</tr>
<tr>
<td><code>b.none</code></td>
<td>不存在1</td>
</tr>
<tr>
<td><code>b.count</code></td>
<td>1的个数，size_t类型（cstddef头文件中）</td>
</tr>
<tr>
<td><code>b.size</code></td>
<td>二进制位个数</td>
</tr>
<tr>
<td><code>b[pos]</code></td>
<td>pos位的二进制数</td>
</tr>
<tr>
<td><code>b.test(pos)</code></td>
<td>pos位是否为1</td>
</tr>
<tr>
<td><code>b.set</code></td>
<td>所有位置1</td>
</tr>
<tr>
<td><code>b.set(pos)</code></td>
<td>pos位置1</td>
</tr>
<tr>
<td><code>b.reset</code></td>
<td>所有位置0</td>
</tr>
<tr>
<td><code>b.reset(pos)</code></td>
<td>pos位置0</td>
</tr>
<tr>
<td><code>b.flip</code></td>
<td>取反</td>
</tr>
<tr>
<td><code>b.flip(pos)</code></td>
<td>pos位取反</td>
</tr>
<tr>
<td><code>b.to_ulong()</code></td>
<td>返回一个unsigned long 值</td>
</tr>
<tr>
<td><code>os &lt;&lt; b</code></td>
<td>输出到流</td>
</tr>
</tbody>
</table>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组定义和初始化"><a href="#数组定义和初始化" class="headerlink" title="数组定义和初始化"></a>数组定义和初始化</h2><ul>
<li>非const变量以及只有在运行后才能知道值的const变量不能用于定义数组维度</li>
<li>使用字符串初始化数组，默认在最后添加一个空字符 <code>&#39;\0&#39;</code>（C风格字符串）</li>
<li>如果数组元素类型为类，自动调用类默认构造函数初始化</li>
<li>定义数组必须指定数组类型，不能使用auto由初始值推导，数组元素为对象，所以不存在引用的数组</li>
<li>数组的索引是<code>size_t</code>类型</li>
<li>指针（指向数组元素）相减是<code>ptrdiff_t</code>类型（带符号）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p[10];//指针数组</div><div class="line">int (*p)[10];//数组指针</div><div class="line">int &amp;p[10];//错误，没有引用的数组</div><div class="line">int (&amp;p)[10];//数组的引用</div><div class="line">int *(&amp;p)[10];//指针数组的引用</div></pre></td></tr></table></figure>
<p>支持范围for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;</div><div class="line">for (int i: a)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++11标准引入begin和end函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;</div><div class="line">int *p = begin(a);</div><div class="line">int *pe = end(a);</div><div class="line">while(p != pe)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; *p &lt;&lt; endl;</div><div class="line">    ++p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以使用数组初始化<code>vector</code>，反过来不行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a[] = &#123;1,2,3,4,5&#125;</div><div class="line">vector&lt;int&gt; iv(begin(a), end(a))</div></pre></td></tr></table></figure>
<h2 id="C风格字符串标准库函数"><a href="#C风格字符串标准库函数" class="headerlink" title="C风格字符串标准库函数"></a>C风格字符串标准库函数</h2><p><code>cstring</code>是<code>string.h</code>头文件的C++版本</p>
<p>可以使用C风格字符串来初始化string对象，反过来不行</p>
<p>可以使用string的<code>c_string()</code>方法来初始化，不能保证一直有效，最好拷贝一份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string as(&quot;hello world&quot;);</div><div class="line">const char *str = as.c_str();//指针类型是const char*</div><div class="line">cout &lt;&lt; strlen(str) &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>C风格字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    const char *a = &quot;hello&quot;;</div><div class="line">    char b[] = &quot;world&quot;;</div><div class="line">    char d[40]; //要足够大，否则会出错</div><div class="line">    strcpy(d, b); //b拷贝给d</div><div class="line">    strcat(d,b); //b附加到d后面</div><div class="line">    std::cout  &lt;&lt;  strlen(a) &lt;&lt; std::endl;</div><div class="line">    std::cout  &lt;&lt;  strlen(b) &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C中使用<code>malloc</code>和<code>free</code>分配储存空间<br>C++中使用<code>new</code>和<code>delete</code></p>
<p><code>new</code>表达式返回指向新分配数组的第一个元素的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *pia = new int[10];</div></pre></td></tr></table></figure></p>
<p>如果数组元素具有类类型，使用默认构造函数进行初始化，或者使用括号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string *psa = new string[10];</div><div class="line">int *pib = new int[10]();</div></pre></td></tr></table></figure></p>
<p>数组长度可以在程序运行时动态决定，并且，长度0也是合法的</p>
<p>使用<code>delete</code>释放内存，<strong>注意</strong>方括号不能缺少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete [] pia;</div></pre></td></tr></table></figure></p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p><code>sizeof()</code></p>
<ul>
<li>返回类型所占字节数</li>
<li>返回指针本身所占空间大小</li>
<li>返回解引用指针所指对象大小，指针不需有效</li>
<li>返回整个数组所占空间大小</li>
<li>不会返回string和vector的元素所占空间，返回类型固定部分大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a[] = &#123;1,2,3,4,5,6,7&#125;;</div><div class="line">int *p = a;</div><div class="line">sizeof(a);//4*7=28</div><div class="line">sizeof(p);//28</div><div class="line">sizeof(*p);//4</div></pre></td></tr></table></figure>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>从左往右计算，丢弃左值，保留最右侧表达式的值</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>强制类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cast-name&lt;type&gt;(expression);</div></pre></td></tr></table></figure>
<p><code>cast-name</code>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种</p>
<p><code>static_cast</code><br>只要不包含底层<code>const</code>，就可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int i&#123;10&#125;, j&#123;19&#125;;</div><div class="line">double slope = static_cast&lt;double&gt;(j) / i;</div><div class="line">cout &lt;&lt; slope &lt;&lt; endl;//输出1.9</div><div class="line"></div><div class="line">//用于找回存在与void*指针中的值</div><div class="line">double d = 10;</div><div class="line">void *p = &amp;d;</div><div class="line">double *dp = static_cast&lt;double *&gt;(p);</div><div class="line">cout &lt;&lt; *dp &lt;&lt; endl;//输出10</div></pre></td></tr></table></figure>
<p><code>const_cast</code>只能改变对象的底层const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const int ci = 1;</div><div class="line">const int *cp = &amp;ci;</div><div class="line">int *p = const_cast&lt;int *&gt;(cp);</div><div class="line">*p += 1;</div><div class="line">cout &lt;&lt; ci &lt;&lt; *cp &lt;&lt; *p &lt;&lt; endl;//输出：1 2 2</div></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code>为运算对象的位模式提供较低层次上的重新解释</p>
<p>使用<code>reinterpret_cast</code>非常危险，本质上依赖机器</p>
<h1 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h1><p><code>throw</code> 语句用于抛出异常，可以使用<code>try</code>捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    try  </div><div class="line">    &#123;  </div><div class="line">        if (1)</div><div class="line">            throw 1;</div><div class="line">    &#125;  </div><div class="line">    catch(int i)  </div><div class="line">    &#123;  </div><div class="line">        cout &lt;&lt; i  &lt;&lt; endl;  </div><div class="line">    &#125;  </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用标准异常类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;exception&gt;  </div><div class="line">using namespace std;</div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    try  </div><div class="line">    &#123;  </div><div class="line">        int *myarray = new int[10000000000];</div><div class="line">    &#125;  </div><div class="line">    catch(exception&amp; e)  </div><div class="line">    &#123;  </div><div class="line">        cout &lt;&lt; e.what() &lt;&lt; endl;   //输出 std::bad_alloc</div><div class="line">    &#125;  </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>stdexcept</code>头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;stdexcept&gt;</div><div class="line">using namespace std;</div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int val(10);</div><div class="line">    if (val == 10)</div><div class="line">    &#123;</div><div class="line">        throw runtime_error(&quot;test err&quot;);//中断程序运行</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用try catch捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int val(10);</div><div class="line">    try</div><div class="line">    &#123;</div><div class="line">        if (val == 10)</div><div class="line">        &#123;</div><div class="line">            throw runtime_error(&quot;test err&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;catch (runtime_error err)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; err.what();</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl; //后面继续运行</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h3><p>引用形参，相当于将形参与实参绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void swap(int &amp;v1,int &amp;v2)</div><div class="line">&#123;</div><div class="line">    int temp = v2;</div><div class="line">    v2 = v1;</div><div class="line">    v1 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a(1),b(2);</div><div class="line">    swap(a,b);</div><div class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用const引用可以避免复制，提高效率</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bool longer(const string &amp;s1,const string &amp;s2)</div><div class="line">&#123;</div><div class="line">    return s1.size() &lt; s2.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不用修改参数，就把形参定义为const，否则传入const参数会出现编译错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt; </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool longer(string &amp;v1,string &amp;v2) //非const</div><div class="line">&#123;</div><div class="line">    return v1.size() &lt; v2.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    if(longer(&quot;asdasd&quot;,&quot;asdasda&quot;)) //编译出错</div><div class="line">    &#123;</div><div class="line">        //</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>指针引用</strong></p>
<p><code>int *&amp;v1</code>是指针引用形参，&amp;v1理解为指针，所以需要在前面添加<code>*</code>符号</p>
<p>从右往左读符号，最靠近变量名的有最直接影响</p>
<p>下例只交换了两个指针的地址，而a、b的内容并没有交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void swap(int *&amp;v1,int *&amp;v2)</div><div class="line">&#123;</div><div class="line">    int *temp = v2;</div><div class="line">    v2 = v1;</div><div class="line">    v1 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a(1),b(2);</div><div class="line">    int *pa = &amp;a;</div><div class="line">    int *pb = &amp;b;</div><div class="line">    cout &lt;&lt; *pa &lt;&lt; *pb &lt;&lt; endl; //1 2</div><div class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; //1 2</div><div class="line">    swap(pa,pb);</div><div class="line">    cout &lt;&lt; *pa &lt;&lt; *pb &lt;&lt; endl; // 2 1</div><div class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; // 1 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器形参"><a href="#迭代器形参" class="headerlink" title="迭代器形参"></a>迭代器形参</h3><p>vector等容器把迭代器作为参数传递，下例输出6个8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void print(</div><div class="line">    vector&lt;int&gt;::const_iterator beg,</div><div class="line">    vector&lt;int&gt;::const_iterator end</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    while (beg != end)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *beg++ &lt;&lt; &apos; &apos;; //++符具有更高优先级，== *(beg++)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    vector&lt;int&gt; v(6,8);</div><div class="line">    print(v.begin(),v.end());</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用标准库规范"><a href="#使用标准库规范" class="headerlink" title="使用标准库规范"></a>使用标准库规范</h3><p>传递指向数组首元素和尾后元素的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void print(const int *begin, const int *end)</div><div class="line">&#123;</div><div class="line">    while(begin != end)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *begin++ &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</div><div class="line">    print (begin(a), end(a));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>除了传递数组指针外，还可以使用引用传递数组<code>int (&amp;array)[]</code><br>引用后，array和a地址相同，即为同一个东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void print(int (&amp;array)[10])</div><div class="line">&#123;</div><div class="line">    for (auto i: array)</div><div class="line">        cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</div><div class="line">    print (a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注：</strong><br>    <code>int *array[10]</code> 是十个指针组成的数组 :指针数组<br>    <code>int (*array)[10]</code> 是十个元素的数组的指针:数组指针</p>
<h3 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h3><p>传递多维数组时需要传递两个维度的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//这两个是等价的</div><div class="line">void print(int (*array)[10], int rowsize)&#123; ... &#125;</div><div class="line">void print(int array[][10], int rowsize)&#123; ... &#125;</div></pre></td></tr></table></figure>
<h3 id="main函数传递参数"><a href="#main函数传递参数" class="headerlink" title="main函数传递参数"></a>main函数传递参数</h3><p><code>argv</code>是一个数组，0是文件名，往后是输入的参数，<code>argc</code>表示数组中字符串的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123;  </div><div class="line">    string s1, s2;</div><div class="line"></div><div class="line">    s1 = argv[1];</div><div class="line">    s2 = argv[2];</div><div class="line"></div><div class="line">    cout &lt;&lt; s1 + s2 &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./hello hello world</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld</div></pre></td></tr></table></figure></p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>如果所有参数类型相同，可以使用<code>initializer_list</code>标准库类型，在同名头文件中  (198页)</p>
<p>和vector不一样的是，该对象中的元素永远是常量值，无法改变元素值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void err_message(initializer_list&lt;string&gt; il)</div><div class="line">&#123;</div><div class="line">    for (auto beg = il.begin(); beg != il.end(); ++beg)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    err_message(&#123;&quot;test&quot;, &quot;err&quot;&#125;); //放在一对花括号内</div><div class="line">    err_message(&#123;&quot;func&quot;, &quot;test&quot;, &quot;ok&quot;&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数不能返回局部变量的引用或者指针，因为临时对象的空间已经释放<br>函数可以返回一个引用作为左值，注意函数返回类型是引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">char &amp;get_val(string &amp;str,string::size_type ix)</div><div class="line">&#123;</div><div class="line">    return str[ix];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    string s(&quot;asdasd&quot;);</div><div class="line">    get_val(s,0) = &apos;-&apos;;</div><div class="line">    cout &lt;&lt; s &lt;&lt; endl;//输出：-sdasd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>C++11新标准规定，函数可以返回花括号包围的值的列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vector&lt;string&gt; process()</div><div class="line">&#123;</div><div class="line">    return &#123;&quot;test&quot;, &quot;return&quot;, &quot;vector&quot;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    vector&lt;string&gt; sv = process();</div><div class="line">    for (auto s: sv)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; s &lt;&lt; endl; //输出：test return vector</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>注意 <code>char*</code>类型到<code>int</code>类型的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int fun(int val)</div><div class="line">&#123;</div><div class="line">    if (val != 1)</div><div class="line">    &#123;</div><div class="line">        return fun(val - 1) * val;</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123;  </div><div class="line">    int num = atoi(argv[1]); //类型转换</div><div class="line">    cout &lt;&lt; fun(num) &lt;&lt; endl; //输入：./hello 4 输出：24</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回数组的指针"><a href="#返回数组的指针" class="headerlink" title="返回数组的指针"></a>返回数组的指针</h3><p>声明一个数组指针函数 (205页)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int array[10];//含有10个元素的数组</div><div class="line">int (*p)[10] = &amp;array ;//数组的指针</div><div class="line">int (*func(int i))[10]; //返回数组指针的函数</div></pre></td></tr></table></figure>
<ul>
<li><code>func(int i)</code>函数接受一个整数实参</li>
<li><code>(*func(int i))</code>可以对函数调用结果进行解引用</li>
<li><code>(*func(int i))[10]</code>解引用后得到的是大小为10的数组</li>
<li><code>int (*func(int i))[10]</code>数组的元素类型为<code>int</code></li>
</ul>
<p>举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int array[10];</div><div class="line"></div><div class="line">int (*func(int i))[10] //接受一个参数，将数组的元素全部赋值为该值</div><div class="line">&#123;</div><div class="line">    int (*p)[10] = &amp;array;</div><div class="line">    for (auto &amp;elem: array)</div><div class="line">    &#123;</div><div class="line">        elem = i;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int (*pp)[10] = func(2); //接受参数2，返回一个数组的指针</div><div class="line">    for (auto elem: *pp)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; elem &lt;&lt; endl;//输出10个2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用尾置返回类型方式<br>C++11新标准使用<strong>尾置返回类型</strong>简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//func接受一个int类型实参，返回一个指针，这个指针指向含有10个整数元素的数组</div><div class="line">auto func(int i) -&gt; int(*)[10];</div></pre></td></tr></table></figure>
<p>函数改成这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">auto func(int i) -&gt; int(*)[10]</div><div class="line">&#123;</div><div class="line">    int (*p)[10] = &amp;array;</div><div class="line">    for (auto &amp;elem: array)</div><div class="line">    &#123;</div><div class="line">        elem = i;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果已经知道具体的数组，使用<code>decltype</code>获取类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int array[10];</div><div class="line"></div><div class="line">decltype(array) *func(int i) //decltype返回的是个数组，所以还需要添加*符号</div><div class="line">&#123;</div><div class="line">    int (*p)[10] = &amp;array;</div><div class="line">    for (auto &amp;elem: array)</div><div class="line">    &#123;</div><div class="line">        elem = i;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h2><p>重载函数是相同的函数名不同参数的函数，（main函数不能重载）<br>重载函数在参数数量或者参数类型上有所不同<br>不允许 “除了返回类型其他都相同” 的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void hi(const int i) //const int 参数</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int hi(const string str)//const string 参数</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; str &lt;&lt; endl;</div><div class="line">    return str.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    hi(hi(&quot;hello world&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h3><p>顶层<code>const</code>不影响传入函数的对象<br>引用和指针通过判断是否是常量区分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lookup(Phone);</div><div class="line">lookup(Phone const);//错误，重复声明了lookup(Phone)</div><div class="line"></div><div class="line">lookup(Phone *);</div><div class="line">lookup(Phone *const);//错误，重复声明了lookup(Phone *)</div><div class="line"></div><div class="line">lookup(Phone &amp;);//Phone的引用</div><div class="line">lookup(const Phone &amp;);//正确，常量引用</div><div class="line"></div><div class="line">lookup(Phone *);//指向Phone的指针</div><div class="line">lookup(const Phone *);//正确，指向常量的指针</div></pre></td></tr></table></figure>
<p><code>const_cast</code>在重载函数的情景中最有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const string &amp;shortstring(const string &amp;s1, const string &amp;s2) //接收常量</div><div class="line">&#123;</div><div class="line">    return s1.size() &lt;= s2.size() ? s1: s2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重载</div><div class="line">string &amp;shortstring(string &amp;s1, string &amp;s2) //接受string引用</div><div class="line">&#123;</div><div class="line">    auto &amp;r = shortstring(const_cast&lt;const string&amp;&gt;(s1),  </div><div class="line">        const_cast&lt;const string&amp;&gt;(s2)); //使用const_cast强制转换为常量</div><div class="line">    return const_cast&lt;string&amp;&gt;(r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    string s1&#123;&quot;hello&quot;&#125;;</div><div class="line">    string s2&#123;&quot;world!&quot;&#125;;</div><div class="line">    cout &lt;&lt; shortstring(s1,s2) &lt;&lt; endl;//传入string引用</div><div class="line">    cout &lt;&lt; shortstring(&quot;justfor&quot;,&quot;test&quot;) &lt;&lt; endl;//传入常量</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数可以避免函数调用的开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用inline关键词定义</div><div class="line">inline </div><div class="line">const string &amp;shortstring(const string &amp;s1, const string &amp;s2) </div><div class="line">&#123;</div><div class="line">    return s1.size() &lt;= s2.size() ? s1: s2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    cout &lt;&lt; shortstring(&quot;justfor&quot;,&quot;test&quot;) &lt;&lt; endl;//传入常量</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cout &lt;&lt;  s1.size() &lt;= s2.size() ? s1: s2 &lt;&lt; endl;</div></pre></td></tr></table></figure>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a><code>constexpr</code>函数</h3><p><code>constexpr</code>是指能用于常量表达式的函数，遵守以下规定：</p>
<ul>
<li>函数的返回类型和形参必须是字面值，或者可以是但不一定是另一个常量表达式函数</li>
<li>有且只有一个return语句</li>
<li>常量表达式函数和内联函数一般定义在头文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">constexpr int new_sz() &#123;return 2;&#125;</div><div class="line">constexpr int scale(int t) &#123;return new_sz() * t;&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int array[scale(2)]; //相当于int array[4]</div><div class="line">    cout &lt;&lt; scale(2) &lt;&lt; endl;//输出4</div><div class="line">    int i  = 2;</div><div class="line">    int a2[scale(i)] = &#123;1,2,3,4&#125;;//错误，scale(i)不是常量表达式</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><code>assert</code>预处理宏，定义在<code>cassert</code>头文件中<br>如果<code>expr</code>为假，输出信息，终止程序执行，如果<code>expr</code>为真，什么也不做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(expr)</div></pre></td></tr></table></figure>
<p>预处理宏由预处理器管理，无需使用<code>std::</code>和<code>using</code>声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int i = 0;</div><div class="line">    cin &gt;&gt; i;</div><div class="line">    assert(i &gt; 5);//如果输入3，输出：Assertion `i &gt; 5&apos; failed</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>assert</code>依赖于<code>NDEBUG</code>预处理变量的状态，如果定义了<code>NDEBUG</code>，<code>assert</code>什么也不做<br>编译器提供命令选项定义这个预处理变量，相当于在文件一开始写<code>#define NDEBUG</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ hello.cc -o hello -D NDEBUG</div></pre></td></tr></table></figure>
<p>也可以自己写调试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int i = 0;</div><div class="line">    cin &gt;&gt; i;</div><div class="line">    #ifndef NDEBUG</div><div class="line">        cout &lt;&lt; &quot;i is: &quot; &lt;&lt; i &lt;&lt; endl;</div><div class="line">    #endif</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>C++</code>编译器定义了一些局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__func__ 当前函数名，是const char的一个静态数组</div><div class="line">__FILE__ 存放文件名的字符串字面值</div><div class="line">__LINE__ 存放当前行号的整型字面值</div><div class="line">__TIME__ 存放文件编译时间的字符串字面值</div><div class="line">__DATE__ 存放文件编译日期的字符串字面值</div></pre></td></tr></table></figure>
<h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><p>精准匹配（相同、数组-&gt;指针、函数-&gt;指针、删除或添加顶层const） &gt; const转换 &gt; 类型提升 &gt; 标准转换（算术转换、指针转换） &gt; 类类型转换（219）</p>
<p>指针值（const char<em>）可以隐式转换为bool类型，为标准转换<br>指针值（const char</em>）到sting为类类型转换<br>所以第二个匹配度更高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void find(const string &amp;s1, const string &amp;s2, bool b = &quot;true&quot;)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;1&quot;  &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">void find(const string &amp;s, bool b = &quot;true&quot;)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    find(&quot;hello&quot;,&quot;world&quot;);//输出：2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数的类型由返回类型和形参类型共同决定，声明一个指向函数的指针，需要指定返回类型和形参类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bool (*pf) (const string &amp;, const string &amp;);//没有初始化的函数指针</div><div class="line">bool shortstring(const string &amp;, const string &amp;);//一个函数</div><div class="line">pf = shortstring;//pf指向shortstring函数</div><div class="line">pf = &amp;shortstring;//取址符是可选的</div><div class="line">pf(&quot;hello&quot;, &quot;world&quot;);//调用</div><div class="line">(*pf)(&quot;hello&quot;, &quot;world&quot;);//等价的</div></pre></td></tr></table></figure>
<p>和数组类型相似<br>虽然不能定义函数类型的形参，但是可以定义指向函数的指针的形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//第三个参数是形参类型，自动转换成函数指针（精准匹配）</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;))</div><div class="line">//第三个参数是个函数指针，等价</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;))</div><div class="line">//函数作为参数，自动转换</div><div class="line">whichshort(s1, s2, shortstring)</div></pre></td></tr></table></figure>
<p>使用decltype简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef decltype(shortstring) Fun;//函数类型</div><div class="line">typedef decltype(shortstring) *FunP;//函数指针</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, Fun);//下面俩和之前等价</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, FunP);</div></pre></td></tr></table></figure>
<p>虽然不能返回函数，但是可以返回函数指针，然而要写出返回类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//使用类型别名</div><div class="line">using F = int(int*, int);//函数类型</div><div class="line">using PF = int (*)(int*, int);//函数指针</div><div class="line">//定义</div><div class="line">PF f1(int);//返回函数指针的函数</div><div class="line">F *f1(int);//等价的</div><div class="line">//相当于</div><div class="line">//返回一个接受int* 和int参数返回int的函数的指针，接受一个int参数的函数</div><div class="line">int (*f1(int)) (int*, int);</div></pre></td></tr></table></figure></p>
<p>使用尾置返回类型的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto f1(int) -&gt; int(*)(int*, int);</div></pre></td></tr></table></figure>
<p>和返回数组指针类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto func(int i) -&gt; int(*)[10];</div></pre></td></tr></table></figure>
<p>使用decltype，注意<code>*</code>符号不能少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">decltype(fun) *f1(int);</div></pre></td></tr></table></figure></p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><p>定义一个自定义数据类型<code>Sales_data</code>，这并不是抽象数据类型，需要编写操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h3><ul>
<li>成员函数必须声明在内部，定义可以在外部或者内部，定义在内部的函数是隐式的（inline）</li>
<li>非成员函数必须定义和声明在外部</li>
<li>即使数据成员定义在成员函数之后，也可以使用数据，编译器首先编译成员的声明，然后才是成员函数体</li>
<li>外部定义的成员函数除了与声明必须匹配外，必须包含类名</li>
<li><code>combine()</code>函数类似于<code>+=</code>，返回的是<code>this</code>对象，即调用这个函数的对象，像这样调用<code>some.combine(another);</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    //成员函数</div><div class="line">    string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">    //数据成员</div><div class="line">    string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//非成员函数</div><div class="line">Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</div><div class="line">ostream &amp;print(ostream&amp;, const Sales_data);</div><div class="line">istream &amp;read(istream&amp;, const Sales_data);</div><div class="line">//外部定义成员函数</div><div class="line">Sales_data&amp; Sales_data::combine(const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    unit += sd.unit; //将 sd 的成员加到 this 的对象上</div><div class="line">    revenue += sd.revenue;</div><div class="line">    return *this; //返回调用这个函数的对象</div><div class="line">&#125;</div><div class="line">double Sales_data::avg_price() const</div><div class="line">&#123;</div><div class="line">    if (unit)</div><div class="line">        return revenue/unit;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>some.getname()</code>就相当于<code>getname(&amp;some)</code></li>
<li>成员函数通过一个隐式的<code>this</code>参数来访问对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string getname() const &#123;return name;&#125;</div><div class="line">//上面这句也可以这么定义，但一般不这么做</div><div class="line">string getname() const &#123;return this -&gt; name;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>getname()</code>函数后有一个<code>const</code>关键字，作用是修改隐式<code>this</code>指针的类型</li>
<li>默认情况下，<code>this</code>的类型是指向类类型的常量指针<code>Sales_data *const</code></li>
<li><code>getname()</code>函数不会修改<code>this</code>所指对象，因此应该把this设置为指向常量指针</li>
<li>即<code>const Sales_data *const</code></li>
<li><code>const</code>关键字位置是紧跟在参数列表后</li>
</ul>
<h3 id="定义非成员函数"><a href="#定义非成员函数" class="headerlink" title="定义非成员函数"></a>定义非成员函数</h3><ul>
<li>一般把一些辅助函数，比如add、read和print等定义为非成员函数</li>
<li>定义非成员函数也和其他函数一样，通常把函数的声明和定义分开</li>
<li>因为IO类型不能被复制，所以用引用作为参数</li>
<li><code>print()</code>不负责换行，一般来说，执行输出的函数应该尽量减少对格式的控制，由用户决定</li>
<li>调用方式：<code>read(cin, some)</code>、<code>print(cout, some) &lt;&lt; endl</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">istream &amp;read(istream &amp;is, Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    double price = 0;</div><div class="line">    is &gt;&gt; sd.name &gt;&gt; sd.unit &gt;&gt; price;</div><div class="line">    sd.revenue = price * sd.unit;</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ostream &amp;print(ostream &amp;os, const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; sd.getname() &lt;&lt; &quot; &quot; &lt;&lt; sd.unit &lt;&lt; &quot; &quot;</div><div class="line">        &lt;&lt; sd.revenue &lt;&lt; &quot; &quot; &lt;&lt; sd.avg_price();</div><div class="line">    return os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>add()</code>函数中，使用<code>sd1</code>来初始化<code>sum</code></li>
<li>然后调用<code>combine()</code>函数把<code>sd2</code>数据成员加到<code>sum</code>中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    Sales_data sum = sd1; //把sd1的数据成员拷贝给sum</div><div class="line">    sum.combine(sd2); //相当于 +=</div><div class="line">    return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>构造函数的任务是初始化类对象的数据成员，类创建时执行</li>
<li>构造函数的名字和类名相同，没有返回类型，不能声明为<code>const</code></li>
<li>如果类定义没有提供初始值，编译器隐式定义一个默认构造函数<ul>
<li>如果类内成员有初始值，使用其初始化</li>
<li>否则，默认初始化该成员</li>
</ul>
</li>
<li>如果一个构造函数为所有形参提供了默认参数，也相当于是个默认构造函数</li>
<li>构造函数类似重载函数，类可以包含多个构造函数<ul>
<li><code>= default</code>是C++新标准，表示要求编译器生成默认构造函数</li>
<li>如果定义了其他构造函数而不指明<code>=default</code>，使用默认构造函数将出错</li>
<li>括号内为参数（可能为空），花括号内是函数体（可能为空）</li>
<li>之间的是构造函数初始值列表</li>
</ul>
</li>
<li>如果是const、引用或未提供默认构造函数的类类型，必须通过构造函数初始化列表而非赋值提供初值</li>
<li>在构造函数前加关键字<code>explicit</code>可以阻止隐式转换</li>
<li>函数前加<code>~</code>是析构函数，对象删除时自动调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">    //数据成员</div><div class="line">    string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//外部定义构造函数，初始值列表为空，函数体进行初始化</div><div class="line">Sales_data::Sales_data(istream &amp;is)</div><div class="line">&#123;</div><div class="line">    read(is, *this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用构造函数初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data sd1; //默认构造函数，初始化为：&apos;&apos; 0 0</div><div class="line">Sales_data sd2(&quot;hello&quot;); //初始化为：&apos;hello&apos; 0 0</div><div class="line">Sales_data sd3(&quot;hello&quot;, 2, 2); //初始化为：&apos;hello&apos; 2 4</div><div class="line">Sales_data sd4(cin); //根据输入初始化</div><div class="line"></div><div class="line">print(cout, sd3) &lt;&lt; endl; //输出：hello 2 4 2ll</div></pre></td></tr></table></figure></p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//非委托构造函数</div><div class="line">Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">    name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">//委托构造函数</div><div class="line">Sales_data() : Sales_data(&quot;&quot;, 0, 0) &#123;&#125;</div><div class="line">Sales_data(std::string s) : Sales_data(s, 0, 0) &#123;&#125;</div><div class="line">Sales_data (std::istream &amp;is) : Sales_data() &#123;read(is, *this);&#125;</div></pre></td></tr></table></figure>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul>
<li>类结构体定义和非成员函数声明放在<code>sales_data.h</code>中</li>
<li>注意，不要在头文件中使用<code>using namespace std;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#ifndef SALES_DATA_H</div><div class="line">#define SALES_DATA_H </div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"></div><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const std::string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (std::istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">    //数据成员</div><div class="line">    std::string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//非成员函数声明</div><div class="line">std::istream &amp;read(std::istream &amp;is, Sales_data &amp;sd);</div><div class="line">std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;sd);</div><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<ul>
<li>外部定义的成员函数和非成员函数放在<code>sales_data.cc</code>中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &quot;sales_data.h&quot;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">//外部定义成员函数</div><div class="line">Sales_data&amp; Sales_data::combine(const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    unit += sd.unit;</div><div class="line">    revenue += sd.revenue;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line">double Sales_data::avg_price() const</div><div class="line">&#123;</div><div class="line">    if (unit)</div><div class="line">        return revenue/unit;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义非成员函数</div><div class="line">istream &amp;read(istream &amp;is, Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    double price = 0;</div><div class="line">    is &gt;&gt; sd.name &gt;&gt; sd.unit &gt;&gt; price;</div><div class="line">    sd.revenue = price * sd.unit;</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ostream &amp;print(ostream &amp;os, const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; sd.getname() &lt;&lt; &quot; &quot; &lt;&lt; sd.unit &lt;&lt; &quot; &quot;</div><div class="line">        &lt;&lt; sd.revenue &lt;&lt; &quot; &quot; &lt;&lt; sd.avg_price();</div><div class="line">    return os;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    Sales_data sum = sd1;</div><div class="line">    sum.combine(sd2);</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//外部定义构造函数</div><div class="line">Sales_data::Sales_data(istream &amp;is)</div><div class="line">&#123;</div><div class="line">    read(is, *this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在主文件使用include导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &quot;sales_data.h&quot;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    Sales_data sd(cin);</div><div class="line">    print(cout, sd) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="访问控制和封装"><a href="#访问控制和封装" class="headerlink" title="访问控制和封装"></a>访问控制和封装</h2><ul>
<li>自定义数据类型没有强制要求使用接口，仍可访问对象内部</li>
<li>使用访问说明符加强类的封装性<ul>
<li>定义在<code>public</code>说明符后的成员可以在整个程序内被访问</li>
<li>定义在<code>private</code>说明符后的成员只能被类的成员函数访问，即隐藏了类的实现细节</li>
</ul>
</li>
</ul>
<p>当使用<code>class</code>关键字，并且添加了<code>private</code>说明符之后，部分函数（非成员函数）不能正常编译了<br><code>class</code>和<code>struct</code>关键字唯一区别是默认访问权限变化了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const std::string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (std::istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    std::string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>类类型</p>
<ul>
<li>类可以在定义之前声明，比如：<code>class Salse_data;</code></li>
<li>不过注意在声明之后、定义之前，编译器并不清楚类的具体内容（不完全类型），期间不能使用其成员</li>
<li>成员函数体在整个类成员可见之后才被处理</li>
<li>类型名的定义通常出现在类的开始处，确保使用该类型的成员都出现在类型名定义之后</li>
</ul>
<p>友元</p>
<ul>
<li>类也可以让其他类或者函数访问它的非公有成员，可以把函数声明为友元</li>
<li>声明为友元，需要添加一条以关键字<code>friend</code>开头的函数声明</li>
<li>友元声明可以出现在类内的任意位置，但最好在类定义开头或者结尾集中声明</li>
<li>友元的声明仅仅指定了访问权限，所以还需要再次声明以供用户调用</li>
<li>指定一个类作为友元，那么那个类就可以访问此类的所有成员</li>
<li><code>All_date</code>就是<code>Sales_data</code>的友元，<code>All_data</code>内成员函数可以调用<code>Sales_data</code>所有成员</li>
<li>注意友元没有传递性，<code>Salses_data</code>的友元的友元并不能访问其内部成员</li>
<li>如果只将某个类的某个成员函数声明为友元，需要注意步骤<ul>
<li>先定义<code>All_data</code>类，声明但不定义<code>clear()</code>函数，如果用到<code>Sales_data</code>类，需要先申明<code>class Salse_data</code></li>
<li>然后定义<code>Salse_data</code>类，声明<code>clear()</code>友元，注意在定义之前不能访问类内成员</li>
<li>最后再定义<code>clear()</code>函数<br>-如果将重载函数声明为友元，需要将每个函数依次声明</li>
</ul>
</li>
</ul>
<p>正常的声明友元<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">//非成员函数友元声明</div><div class="line">friend std::istream &amp;read(std::istream &amp;is, Sales_data &amp;sd);</div><div class="line">friend std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;sd);</div><div class="line">friend Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line">friend class All_data;//友元类</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const std::string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (std::istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    std::string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//非成员函数声明</div><div class="line">std::istream &amp;read(std::istream &amp;is, Sales_data &amp;sd);</div><div class="line">std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;sd);</div><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line"></div><div class="line">class All_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using SaleIndex = std::vector&lt;Sales_data&gt;::size_type; //容器index类型</div><div class="line">    void clear(SaleIndex i);</div><div class="line">private:</div><div class="line">    std::vector&lt;Sales_data&gt; sales_datas&#123;Sales_data(&quot;hello&quot;,2,2)&#125;; //存放Salse_data的容器</div><div class="line">&#125;;</div><div class="line"></div><div class="line">inline</div><div class="line">void All_data::clear(SaleIndex i) //清空容器内某个Salse_date类型的内容</div><div class="line">&#123;</div><div class="line">    Sales_data &amp;sd = sales_datas[i];</div><div class="line">    sd.name = std::string(&quot;&quot;);</div><div class="line">    sd.unit = 0;</div><div class="line">    sd.revenue = 0;</div><div class="line">    sd.num = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只将类的某个成员函数声明为友元<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Sales_data; //因为用到`Sales_data`，需要先声明</div><div class="line"></div><div class="line">class All_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using SaleIndex = std::vector&lt;Sales_data&gt;::size_type;</div><div class="line">    void clear(SaleIndex i); //声明 clear 函数</div><div class="line">    Sales_data &amp; getSale(SaleIndex i) &#123;Sales_data &amp;sd = sales_datas[i]; return sd;&#125;</div><div class="line">private:</div><div class="line">    std::vector&lt;Sales_data&gt; sales_datas; //因为`Sales_data`还没有定义，并不能初始化</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Sales_data //定义 Sales_data 类</div><div class="line">&#123;</div><div class="line">friend class All_data;</div><div class="line">/* ... */</div><div class="line">&#125;;</div><div class="line">/* ... */</div><div class="line"></div><div class="line">inline</div><div class="line">void All_data::clear(SaleIndex i) //定义 clear 函数</div><div class="line">&#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>定义在内部的成员函数默认为内联函数（inline），也可以指定外部定义的成员函数为（inline）</li>
<li>注意外部定义的inline成员函数应该与类定义放在同一个文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">inline</div><div class="line">Sales_data&amp; Sales_data::combine(const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    unit += sd.unit;</div><div class="line">    revenue += sd.revenue;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line">inline</div><div class="line">double Sales_data::avg_price() const</div><div class="line">&#123;</div><div class="line">    if (unit)</div><div class="line">        return revenue/unit;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>成员函数可以被重载，这里重载了<code>numadd()</code>函数</li>
<li>即使是const成员函数，也可以修改数据成员，只要加上<code>mutable</code>关键字（mutable data member 可变数据成员）</li>
<li>当调用<code>sd.numadd()</code>时，数据成员<code>num</code>自增 1，同样的<code>sd.numadd(3)</code>自增3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    /* ... */</div><div class="line">    //成员函数</div><div class="line">    void numadd() const &#123;++num;&#125;</div><div class="line">    void numadd(int i) const &#123;num += i;&#125;</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    /* ... */</div><div class="line">    mutable int num = 0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>返回<code>*this</code>的成员函数可以实现链式调用：比如<code>myScreen.move(4,0).set(&#39;*&#39;)</code></li>
<li>如果其中有一个成员设置了<code>const</code>关键字，链式调用时会报错，因为返回的是常量引用，后续不能进行写入操作</li>
<li>通过重载可以解决这种问题</li>
<li><code>do_display()</code>函数无论是不是常量引用，都隐式转换成常量引用，然后输出</li>
<li>使用<code>do_dispay()</code>避免多处重复同样的代码，功能明显，方便调试，隐式被声明为内联函数，运行时没有额外开销</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">/* ... */</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    /* ... */</div><div class="line">    Sales_data &amp;addnum() &#123;++num; return *this;&#125;</div><div class="line">    Sales_data &amp;addnum(int i) &#123;num += i; return *this;&#125;</div><div class="line">    Sales_data &amp;display(std::ostream &amp;os)&#123;do_display(os); return *this;&#125; //返回一个非常量引用</div><div class="line">    const Sales_data &amp;display(std::ostream &amp;os) const &#123;do_display(os); return *this;&#125; //返回一个常量引用</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    /* ... */</div><div class="line">    void do_display(std::ostream &amp;os) const &#123;os &lt;&lt; name &lt;&lt; &quot; num &quot; &lt;&lt; num;&#125; //提供给内部成员函数调用</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>链式调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Sales_data sd(&quot;hello&quot;, 2, 2);</div><div class="line">sd.display(cout).addnum(10).display(cout); //这里是非常量引用</div></pre></td></tr></table></figure></p>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><ul>
<li>静态成员可以是<code>public</code>或者<code>private</code>的</li>
<li>静态成员函数不包含<code>this</code>指针，不能声明成<code>const</code></li>
<li>静态成员不与任何对象绑定在一起，使用域运算符直接访问<code>Sales_data::count</code></li>
<li>可以在类的内部或者外部定义静态成员函数</li>
<li>外部定义静态成员时，不能重复<code>static</code>关键字，该关键字只能出现在内部声明语句中</li>
<li>静态数据成员不由类的构造函数初始化，必须在类的外部定义和初始化每个静态成员，<code>int Sales_data::count = 0;</code></li>
<li>静态数据成员的定义最好和非内联函数放在一个文件中，<code>sales_data.cc</code></li>
<li>通常情况下，类的静态成员不应该在类内初始化，如果是字面值常量类型的<code>constexpr</code>，可以提供<code>const</code>初始值</li>
<li>例如：<code>static constexpr int period = 30</code>，用于类内定义维度<code>double array[period]</code></li>
</ul>
<p>静态成员的声明和定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    static int getcount() &#123;return count;&#125; //没有const关键字</div><div class="line">    static void addcount() &#123;count += 1;&#125;</div><div class="line">private:</div><div class="line">    static int count; //内部声明，外部定义</div><div class="line">    static constexpr int period = 20; //字面值常量类型的constexpr，内部定义并初始化</div><div class="line">    double array[period]; //使用静态成员作为维度</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>外部定义静态成员，文件<code>Salse_data.cc</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &quot;sales_data.h&quot;</div><div class="line"></div><div class="line">int Sales_data::count = 0;</div><div class="line"></div><div class="line">//定义非成员函数</div><div class="line">/* ... */</div></pre></td></tr></table></figure></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-08-31</span><i class="fa fa-tag"></i><a href="/tags/c-plus/" title="c_plus" class="tag">c_plus </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2016/08/31/Note/cpp/cpp_primer_part1/,Harryx,C++ Primer,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/09/29/Note/python/demo/wxbot/" title="wxBot微信机器人框架" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/07/11/Note/python/language/decorator/" title="装饰器" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="HeRui"><title>Haskell 函数式编程 (一) · Harryx</title><meta name="description" content="简述Haskell 是一种函数式编程语言
参考:Haskell 趣学指南Real World Haskell阮一峰的网络日志
函数式编程函数式编程主要思想是把运算过程尽量写成一系列嵌套的函数调用

函数是第一公民函数和其他数据类型相同，可以赋值或者作为参数

只用表达式，不用语句每一步都是远算，并且"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Harryx</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Haskell 函数式编程 (一)</a></h3></div><div class="post-content"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Haskell 是一种函数式编程语言</p>
<p>参考:<br><a href="http://fleurer-lee.com/lyah/" target="_blank" rel="external">Haskell 趣学指南</a><br><a href="http://cnhaskell.com/" target="_blank" rel="external">Real World Haskell</a><br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">阮一峰的网络日志</a></p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程主要思想是把运算过程尽量写成一系列嵌套的函数调用</p>
<ol>
<li><p><strong>函数是第一公民</strong><br>函数和其他数据类型相同，可以赋值或者作为参数</p>
</li>
<li><p><strong>只用表达式，不用语句</strong><br>每一步都是远算，并且都有返回值，避免不必要的读写(I/O)</p>
</li>
<li><p><strong>没有副作用</strong><br>函数只会返回一个值，不会改变其他外部变量</p>
</li>
<li><p><strong>不修改状态</strong><br>不修改变量，使用参数保存状态</p>
</li>
<li><p><strong>引用透明</strong><br>函数的运行不依赖外部变量，只依赖于输入参数</p>
</li>
</ol>
<h1 id="Haskell环境"><a href="#Haskell环境" class="headerlink" title="Haskell环境"></a>Haskell环境</h1><p>Haskell 使用的编译器是ghc，命令行输入ghci 进入交互界面</p>
<p>自定义提示符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :set prompt &quot;gchi&gt; &quot;</div><div class="line">gchi&gt;</div></pre></td></tr></table></figure></p>
<p>使用<code>:l</code>从外部导入一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gchi&gt;  :l test.hs</div></pre></td></tr></table></figure></p>
<p>使用<code>:m</code>从外部导入一个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :m +Data.Ratio</div><div class="line">Prelude Data.Ratio&gt;</div></pre></td></tr></table></figure></p>
<p>设置每次返回结果类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :set +t</div><div class="line">Prelude&gt; 2</div><div class="line">2</div><div class="line">it :: Integer</div></pre></td></tr></table></figure></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h3><p>Haskell 使用空格调用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gchi&gt; succ 1</div><div class="line">2</div></pre></td></tr></table></figure></p>
<p>在交互界面使用let和脚本中定义是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gchi&gt; let add x y = x+y</div><div class="line">gchi&gt; add 1 2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>字符串或者数组的拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gchi&gt; let a=[1,2,3,4,5]</div><div class="line">gchi&gt; a++a</div><div class="line">[1,2,3,4,5,1,2,3,4,5]</div><div class="line">gchi&gt; 1:a</div><div class="line">[1,1,2,3,4,5]</div><div class="line">gchi&gt; null a</div><div class="line">False</div><div class="line">gchi&gt; null []</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>字符串转义<br>putStrLn用于打印一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; putStrLn&quot;lalala\n\tlalala&quot;</div><div class="line">lalala</div><div class="line">	lalala</div></pre></td></tr></table></figure></p>
<p>长度，比较符是比较长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gchi&gt; length a</div><div class="line">5</div><div class="line">gchi&gt; a &gt; [1,3]</div><div class="line">False</div></pre></td></tr></table></figure></p>
<p>读取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">gchi&gt; a</div><div class="line">[1,2,3,4,5]</div><div class="line">gchi&gt; head a</div><div class="line">1</div><div class="line">gchi&gt; tail a</div><div class="line">[2,3,4,5]</div><div class="line">gchi&gt; last a</div><div class="line">5</div><div class="line">gchi&gt; init a</div><div class="line">[1,2,3,4]</div><div class="line">gchi&gt; take 3 a</div><div class="line">[1,2,3]</div><div class="line">ghci&gt;drop 2 a</div><div class="line">[3,4,5]</div><div class="line">gchi&gt; maximum a</div><div class="line">5</div><div class="line">gchi&gt; minimum a</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>其他操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gchi&gt; a</div><div class="line">[1,2,3,4,5]</div><div class="line">gchi&gt; reverse a</div><div class="line">[5,4,3,2,1]</div><div class="line">gchi&gt; sum a</div><div class="line">15</div></pre></td></tr></table></figure></p>
<p>建立数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gchi&gt; [1..10]</div><div class="line">[1,2,3,4,5,6,7,8,9,10]</div><div class="line">gchi&gt; [1,3..10]</div><div class="line">[1,3,5,7,9]</div><div class="line">gchi&gt; cycle[1,2,3]</div><div class="line">1,2,3死循环</div><div class="line">gchi&gt; repeat 10</div><div class="line">10 死循环</div></pre></td></tr></table></figure></p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>可以添加任意多个限制条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">gchi&gt; [x*2 | x &lt;- [1..10]]</div><div class="line">[2,4,6,8,10,12,14,16,18,20]</div><div class="line"></div><div class="line">gchi&gt; [x*2 | x &lt;- [1..10],x*2&gt;10]</div><div class="line">[12,14,16,18,20]</div><div class="line"></div><div class="line">Prelude&gt; [x | x &lt;- [50..100], x `elem` [60..70]]</div><div class="line">[60,61,62,63,64,65,66,67,68,69,70]</div><div class="line"></div><div class="line">Prelude&gt; [x | x &lt;- [50..100], x `mod` 10 ==0]</div><div class="line">[50,60,70,80,90,100]</div><div class="line"></div><div class="line">Prelude&gt; [x | x &lt;- [50..60], odd x]</div><div class="line">[51,53,55,57,59]</div><div class="line"></div><div class="line">Prelude&gt; [x*y | x &lt;- [1..5],y &lt;- [3..7]]</div><div class="line">[3,4,5,6,7,6,8,10,12,14,9,12,15,18,21,12,16,20,24,28,15,20,25,30,35]</div></pre></td></tr></table></figure></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组(tuple)内容可以是不同类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; (1,&apos;a&apos;,&quot;asd&quot;,[1,2])</div><div class="line">(1,&apos;a&apos;,&quot;asd&quot;,[1,2])</div></pre></td></tr></table></figure></p>
<h4 id="序对"><a href="#序对" class="headerlink" title="序对"></a>序对</h4><p>序对就是有两个元素的元组</p>
<p>使用fst和snd获得序对元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; fst (1,&quot;dfgh&quot;)</div><div class="line">1</div><div class="line">Prelude&gt; snd (1,&quot;dfgh&quot;)</div><div class="line">&quot;dfgh&quot;</div></pre></td></tr></table></figure></p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>打包两个list，来生成一组序对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; zip [1,2,3,4] [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</div><div class="line">[(1,&apos;a&apos;),(2,&apos;b&apos;),(3,&apos;c&apos;),(4,&apos;d&apos;)]</div></pre></td></tr></table></figure></p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>数值类型首字母大写，变量首字母小写<br>整数：Integer<br>分数：Ratio Integer<br>分数使用操作符 % 构建</p>
<h3 id="Haskell类型特点"><a href="#Haskell类型特点" class="headerlink" title="Haskell类型特点"></a>Haskell类型特点</h3><h4 id="强类型"><a href="#强类型" class="headerlink" title="强类型"></a>强类型</h4><p>拒绝执行无意义的表达式，类型错误会在编译时显示</p>
<h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><p>编译器在编译时便直到所有值和表达式的类型</p>
<h4 id="类型推到"><a href="#类型推到" class="headerlink" title="类型推到"></a>类型推到</h4><p>编译器自动推断出所有表达式类型</p>
<h3 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t &quot;asdads&quot;</div><div class="line">&quot;asdads&quot; :: [Char]</div><div class="line"></div><div class="line">Prelude&gt; :t (123,&quot;asd&quot;,[1,2,3])</div><div class="line">(123,&quot;asd&quot;,[1,2,3]) :: (Num t, Num t1) =&gt; (t, [Char], [t1])</div></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; lines &quot;lalala\nlalala\nlalala\tlalala\n&quot;</div><div class="line">[&quot;lalala&quot;,&quot;lalala&quot;,&quot;lalala\tlalala&quot;]</div><div class="line">it :: [String]</div><div class="line">Prelude&gt; :t lines</div><div class="line">lines :: String -&gt; [String]</div></pre></td></tr></table></figure>
<p>这里的<code>-&gt;</code>可以读作映射</p>
<p>类型a是个类型变量，指的是可以取任意类型</p>
<p>fst将两个类型作为参数，返回第一个项的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t fst</div><div class="line">fst :: (a, b) -&gt; a</div></pre></td></tr></table></figure></p>
<p>不纯函数（受环境变量影响的函数）的类型以IO开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t readFile</div><div class="line">readFile :: FilePath -&gt; IO String</div></pre></td></tr></table></figure></p>
<p>在定义函数前声明类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">testCase :: Bool -&gt; Bool </div><div class="line">testCase value =</div><div class="line">    case value of</div><div class="line">        True -&gt; False</div><div class="line">        False -&gt; True</div></pre></td></tr></table></figure></p>
<h3 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h3><p>只有属于响应的类型类才能使用相应的方法</p>
<p>Eq：判断相等<br>Ord：比较大小<br>Show：可用字符串表示<br>Read：字符串转化为一个类型<br>Enum：可枚举<br>Bounded：成员有上下限<br>Num：数字<br>Intergral：数字<br>Floating：浮点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*Main&gt; read &quot;12&quot; :: Int</div><div class="line">12</div><div class="line">*Main&gt; read &quot;12&quot; :: Float</div><div class="line">12.0</div></pre></td></tr></table></figure>
<p>使用逗号可以给函数添加多个约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">checkReverse :: (Eq a,Num a) =&gt; [a] -&gt; Bool</div><div class="line">checkReverse xs = if null xs</div><div class="line">    then True</div><div class="line">    else if xs == (reverse xs)</div><div class="line">        then True</div><div class="line">        else False</div></pre></td></tr></table></figure>
<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><p>Int：表示整数，有上限<br>Integer：无边界整数<br>Float ：浮点数<br>Double：双精度浮点数<br>Bool：布尔值<br>Char：一个字符<br>Haskell有个特殊的类型：<code>()</code>表示一个空元组</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Haskell里变量不能多次赋值</p>
<p>文件：test.hs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x=20</div><div class="line">x=10</div></pre></td></tr></table></figure></p>
<p>导入出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t readFile</div><div class="line">readFile :: FilePath -&gt; IO String</div><div class="line">Prelude&gt; :l test.hs</div><div class="line">[1 of 1] Compiling Main             ( test.hs, interpreted )</div><div class="line"></div><div class="line">test.hs:2:1:</div><div class="line">    Multiple declarations of `x&apos;</div><div class="line">    Declared at: test.hs:1:1</div><div class="line">                 test.hs:2:1</div><div class="line">Failed, modules loaded: none.</div></pre></td></tr></table></figure></p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>在Haskell中，代码缩进预示着一个定义的延续，非常重要</p>
<p>不同分支的类型必须相同，否则会出错<br>同样的，也不能省略分支</p>
<p>自定义一个drop函数，null用于检查列表是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">myDrop n xs = if n&lt;=0 || null xs</div><div class="line">    then xs</div><div class="line">    else myDrop (n-1) (tail xs)</div><div class="line"></div><div class="line">*Main&gt; myDrop 2 [1,2,3,4,5,6]</div><div class="line">[3,4,5,6]</div></pre></td></tr></table></figure></p>
<p>用Python实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def myDrop(n,xs):</div><div class="line">    if n&lt;=0 or len(xs)==0:</div><div class="line">        return xs</div><div class="line">    else:</div><div class="line">        return myDrop(n-1,xs[1:])</div><div class="line"></div><div class="line">print myDrop(2,[1,2,3,4])</div></pre></td></tr></table></figure></p>
<h1 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h1><h2 id="自定义新的数据类型"><a href="#自定义新的数据类型" class="headerlink" title="自定义新的数据类型"></a>自定义新的数据类型</h2><p>使用<code>data</code>关键字定义新的数据类型</p>
<p><code>BookInfo</code>是类型名，<code>Book</code>是值构造器的名字<br>类型名和值构造器命名不会冲突</p>
<p>之后的是类型的组成部分</p>
<p>注意：相同结构的不同类型也是区别对待的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">data BookInfo = Book Int String [String]</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">myBook = Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]</div><div class="line"></div><div class="line">*Main&gt; myBook</div><div class="line">Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]</div><div class="line"></div><div class="line">*Main&gt; :t myBook</div><div class="line">myBook :: BookInfo</div><div class="line"></div><div class="line">*Main&gt; :info BookInfo</div><div class="line">data BookInfo = Book Int String [String]    -- Defined at test.hs:9:6</div><div class="line">instance Show BookInfo -- Defined at test.hs:10:14</div><div class="line"></div><div class="line">*Main&gt; :t Book</div><div class="line">Book :: Int -&gt; String -&gt; [String] -&gt; BookInfo</div></pre></td></tr></table></figure></p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><code>type</code>关键字给<strong>已存在</strong>的类型添加别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type CustomerID = Int</div><div class="line">type ReviewBody = String</div><div class="line"></div><div class="line">data BookReview = BookReview BookInfo CustomerID ReviewBody</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">myBookReview = BookReview myBook 3 &quot;hello harryx&quot;</div><div class="line"></div><div class="line">*Main&gt; myBookReview</div><div class="line">BookReview (Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]) 3 &quot;hello harryx&quot;</div></pre></td></tr></table></figure>
<h2 id="代数数据类型"><a href="#代数数据类型" class="headerlink" title="代数数据类型"></a>代数数据类型</h2><p>Bool类型是代数数据类型<strong>（algebraic data type）</strong>最简单的例子</p>
<p><code>Bool</code>有两个值构造器，分别是<code>False</code>和<code>True</code>，用 <code>|</code> 分为两个分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data Bool = False | True</div></pre></td></tr></table></figure>
<p><code>BookPay</code>类型提供三种值构造器</p>
<p>分别对应信用卡、支付宝、现金三种方式</p>
<p>不同值构造器所需的参数可能不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">type CardNumber = String</div><div class="line">type AlipayNumber = String</div><div class="line">type  Address = [String]</div><div class="line">data BookPay = Card CardNumber</div><div class="line">    | Alipay AlipayNumber</div><div class="line">    | Cash Address</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">*Main&gt; :info BookPay</div><div class="line">data BookPay = Card CardNumber | Alipay AlipayNumber | Cash Address</div><div class="line">    -- Defined at test.hs:21:6</div><div class="line">instance Show BookPay -- Defined at test.hs:24:14</div><div class="line"></div><div class="line">*Main&gt; :t Cash</div><div class="line">Cash :: Address -&gt; BookPay</div><div class="line"></div><div class="line">*Main&gt; let myPay = Cash [&quot;China&quot;,&quot;JS&quot;]</div><div class="line">*Main&gt; myPay</div><div class="line">Cash [&quot;China&quot;,&quot;JS&quot;]</div></pre></td></tr></table></figure>
<h3 id="元组和代数数据类型"><a href="#元组和代数数据类型" class="headerlink" title="元组和代数数据类型"></a>元组和代数数据类型</h3><p>和代数类型不同，如果元组的结构相同，那么元组的类型也相同</p>
<p>使用上面的例子，即使结构都是一个String，类型名都是Book，仍然区分为不同类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">type CardNumber = String</div><div class="line">type AlipayNumber = String</div><div class="line">type  Address = [String]</div><div class="line">data BookPay = Card CardNumber</div><div class="line">    | Alipay AlipayNumber</div><div class="line">    | Cash Address</div><div class="line">    deriving(Eq,Show)</div><div class="line"></div><div class="line">myPay = Alipay &quot;123&quot;</div><div class="line">yourPay = Alipay &quot;123&quot;</div><div class="line">hisPay = Card &quot;123&quot;</div><div class="line"></div><div class="line">*Main&gt; myPay == yourPay</div><div class="line">True</div><div class="line">*Main&gt; myPay == hisPay</div><div class="line">False</div><div class="line"></div><div class="line">*Main&gt; :t myPay</div><div class="line">myPay :: BookPay</div><div class="line"></div><div class="line">*Main&gt; :t hisPay</div><div class="line">hisPay :: BookPay</div></pre></td></tr></table></figure>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配时，会从上到下依次检查</p>
<p>myNot分别定义了函数对于不同输入参数的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">myNot :: Bool -&gt; Bool</div><div class="line">myNot True = False</div><div class="line">myNot False = True</div><div class="line"></div><div class="line">*Main&gt; myNot (1/=1)</div><div class="line">True</div><div class="line">*Main&gt; myNot (1==1)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>递归求和</p>
<p>这里约束类型为<code>Num</code>，只要是<code>Num</code>类型都可以<br>如果约束为<code>Integral</code>，只能输入整数</p>
<p>其中，数组会被分解为<code>x``xs</code>两部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mySum :: Num a =&gt; [a] -&gt; a</div><div class="line">mySum (x:xs) = x + mySum xs</div><div class="line">mySum [] = 0</div></pre></td></tr></table></figure>
<p>匹配自定义的代数类型<br>必须指定相应类型构造器才能匹配成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bookId  (Book id title  authors) = id</div><div class="line">bookTitle (Book id title  authors) = title</div><div class="line">bookAuthors (Book id title  authors) = authors</div><div class="line"></div><div class="line">*Main&gt; bookId myBook</div><div class="line">1234</div><div class="line">*Main&gt; bookTitle myBook</div><div class="line">&quot;my book&quot;</div><div class="line">*Main&gt; bookAuthors myBook</div><div class="line">[&quot;harryx&quot;,&quot;herui&quot;]</div></pre></td></tr></table></figure>
<p><code>as</code>模式可以保留对整体的引用</p>
<p>当匹配到最后一个模式时，会把整体赋值为all</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tell :: Show a =&gt; [a] -&gt; [Char]</div><div class="line">tell [] = &quot;none&quot;</div><div class="line">tell (x:[]) = show x</div><div class="line">tell (x:y:[]) = show x ++ &quot; and &quot; ++ show y</div><div class="line">tell all@(x:y:_) = &quot;long &quot; ++ show  all</div><div class="line"></div><div class="line">*Main&gt; tell [1,2,3,4,4]</div><div class="line">&quot;long [1,2,3,4,4]&quot;</div></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>当不需要使用某个接收的参数时，可以使用通配符，编译器也不会因为参数没有使用而报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bookId  (Book id _  _) = id</div><div class="line">bookTitle (Book _ title  _) = title</div><div class="line">bookAuthors (Book _ _  authors) = authors</div></pre></td></tr></table></figure>
<p>在模式匹配时使用通配符，可以定义一个默认行为<br>如果之前都没匹配成功，会匹配后面的通配符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mySum (x:xs) = x + mySum xs</div><div class="line">mySum _ = 0</div><div class="line"></div><div class="line">*Main&gt; mySum [1,2,3]</div><div class="line">6</div><div class="line">*Main&gt; mySum []</div><div class="line">0</div></pre></td></tr></table></figure>
<h3 id="记录语法"><a href="#记录语法" class="headerlink" title="记录语法"></a>记录语法</h3><p>在创建一个数据类型时，可以指定字段名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data BookInfo = Book&#123;</div><div class="line">    bookId :: Int,</div><div class="line">    bookTitle :: String,</div><div class="line">    bookAuthors :: [String]</div><div class="line">&#125;deriving(Eq,Show)</div></pre></td></tr></table></figure>
<p>在创建值时可以指定字段名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myBook = Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]</div><div class="line"></div><div class="line">yourBook = Book&#123;</div><div class="line">    bookId = 2345,</div><div class="line">    bookTitle = &quot;your book&quot;,</div><div class="line">    bookAuthors = [&quot;someone&quot;,&quot;the others&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用自带的访问器函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*Main&gt; bookId myBook</div><div class="line">1234</div><div class="line">*Main&gt; bookTitle yourBook</div><div class="line">&quot;your book&quot;</div></pre></td></tr></table></figure>
<h3 id="递归类型"><a href="#递归类型" class="headerlink" title="递归类型"></a>递归类型</h3><p>其中it为上一个求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">data List a = Cons a (List a)</div><div class="line">    | Nil</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">*Main&gt; Cons 0 Nil</div><div class="line">Cons 0 Nil</div><div class="line"></div><div class="line">*Main&gt; Cons 1 it</div><div class="line">Cons 1 (Cons 0 Nil)</div><div class="line"></div><div class="line">*Main&gt; Cons 2 it</div><div class="line">Cons 2 (Cons 1 (Cons 0 Nil))</div></pre></td></tr></table></figure>
<p>List和list的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fromList (x:xs) = Cons x (fromList xs)</div><div class="line">fromList []     = Nil</div><div class="line"></div><div class="line">fromCons (Cons a x) = a : (fromCons x)</div><div class="line">fromCons Nil = []</div><div class="line"></div><div class="line">*Main&gt; fromList &quot;asdasd&quot;</div><div class="line">Cons &apos;a&apos; (Cons &apos;s&apos; (Cons &apos;d&apos; (Cons &apos;a&apos; (Cons &apos;s&apos; (Cons &apos;d&apos; Nil)))))</div><div class="line"></div><div class="line">*Main&gt; fromCons (fromList &quot;asdasd&quot;)</div><div class="line">&quot;asdasd&quot;</div></pre></td></tr></table></figure>
<p>使用模式匹配和递归<br>返回数组最大值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">maxXs :: (Num a,Ord a) =&gt; [a] -&gt; a</div><div class="line">maxXs [] = error &quot;empty&quot;</div><div class="line">maxXs [x] = x</div><div class="line">maxXs (x:xs)</div><div class="line">    | x &gt; (maxXs xs) = x</div><div class="line">    | otherwise = (maxXs xs)</div></pre></td></tr></table></figure>
<p>Python实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def maxLis(lis):</div><div class="line">    if  len(lis) == 0:</div><div class="line">        return 0</div><div class="line">    if len(lis) == 1:</div><div class="line">        return lis[0]</div><div class="line">    if lis[0] &gt; maxLis(lis[1:]):</div><div class="line">        return lis[0]</div><div class="line">    else:</div><div class="line">        return maxLis(lis[1:])</div><div class="line"></div><div class="line">print maxLis([1,2,3,4,5,3,2,5,7,4,2,3])</div></pre></td></tr></table></figure>
<p>排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mySort :: (Ord a) =&gt; [a] -&gt; [a]</div><div class="line">mySort [] = []</div><div class="line">mySort (x:xs) = </div><div class="line">    let &#123;</div><div class="line">    smallone = mySort [a | a &lt;- xs, a &lt;= x];</div><div class="line">    bigone = mySort [a | a &lt;- xs, a &gt; x];</div><div class="line">&#125;</div><div class="line">    in smallone ++ [x] ++ bigone</div></pre></td></tr></table></figure>
<p>使用Python实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def mySort(lis):</div><div class="line">    if lis == []:</div><div class="line">        return []</div><div class="line">    else:</div><div class="line">        return mySort([i for i in lis[1:] if i &lt;= lis[0]]) \</div><div class="line">            + [lis[0]] \</div><div class="line">            + mySort([i for i in lis[1:] if i &gt; lis[0]])</div><div class="line"></div><div class="line">print mySort([1,3,2,5,4,5,23,24,1,14,2,4124,12,21,1])</div></pre></td></tr></table></figure>
<h3 id="报告错误"><a href="#报告错误" class="headerlink" title="报告错误"></a>报告错误</h3><p>定义一个返回数组倒数第二个值，如果数组长度太短返回错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lastButOne xs = if null xs || (length xs) == 1</div><div class="line">    then error &quot;list too short&quot;</div><div class="line">    else head (drop ((length xs) -2) xs)</div><div class="line"></div><div class="line">*Main&gt; lastButOne [1,2,3,4,5,6,7]</div><div class="line">6</div><div class="line"></div><div class="line">*Main&gt; lastButOne [1]</div><div class="line">*** Exception: list too short</div><div class="line">*Main&gt; lastButOne []</div><div class="line">*** Exception: list too short</div></pre></td></tr></table></figure>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数内部，<code>let</code>把变量限制在<code>in</code>后面的表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo = let x=1</div><div class="line">    in ((let x = &quot;asd&quot; in x),x)</div><div class="line"></div><div class="line">*Main&gt; foo</div><div class="line">(&quot;asd&quot;,1)</div></pre></td></tr></table></figure>
<p>where和let类似，不同的是，语句定义在主句后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo = a</div><div class="line">    where a=1</div></pre></td></tr></table></figure>
<p>where语句中可以进行模式匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">initials :: String -&gt; String -&gt; String   </div><div class="line">initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot;   </div><div class="line">    where (f:_) = firstname   </div><div class="line">          (l:_) = lastname</div></pre></td></tr></table></figure>
<h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><p><code>Case</code>语句</p>
<p>case后面是一个表达式，表达式的值为匹配目标<br>of后面是匹配区的开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">testCase value =</div><div class="line">    case value of</div><div class="line">        True -&gt; False</div><div class="line">        False -&gt; True</div></pre></td></tr></table></figure>
<h3 id="门卫"><a href="#门卫" class="headerlink" title="门卫"></a>门卫</h3><p>类似功能的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String   </div><div class="line">bmiTell weight height   </div><div class="line">    | weight / height ^ 2 &lt;= 18.5 </div><div class="line">        = &quot;You&apos;re underweight, you emo, you!&quot;   </div><div class="line">    | weight / height ^ 2 &lt;= 25.0 </div><div class="line">        = &quot;You&apos;re supposedly normal. Pffft, I bet you&apos;re ugly!&quot;   </div><div class="line">    | weight / height ^ 2 &lt;= 30.0 </div><div class="line">        = &quot;You&apos;re fat! Lose some weight, fatty!&quot;   </div><div class="line">    | otherwise                 </div><div class="line">        = &quot;You&apos;re a whale, congratulations!&quot;</div></pre></td></tr></table></figure>
<p>使用局部变量改进函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String   </div><div class="line">bmiTell weight height   </div><div class="line">    | bmi &lt;= skinny</div><div class="line">        = &quot;You&apos;re underweight, you emo, you!&quot;   </div><div class="line">    | bmi &lt;= normal</div><div class="line">        = &quot;You&apos;re supposedly normal. Pffft, I bet you&apos;re ugly!&quot;   </div><div class="line">    | bmi &lt;= fat</div><div class="line">        = &quot;You&apos;re fat! Lose some weight, fatty!&quot;   </div><div class="line">    | otherwise                 </div><div class="line">        = &quot;You&apos;re a whale, congratulations!&quot;  </div><div class="line">    where &#123;</div><div class="line">        bmi = weight / height ^ 2;</div><div class="line">        (skinny, normal, fat) = (18.5, 25.0, 30.0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中缀函数"><a href="#中缀函数" class="headerlink" title="中缀函数"></a>中缀函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a `myplus` b = a+b</div><div class="line"></div><div class="line">*MyModule&gt; 1 `myplus` 2</div><div class="line">3</div><div class="line">*MyModule&gt; myplus 1 2</div><div class="line">3</div></pre></td></tr></table></figure>
<h1 id="柯里函数"><a href="#柯里函数" class="headerlink" title="柯里函数"></a>柯里函数</h1><p>使用参数不完全的函数定义新函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; let conpTen = max 10</div><div class="line">Prelude&gt; conpTen 9</div><div class="line">10</div></pre></td></tr></table></figure>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>将函数作为参数调用或返回</p>
<p>这里将函数f递归调用，作用在两个数组</p>
<p>真正调用的函数类型可以和函数参数不同<br>不一定是 a -&gt; b -&gt; c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">myCons :: a -&gt; a -&gt; [a]</div><div class="line">myCons x y = x:[y]</div><div class="line"></div><div class="line">myZip :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</div><div class="line">myZip _ _ [] = []</div><div class="line">myZip _ [] _ = []</div><div class="line">myZip f (x1:x1s) (x2:x2s) = (f x1 x2) : (myZip f x1s x2s)</div><div class="line"></div><div class="line">*Main&gt; myZip myCons [1,2,3,4] [3,4,5,6]</div><div class="line">[[1,3],[2,4],[3,5],[4,6]]</div></pre></td></tr></table></figure>
<p>Python实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def myZip(f,lis1,lis2):</div><div class="line">    if lis1 == [] or lis2 == []:</div><div class="line">        return []</div><div class="line">    else:</div><div class="line">        return [f(lis1[0],lis2[0])] + myZip(f,lis1[1:],lis2[1:])</div><div class="line"></div><div class="line">lis1=[1,1,2,3]</div><div class="line">lis2=[2,2,4,5]</div><div class="line"></div><div class="line">def myCons(a,b):</div><div class="line">    return [a,b]</div><div class="line"></div><div class="line">print myZip(myCons,lis1,lis2)</div></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Haskell的lambda用\表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myFlip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</div><div class="line">myFlip f x y = f y x </div><div class="line"></div><div class="line">*Main&gt; myFlip (\a b -&gt; a:[b]) 1 2</div><div class="line">[2,1]</div></pre></td></tr></table></figure>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p><code>foldl</code>实现左折叠<br><code>foldr</code>右折叠<br>将一个二元函数作为参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myFoldlSum :: Num a =&gt; [a] -&gt; a</div><div class="line">myFoldlSum xs = foldl (\acc x -&gt; acc + x) 0 xs</div></pre></td></tr></table></figure>
<p>柯里化可以省略参数<br><code>\acc x -&gt; acc + x</code>和<code>+</code>是等价的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myFoldlSum :: Num a =&gt; [a] -&gt; a</div><div class="line">myFoldlSum = foldl (+) 0</div></pre></td></tr></table></figure>
<p>使用<code>:</code>将数组反向拼接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myFoldlRev :: [a] -&gt; [a]</div><div class="line">myFoldlRev = foldl (\acc x -&gt; x:acc) []</div><div class="line"></div><div class="line">*Main&gt; myFoldlRev [1,2,3]</div><div class="line">[3,2,1]</div></pre></td></tr></table></figure>
<p><code>foldl1``foldr1</code>把折叠的第一个值作为初始值(数值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myFoldlSum :: Num a =&gt; [a] -&gt; a</div><div class="line">myFoldlSum = foldl1 (+)</div></pre></td></tr></table></figure>
<h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a><code>$</code>符号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">($) :: (a -&gt; b) -&gt; a -&gt; b   </div><div class="line">f $ x = f x</div></pre></td></tr></table></figure>
<p><code>$</code>相当于在后面添加了括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*Main&gt; sum $ map (+1) [1,2,3,4]</div><div class="line">14</div><div class="line">*Main&gt; sum ( map (+1) [1,2,3,4])</div><div class="line">14</div></pre></td></tr></table></figure>
<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c   </div><div class="line">f . g = \x -&gt; f (g x)</div></pre></td></tr></table></figure>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="装载模块"><a href="#装载模块" class="headerlink" title="装载模块"></a>装载模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; import Data.List</div><div class="line">Prelude Data.List&gt;</div></pre></td></tr></table></figure>
<p>在ghci命令行也可以使用<code>:m</code>装载模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :m Data.List</div><div class="line">Prelude Data.List&gt;</div></pre></td></tr></table></figure>
<p>只装载某个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Data.List  (nub)</div></pre></td></tr></table></figure></p>
<p>去除某个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Data.List  hiding (nub)</div></pre></td></tr></table></figure></p>
<p>避免命名冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import qualified Data.List</div><div class="line"></div><div class="line">*Main&gt; Data.List.nub [1,2,12,1]</div><div class="line">[1,2,12]</div></pre></td></tr></table></figure></p>
<p>自定义模块名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import qualified Data.List as L</div><div class="line"></div><div class="line">*Main&gt; L.nub [1,2,3,3,2]</div><div class="line">[1,2,3]</div></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import Data.List  </div><div class="line"></div><div class="line">numUniques :: (Eq a) =&gt; [a] -&gt; Int   </div><div class="line">numUniques = length . nub</div><div class="line"></div><div class="line">*Main Data.List&gt; numUniques [1,2,3,2,1,3]</div><div class="line">3</div></pre></td></tr></table></figure></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-05-24</span><i class="fa fa-tag"></i><a href="/tags/haskell/" title="haskell" class="tag">haskell </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2016/05/24/Haskell/,Harryx,Haskell 函数式编程 (一),;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/07/11/deco/" title="装饰器" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/05/18/SICP/" title="SICP 笔记(一)" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
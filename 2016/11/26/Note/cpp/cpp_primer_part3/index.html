<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>C++ Primer · Harryx</title><meta name="description" content="拷贝控制拷贝赋值和销毁拷贝构造函数13.5
12345678910111213141516171819202122232425262728293031//注意，这里省略了 std::class HasPtr&amp;#123;public:    HasPtr(const string &amp;amp;s = s"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Harryx</a></h3><div class="description"><p>good good study good good play~</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/harryx520"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/Booooyakasha"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备19072417号-1</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/avator.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>C++ Primer</a></h3></div><div class="post-content"><h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><h2 id="拷贝赋值和销毁"><a href="#拷贝赋值和销毁" class="headerlink" title="拷贝赋值和销毁"></a>拷贝赋值和销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>13.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//注意，这里省略了 std::</span><br><span class="line">class HasPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    HasPtr(const string &amp;s = string()) : </span><br><span class="line">        ps(new string(s)), i(0) &#123;&#125;</span><br><span class="line">    HasPtr(const HasPtr &amp;hp);</span><br><span class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</span><br><span class="line">    void change(const string s) &#123;*ps = s;&#125;</span><br><span class="line">private:</span><br><span class="line">    string *ps;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</span><br><span class="line">    ps(new string(*hp.ps)),</span><br><span class="line">    i(hp.i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    HasPtr a(&quot;hello&quot;);</span><br><span class="line">    HasPtr b = a;</span><br><span class="line">    a.print(); //hello</span><br><span class="line">    b.print(); // hello</span><br><span class="line">    a.change(&quot;world&quot;);</span><br><span class="line">    a.print(); // world</span><br><span class="line">    b.print(); // hello</span><br><span class="line">    b.change(&quot;asd&quot;);</span><br><span class="line">    a.print(); // world</span><br><span class="line">    b.print(); //asd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>13.8</p>
<p>重载赋值运算符，返回类型是当前对象的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    HasPtr(const string &amp;s = string()) : </span><br><span class="line">        ps(new string(s)), i(0) &#123;&#125;</span><br><span class="line">    HasPtr(const HasPtr &amp;hp);</span><br><span class="line">    HasPtr &amp;operator=(const HasPtr &amp;hp);</span><br><span class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</span><br><span class="line">    void change(const string s) &#123;*ps = s;&#125;</span><br><span class="line">private:</span><br><span class="line">    string *ps;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</span><br><span class="line">    ps(new string(*hp.ps)),</span><br><span class="line">    i(hp.i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//重载赋值运算符，返回类型是当前对象的引用</span><br><span class="line">HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)</span><br><span class="line">&#123;</span><br><span class="line">    //防止hp和ps指向同一对象</span><br><span class="line">    auto newp = new string(*hp.ps); //存到临时变量</span><br><span class="line">    delete ps; //释放旧内存</span><br><span class="line">    ps = newp; //拷贝到本地</span><br><span class="line">    i = hp.i;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    HasPtr a(&quot;hello&quot;);</span><br><span class="line">    HasPtr b;</span><br><span class="line">    b = a;</span><br><span class="line">    a.print(); //hello</span><br><span class="line">    b.print(); // hello</span><br><span class="line">    a.change(&quot;world&quot;);</span><br><span class="line">    a.print(); // world</span><br><span class="line">    b.print(); // hello</span><br><span class="line">    b.change(&quot;asd&quot;);</span><br><span class="line">    a.print(); // world</span><br><span class="line">    b.print(); //asd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>初始化对象非static成员，释放对象使用的资源，销毁非static数据成员</p>
<p>没有返回值，不接收参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    HasPtr(const string &amp;s = string()) : </span><br><span class="line">        ps(new string(s)), i(0) &#123;&#125;</span><br><span class="line">    ~HasPtr() &#123;delete ps;&#125; //析构函数</span><br><span class="line">    HasPtr(const HasPtr &amp;hp);</span><br><span class="line">    HasPtr &amp;operator=(const HasPtr &amp;hp);</span><br><span class="line">    string *val()&#123;return ps;&#125;</span><br><span class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</span><br><span class="line">    void change(const string s) &#123;*ps = s;&#125;</span><br><span class="line">private:</span><br><span class="line">    string *ps;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</span><br><span class="line">    ps(new string(*hp.ps)),</span><br><span class="line">    i(hp.i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)</span><br><span class="line">&#123;</span><br><span class="line">    auto newp = new string(*hp.ps);</span><br><span class="line">    delete ps;</span><br><span class="line">    ps = newp;</span><br><span class="line">    i = hp.i;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回一个指针，指向string</span><br><span class="line">string *fun()</span><br><span class="line">&#123;</span><br><span class="line">    HasPtr hp(&quot;hello&quot;);</span><br><span class="line">    return hp.val();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    string *p = fun(); //p指向一个已经被释放的string</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl; //报错，因为指针已经悬空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>13.18</p>
<p>利用<code>static</code>数据成员给每个对象生成唯一的递增的数据成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Employee</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Employee(const string s) : name(s),num(count)</span><br><span class="line">        &#123;count = count + 1;&#125;</span><br><span class="line">    void print() &#123;cout &lt;&lt; num &lt;&lt; &quot; : &quot; &lt;&lt; name &lt;&lt; endl;&#125;</span><br><span class="line">private:</span><br><span class="line">    string name;</span><br><span class="line">    int num;</span><br><span class="line">    static int count; //内部声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//static外部定义，注意没有static关键字</span><br><span class="line">int Employee::count = 0;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    Employee e1(&quot;a&quot;);</span><br><span class="line">    Employee e2(&quot;b&quot;);</span><br><span class="line">    Employee e3(&quot;c&quot;);</span><br><span class="line">    e1.print(); // 0 : a</span><br><span class="line">    e2.print(); // 1 : b</span><br><span class="line">    e3.print(); // 2 : c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拷贝控制和资源管理ka"><a href="#拷贝控制和资源管理ka" class="headerlink" title="拷贝控制和资源管理ka"></a>拷贝控制和资源管理ka</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>13.27</p>
<p>计数器保存在动态内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    HasPtr(const string &amp;s = string()) : </span><br><span class="line">        ps(new string(s)), i(0), use(new size_t(0)) &#123;++ *use;&#125;</span><br><span class="line">    ~HasPtr(); </span><br><span class="line">    HasPtr(const HasPtr &amp;hp);</span><br><span class="line">    HasPtr &amp;operator=(const HasPtr &amp;hp);</span><br><span class="line">    string *val()&#123;return ps;&#125;</span><br><span class="line">    void print() &#123;cout &lt;&lt; *use &lt;&lt; &quot; &quot; &lt;&lt; *ps &lt;&lt; endl;&#125;</span><br><span class="line">    void change(const string s) &#123;*ps = s;&#125;</span><br><span class="line">private:</span><br><span class="line">    string *ps;</span><br><span class="line">    int i;</span><br><span class="line">    size_t *use;</span><br><span class="line">&#125;;</span><br><span class="line">//拷贝初始化，自增计数器</span><br><span class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</span><br><span class="line">    ps(new string(*hp.ps)),</span><br><span class="line">    i(hp.i), use(hp.use) &#123;++*use;&#125;</span><br><span class="line">//析构函数，自减计数器，计数器为0释放内存</span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line">    if (-- *use == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        delete ps;</span><br><span class="line">        delete use;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//拷贝赋值运算符，右值自增，左值自减计数器</span><br><span class="line">HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)</span><br><span class="line">&#123;</span><br><span class="line">    ++ *hp.use; //先自增，防止指向的是同一对象</span><br><span class="line">    if(-- *use == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        delete ps;</span><br><span class="line">        delete use;</span><br><span class="line">    &#125;</span><br><span class="line">    ps = hp.ps;</span><br><span class="line">    i = hp.i;</span><br><span class="line">    use = hp.use;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">//查看引用计数</span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    HasPtr a1(&quot;hello&quot;);</span><br><span class="line">    a1.print(); // 1</span><br><span class="line">    HasPtr a2(&quot;world&quot;);</span><br><span class="line">    a1.print(); // 1</span><br><span class="line">    a2.print(); // 1</span><br><span class="line">    HasPtr a3 = a1;</span><br><span class="line">    a1.print(); // 2</span><br><span class="line">    a2.print(); // 1</span><br><span class="line">    a3.print(); // 2</span><br><span class="line">    a3 = a2;</span><br><span class="line">    a1.print(); // 1</span><br><span class="line">    a2.print(); // 2</span><br><span class="line">    a3.print(); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>13.31</p>
<p>在赋值运算中调用swap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class HasPtr</span><br><span class="line">&#123;</span><br><span class="line">friend void swap(HasPtr &amp;hp1, HasPtr &amp;hp2);</span><br><span class="line">public:</span><br><span class="line">    HasPtr(const string &amp;s = string()) : </span><br><span class="line">        ps(new string(s)), i(0), use(new size_t(0)) &#123;++ *use;&#125;</span><br><span class="line">    ~HasPtr(); </span><br><span class="line">    HasPtr(const HasPtr &amp;hp);</span><br><span class="line">    HasPtr &amp;operator=(HasPtr hp);</span><br><span class="line">    bool operator&lt;(const HasPtr &amp;hp) const;</span><br><span class="line">    string *val()&#123;return ps;&#125;</span><br><span class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</span><br><span class="line">    void change(const string s) &#123;*ps = s;&#125;</span><br><span class="line">private:</span><br><span class="line">    string *ps;</span><br><span class="line">    int i;</span><br><span class="line">    size_t *use;</span><br><span class="line">&#125;;</span><br><span class="line">//拷贝初始化，同上</span><br><span class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</span><br><span class="line">    ps(new string(*hp.ps)),</span><br><span class="line">    i(hp.i), use(hp.use) &#123;++*use;&#125;</span><br><span class="line">//析构函数，同上</span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line">    if (-- *use == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        delete ps;</span><br><span class="line">        delete use;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用swap重写拷贝赋值操作</span><br><span class="line">HasPtr &amp;HasPtr::operator=(HasPtr hp)</span><br><span class="line">&#123;  </span><br><span class="line">     //副本在脱离代码块时，自动调用析构函数释放内存</span><br><span class="line">    swap(*this, hp); //当前对象于一个副本交换</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">//&lt; 运算符，在调用sort时需要</span><br><span class="line">bool HasPtr::operator&lt;(const HasPtr &amp;hp) const</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;operator &lt; ...&quot; &lt;&lt; endl;</span><br><span class="line">    return *this -&gt; ps &lt; *hp.ps;</span><br><span class="line">&#125;</span><br><span class="line">//swap操作</span><br><span class="line">inline</span><br><span class="line">void swap(HasPtr &amp;hp1, HasPtr &amp;hp2)</span><br><span class="line">&#123;</span><br><span class="line">    //如果类没有自己的swap调用标准库的swap</span><br><span class="line">    //如果类有自己的swap，不会隐藏自己的swap</span><br><span class="line">    using std::swap; </span><br><span class="line">    swap(hp1.ps, hp2.ps);</span><br><span class="line">    swap(hp1.i, hp2.i);</span><br><span class="line">    cout &lt;&lt; &quot;swaped...&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    HasPtr a1(&quot;hello&quot;);</span><br><span class="line">    HasPtr a2(&quot;world&quot;);</span><br><span class="line">    HasPtr a3(&quot;byebye&quot;);</span><br><span class="line">    vector&lt;HasPtr&gt; vhp&#123;a1, a2, a3&#125;;</span><br><span class="line">    sort(vhp.begin(), vhp.end()); //排序</span><br><span class="line">    /*</span><br><span class="line">        输出：这里调用了三次比较，四次swap拷贝赋值</span><br><span class="line">        operator &lt; ...</span><br><span class="line">        operator &lt; ...</span><br><span class="line">        swaped...</span><br><span class="line">        operator &lt; ...</span><br><span class="line">        swaped...</span><br><span class="line">        swaped...</span><br><span class="line">        swaped...</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重载运算和类型转换"><a href="#重载运算和类型转换" class="headerlink" title="重载运算和类型转换"></a>重载运算和类型转换</h1><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>14.2</p>
<p>重载Sales_data的输入、输出、加法和复合赋值运算符<br>重载相等运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Sales_data</span><br><span class="line">&#123;</span><br><span class="line">friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Sales_data &amp;sd);</span><br><span class="line">friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Sales_data &amp;sd);</span><br><span class="line">friend Sales_data operator+(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</span><br><span class="line">friend bool operator==(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</span><br><span class="line">friend bool operator!=(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</span><br><span class="line">//...省略...</span><br><span class="line">public:</span><br><span class="line">    Sales_data &amp;operator+=(const Sales_data&amp;);</span><br><span class="line">//...省略...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//成员函数</span><br><span class="line">inline</span><br><span class="line">Sales_data&amp; Sales_data::operator+=(const Sales_data &amp;sd)</span><br><span class="line">&#123;</span><br><span class="line">    unit += sd.unit;</span><br><span class="line">    revenue += sd.revenue;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非成员函数</span><br><span class="line">istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;sd)</span><br><span class="line">&#123;</span><br><span class="line">    double price = 0;</span><br><span class="line">    is &gt;&gt; sd.name &gt;&gt; sd.unit &gt;&gt; price;</span><br><span class="line">    if(is) //判断流是否发生错误</span><br><span class="line">        sd.revenue = price * sd.unit;</span><br><span class="line">    else //如果错误，赋值为默认状态</span><br><span class="line">        sd = Sales_data();</span><br><span class="line">    return is;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;sd)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; sd.getname() &lt;&lt; &quot; &quot; &lt;&lt; sd.unit &lt;&lt; &quot; &quot;</span><br><span class="line">        &lt;&lt; sd.revenue &lt;&lt; &quot; &quot; &lt;&lt; sd.avg_price() &lt;&lt; &quot; num: &quot; &lt;&lt; sd.num;</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line">Sales_data operator+(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = sd1;</span><br><span class="line">    sum += sd2;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">bool operator==(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</span><br><span class="line">&#123;</span><br><span class="line">    return sd1.name == sd2.name &amp;&amp;</span><br><span class="line">        sd1.unit == sd2.unit &amp;&amp;</span><br><span class="line">        sd1.revenue == sd2.revenue;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!=(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</span><br><span class="line">&#123;</span><br><span class="line">    return !(sd1 == sd2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sd1, sd2;</span><br><span class="line">    cin &gt;&gt; sd1; //输入</span><br><span class="line">    cin &gt;&gt; sd2;</span><br><span class="line">    Sales_data sd3 = sd1 + sd2; //加</span><br><span class="line">    sd3 += sd1; //复合赋值</span><br><span class="line">    cout &lt;&lt; sd3 &lt;&lt; endl; //输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.18</p>
<p>比较运算符根据实际情况选择是否添加<br>给StrBlob添加比较运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class StrBlob</span><br><span class="line">&#123;</span><br><span class="line">friend bool operator&lt;(const StrBlob &amp;sb1, const StrBlob &amp;sb2);</span><br><span class="line">//...</span><br><span class="line">&#125;;</span><br><span class="line">//非成员函数</span><br><span class="line">bool operator&lt;(const StrBlob &amp;sb1, const StrBlob &amp;sb2)</span><br><span class="line">&#123;</span><br><span class="line">    auto b1 = sb1.data -&gt; begin(), e1 = sb1.data -&gt; end();</span><br><span class="line">    auto b2 = sb2.data -&gt; begin(), e2 = sb2.data -&gt; end();</span><br><span class="line">    while (b1 != e1 &amp;&amp; b2 != e2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*b1 != *b2)</span><br><span class="line">            return *b1 &lt; *b2;</span><br><span class="line">        ++b1;</span><br><span class="line">        ++b2;</span><br><span class="line">    &#125;</span><br><span class="line">    return sb1.data -&gt; size() &lt; sb2.data -&gt; size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    StrBlob b1&#123;&quot;abc&quot;,&quot;afd&quot;&#125;;</span><br><span class="line">    StrBlob b2&#123;&quot;abc&quot;,&quot;afd&quot;,&quot;asd&quot;&#125;;</span><br><span class="line">    cout &lt;&lt; (b1 &lt; b2) &lt;&lt; endl; // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.26</p>
<p>下标运算符通常定义两个版本，一个返回普通的引用，另一个是常量成员并且返回常量引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class StrBlob</span><br><span class="line">&#123;</span><br><span class="line">//...</span><br><span class="line">    string &amp;operator[](size_t n);</span><br><span class="line">    const string &amp;operator[](size_t n) const;</span><br><span class="line">//...</span><br><span class="line">&#125;;</span><br><span class="line">//成员函数</span><br><span class="line">//普通版本</span><br><span class="line">string &amp;StrBlob::operator[](size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    return (*data)[n];</span><br><span class="line">&#125;</span><br><span class="line">//常量版本</span><br><span class="line">const string &amp;StrBlob::operator[](size_t n) const</span><br><span class="line">&#123;</span><br><span class="line">    return (*data)[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    StrBlob b&#123;&quot;abc&quot;,&quot;afd&quot;&#125;;</span><br><span class="line">    const StrBlob a(b);</span><br><span class="line">    a[1] = &quot;world&quot;; //错误，常量引用只读</span><br><span class="line">    b[1] = &quot;hello&quot;;</span><br><span class="line">    cout &lt;&lt; b[1] &lt;&lt; endl; // hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.30</p>
<p>给StrBlobPtr添加自增、自减和解引用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">//先申明</span><br><span class="line">class StrBlobPtr;</span><br><span class="line">class StrBlob</span><br><span class="line">&#123;</span><br><span class="line">friend class StrBlobPtr; //申明为友元</span><br><span class="line">public:</span><br><span class="line">    typedef vector&lt;string&gt;::size_type size_type;</span><br><span class="line">    //构造函数</span><br><span class="line">    StrBlob():data(make_shared&lt;vector&lt;string&gt;&gt;())&#123;&#125;</span><br><span class="line">    StrBlob(initializer_list&lt;string&gt; ils)://多个字符串参数</span><br><span class="line">        data(make_shared&lt;vector&lt;string&gt;&gt;(ils)) &#123;&#125;</span><br><span class="line">    //成员函数</span><br><span class="line">    StrBlobPtr begin();</span><br><span class="line">    StrBlobPtr end();</span><br><span class="line">    size_type size() const &#123;return data -&gt; size();&#125;</span><br><span class="line">    bool empty() const &#123;return data -&gt; empty();&#125;</span><br><span class="line">    void push_back(const string &amp;t) &#123;data -&gt; push_back(t);&#125;</span><br><span class="line">    void pop_back() &#123;check(0, &quot;empty&quot;); data -&gt; front();&#125;</span><br><span class="line">    string&amp; front() &#123;check(0, &quot;empty&quot;); return data -&gt; front();&#125;</span><br><span class="line">    string&amp; back() &#123;check(0, &quot;empty&quot;); return data -&gt; back();&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; data;//vec的指针</span><br><span class="line">    //检测异常</span><br><span class="line">    void check(size_type i, const string &amp;msg) const </span><br><span class="line">        &#123;if (i &gt;= data -&gt; size()) throw out_of_range(msg);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class StrBlobPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //构造函数</span><br><span class="line">    StrBlobPtr() : curr(0) &#123;&#125;</span><br><span class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz=0):</span><br><span class="line">        wptr(a.data), curr(sz) &#123;&#125; //用shared_ptr初始化弱指针</span><br><span class="line">    //成员函数</span><br><span class="line">    string &amp;operator*() const; //解引用</span><br><span class="line">    string *operator-&gt;() const;</span><br><span class="line">    StrBlobPtr &amp;operator++(); //递增</span><br><span class="line">    StrBlobPtr &amp;operator--(); //递增</span><br><span class="line">    StrBlobPtr operator++(int i); //递增</span><br><span class="line">    StrBlobPtr operator--(int i); //递增</span><br><span class="line">private:</span><br><span class="line">    //检查vector是否被释放，索引是否合法</span><br><span class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; check(size_t sz, const string &amp;msg) const;</span><br><span class="line">    weak_ptr&lt;vector&lt;string&gt;&gt; wptr; //一个弱指针</span><br><span class="line">    size_t curr; //位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//返回一个指向第一个元素的StrBlobPtr</span><br><span class="line">StrBlobPtr StrBlob::begin()</span><br><span class="line">&#123;</span><br><span class="line">    return StrBlobPtr(*this);</span><br><span class="line">&#125;</span><br><span class="line">//最后一个元素后一个位置</span><br><span class="line">StrBlobPtr StrBlob::end()</span><br><span class="line">&#123;</span><br><span class="line">    auto ret = StrBlobPtr(*this, data -&gt; size());</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;vector&lt;string&gt;&gt; </span><br><span class="line">StrBlobPtr::check(size_t sz, const string &amp;msg) const</span><br><span class="line">&#123;</span><br><span class="line">    auto ret = wptr.lock(); //如果不存在返回空</span><br><span class="line">    if (!ret)</span><br><span class="line">        throw runtime_error(&quot;unbond StrBlob&quot;);</span><br><span class="line">    if (sz &gt;= ret -&gt; size())</span><br><span class="line">        throw out_of_range(msg);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解引用</span><br><span class="line">string &amp;StrBlobPtr::operator*() const</span><br><span class="line">&#123;</span><br><span class="line">    auto p = check(curr, &quot;dereference past end&quot;); //检查索引</span><br><span class="line">    return (*p) [curr]; //取vector元素</span><br><span class="line">&#125;</span><br><span class="line">string *StrBlobPtr::operator-&gt;() const</span><br><span class="line">&#123;</span><br><span class="line">    return &amp; this -&gt; operator*(); //返回解引用结果的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//前置版本</span><br><span class="line">StrBlobPtr &amp;StrBlobPtr::operator++()</span><br><span class="line">&#123;</span><br><span class="line">    check(curr, &quot;increment past end of StrBlobPtr&quot;); //检查索引</span><br><span class="line">    ++curr; //自增移动</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr &amp;StrBlobPtr::operator--()</span><br><span class="line">&#123;</span><br><span class="line">    --curr;//自减移动，如果为0，产生无效下标</span><br><span class="line">    check(curr, &quot;increment past end of StrBlobPtr&quot;); //检查索引</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置版本用一个不被使用的 int 形参与前置版本区分</span><br><span class="line">//后置版本返回的值应该与之前的值保持一致</span><br><span class="line">//返回的是值，而不是引用</span><br><span class="line">StrBlobPtr StrBlobPtr::operator++(int i)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *this;</span><br><span class="line">    ++*this; //自增移动</span><br><span class="line">    return ret; //返回原值</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::operator--(int i)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *this;</span><br><span class="line">    --*this;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    StrBlob b&#123;&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;&#125;;</span><br><span class="line">    StrBlobPtr bp = b.begin(), be = b.end();</span><br><span class="line">    cout &lt;&lt; *bp++ &lt;&lt; endl; //a</span><br><span class="line">    cout &lt;&lt; *++bp &lt;&lt; endl;//aaa</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p>15.3</p>
<p>定义一个基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class myquote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    myquote() = default;</span><br><span class="line">    myquote(const std::string &amp;bookname, double source_price) :</span><br><span class="line">        name(bookname), price(source_price) &#123;&#125;</span><br><span class="line">    std::string getname() const &#123;return name;&#125;</span><br><span class="line">    //需要派生类自己定义的函数声明为虚函数</span><br><span class="line">    virtual double getprice() const &#123;return price;&#125;</span><br><span class="line">    virtual ~myquote() = default; //基类需要定义一个虚解析函数</span><br><span class="line">private: //私有成员，用户和派生类都不能访问</span><br><span class="line">    std::string name;</span><br><span class="line">protected: // 受保护的成员，派生类可以访问，用户不能访问</span><br><span class="line">    double price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个打印函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这里的mq可以是基类或者派生类</span><br><span class="line">void print_total(ostream &amp;os, MyQuote &amp;mq, size_t num)</span><br><span class="line">&#123;</span><br><span class="line">    double total_price = mq.getprice() * num;</span><br><span class="line">    os &lt;&lt; mq.getname() &lt;&lt; &quot; : &quot; &lt;&lt; total_price &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15.5</p>
<p>定义一个派生类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CutQuote : public MyQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CutQuote() = default;</span><br><span class="line">    CutQuote(const std::string &amp;bookname, double source_price, int cut) : </span><br><span class="line">        MyQuote(bookname, source_price), discount(cut) &#123;&#125;</span><br><span class="line">    double getprice() const override &#123;return price/discount;&#125; //重写虚函数</span><br><span class="line">private:</span><br><span class="line">    int discount; //新增数据成员表示折扣</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>15.11</p>
<p>定义一个输出成员值的debug()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //....</span><br><span class="line">    virtual void debug()</span><br><span class="line">    &#123; //输出自己的元素</span><br><span class="line">        std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; std::endl </span><br><span class="line">            &lt;&lt; &quot;price : &quot; &lt;&lt; price &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">//...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CutQuote : public MyQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //....</span><br><span class="line">    void debug()</span><br><span class="line">    &#123; //显式调用基类的debug函数，否则会陷入无限递归</span><br><span class="line">        MyQuote::debug(); </span><br><span class="line">        std::cout &lt;&lt; &quot;discount : &quot; &lt;&lt; discount &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">//...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>15.15</p>
<p>抽象基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MyQuote() = default;</span><br><span class="line">    MyQuote(const std::string &amp;bookname, double source_price) :</span><br><span class="line">        name(bookname), price(source_price) &#123;&#125;</span><br><span class="line">    std::string getname() const &#123;return name;&#125;</span><br><span class="line">    virtual double getprice() const &#123;return price;&#125;</span><br><span class="line">    virtual ~MyQuote() = default;</span><br><span class="line">private: //私有成员，用户和派生类都不能访问</span><br><span class="line">    std::string name;</span><br><span class="line">protected: // 受保护的成员，派生类可以访问，用户不能访问</span><br><span class="line">    double price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//继承基类的抽象基类</span><br><span class="line">class DiscQuote : public MyQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    DiscQuote() = default;</span><br><span class="line">    DiscQuote(const std::string &amp;bookname, double source_price, int cut) : </span><br><span class="line">        MyQuote(bookname, source_price), discount(cut) &#123;&#125;</span><br><span class="line">    double getprice() const = 0; //声明为纯虚函数</span><br><span class="line">protected:</span><br><span class="line">    int discount; //新增数据成员表示折扣</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//从抽象基类继承</span><br><span class="line">class CutQuote : public DiscQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CutQuote() = default;</span><br><span class="line">    CutQuote(const std::string &amp;bookname, double source_price, int cut) :</span><br><span class="line">        DiscQuote(bookname, source_price, cut) &#123;&#125;</span><br><span class="line">    //覆盖抽象基类的getprice()函数</span><br><span class="line">    double getprice() const override &#123;return price/discount;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print_total(std::ostream &amp;os, MyQuote &amp;mq, std::size_t num);</span><br></pre></td></tr></table></figure>
<h2 id="构造函数和派生类"><a href="#构造函数和派生类" class="headerlink" title="构造函数和派生类"></a>构造函数和派生类</h2><p>15.26</p>
<p>定义拷贝构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class MyQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MyQuote() = default;</span><br><span class="line">    MyQuote(const std::string &amp;bookname, double source_price) :</span><br><span class="line">        name(bookname), price(source_price) &#123;&#125;</span><br><span class="line">    std::string getname() const &#123;return name;&#125;</span><br><span class="line">    MyQuote(const MyQuote &amp;mq) : name(mq.name), price(mq.price)</span><br><span class="line">    &#123; //输出表示调用这个拷贝构造函数</span><br><span class="line">        std::cout &lt;&lt; &quot;MyQuote&apos;s copy..&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual double getprice() const &#123;return price;&#125;</span><br><span class="line">    virtual ~MyQuote() = default;</span><br><span class="line">private: //私有成员，用户和派生类都不能访问</span><br><span class="line">    std::string name;</span><br><span class="line">protected: // 受保护的成员，派生类可以访问，用户不能访问</span><br><span class="line">    double price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DiscQuote : public MyQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    DiscQuote() = default;</span><br><span class="line">    DiscQuote(const std::string &amp;bookname, double source_price, int cut) : </span><br><span class="line">        MyQuote(bookname, source_price), discount(cut) &#123;&#125;</span><br><span class="line">    //先调用基类拷贝构造，然后构造自己的成员</span><br><span class="line">    DiscQuote(const DiscQuote &amp;dq) : MyQuote(dq), discount(dq.discount)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;DiscQuote&apos;s copy..&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    double getprice() const = 0; //声明为纯虚函数</span><br><span class="line">protected:</span><br><span class="line">    int discount; //新增数据成员表示折扣</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CutQuote : public DiscQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CutQuote() = default;</span><br><span class="line">    CutQuote(const std::string &amp;bookname, double source_price, int cut) :</span><br><span class="line">        DiscQuote(bookname, source_price, cut) &#123;&#125;</span><br><span class="line">    // 不用构造自己的成员，向上调用</span><br><span class="line">    CutQuote(const CutQuote &amp;cq) : DiscQuote(cq)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;CutQuote&apos;s copy&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    double getprice() const override &#123;return price/discount;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print_total(std::ostream &amp;os, MyQuote &amp;mq, std::size_t num);</span><br><span class="line"></span><br><span class="line">//在主文件调用</span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    CutQuote q1(&quot;hello world&quot;, 10, 3);</span><br><span class="line">    CutQuote  q2(q1);</span><br><span class="line">    print_total(cout, q2, 1);</span><br><span class="line">    /*</span><br><span class="line">        输出说明是自顶而下的构造</span><br><span class="line">        MyQuote&apos;s copy..</span><br><span class="line">        DiscQuote&apos;s copy..</span><br><span class="line">        CutQuote&apos;s copy</span><br><span class="line">        hello world : 3.33333</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>15.27</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CutQuote : public DiscQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using DiscQuote::DiscQuote; //继承DiscQuote的构造函数</span><br><span class="line">    double getprice() const override &#123;return price/discount;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="容器和继承"><a href="#容器和继承" class="headerlink" title="容器和继承"></a>容器和继承</h2><p>15.28</p>
<p>如果在基类类型容器放置派生类对象，派生类那部分会被切掉<br>因此，在容器中放置（智能）指针而不是对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    CutQuote q1(&quot;hello world&quot;, 10, 3);</span><br><span class="line">    MyQuote q2(&quot;hello world&quot;, 10);</span><br><span class="line">    vector&lt;shared_ptr&lt;MyQuote&gt;&gt; basket;</span><br><span class="line">    //派生类的智能指针隐式转化为基类智能指针</span><br><span class="line">    basket.push_back(make_shared&lt;CutQuote&gt;(q1));</span><br><span class="line">    basket.push_back(make_shared&lt;MyQuote&gt;(q2)); </span><br><span class="line">    for(auto i : basket)</span><br><span class="line">    &#123;</span><br><span class="line">        print_total(cout, *i, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">        输出：</span><br><span class="line">        hello world : 3.33333</span><br><span class="line">        hello world : 10</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15.30</p>
<p>编写一个Basket类<br>如果要改变add_item的接口，直接传入对象，让类自己判断调用什么拷贝方式<br>需要创建虚拟拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class MyQuote</span><br><span class="line">&#123;</span><br><span class="line">//...</span><br><span class="line">    //虚拟拷贝，在程序运行的时候觉得调用哪个类的拷贝函数</span><br><span class="line">    //左值，返回基类指针</span><br><span class="line">    virtual MyQuote *clone() const &amp; &#123;return new MyQuote(*this);&#125; </span><br><span class="line">    //右值，基类指针</span><br><span class="line">    virtual MyQuote *clone() &amp;&amp; &#123;return new MyQuote(std::move(*this));&#125; </span><br><span class="line">//...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CutQuote : public DiscQuote</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using DiscQuote::DiscQuote;</span><br><span class="line">    //左值，派生类指针</span><br><span class="line">    CutQuote *clone() const &amp; &#123;return new CutQuote(*this);&#125;</span><br><span class="line">    //右值，派生类指针</span><br><span class="line">    CutQuote *clone() &amp;&amp; &#123;return new CutQuote(std::move(*this));&#125;</span><br><span class="line">    double getprice() const override &#123;return price/discount;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Basket</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void add_item(const MyQuote &amp;mq)</span><br><span class="line">    &#123; //添加到容器内</span><br><span class="line">        items.push_back(std::shared_ptr&lt;MyQuote&gt;(mq.clone()));</span><br><span class="line">    &#125;</span><br><span class="line">    void add_item(MyQuote &amp;&amp;mq)</span><br><span class="line">    &#123; //尽管参数是右值，mq本身却是个左值，所以需要再次调用move</span><br><span class="line">        items.push_back(std::shared_ptr&lt;MyQuote&gt;(std::move(mq).clone()));</span><br><span class="line">    &#125;</span><br><span class="line">    double total_price()</span><br><span class="line">    &#123; //遍历求和</span><br><span class="line">        double sum(0.0);</span><br><span class="line">        for(auto i : items)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i -&gt; getprice();</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //存放指针的容器</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;MyQuote&gt;&gt; items;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    CutQuote q1(&quot;hello world&quot;, 10, 3);</span><br><span class="line">    MyQuote q2(&quot;hello world&quot;, 10);</span><br><span class="line">    Basket bk;</span><br><span class="line">    bk.add_item(q1);</span><br><span class="line">    bk.add_item(q2);</span><br><span class="line">    cout &lt;&lt; bk.total_price() &lt;&lt; endl; //13.3333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15.39</p>
<p>文件查询程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MYSEARCH_H</span><br><span class="line">#define MYSEARCH_H</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;mysearch.h&quot;</span><br><span class="line"></span><br><span class="line">class QueryResult;</span><br><span class="line">class TextQuery</span><br><span class="line">&#123;</span><br><span class="line">friend class QueryResult;</span><br><span class="line">public:</span><br><span class="line">    TextQuery(std::ifstream &amp;infile);</span><br><span class="line">    QueryResult query(std::string s) const;</span><br><span class="line">private:</span><br><span class="line">   std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; ifile; //指向存放每行文本的vector</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;std::set&lt;int&gt;&gt;&gt; wm; //单词到存放行数的set的映射</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class QueryResult</span><br><span class="line">&#123;</span><br><span class="line">friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const QueryResult &amp;qr);</span><br><span class="line">public:</span><br><span class="line">    QueryResult(std::string s, std::shared_ptr&lt;std::set&lt;int&gt;&gt; lp, std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; fp) : </span><br><span class="line">        world(s), linep(lp), file(fp)&#123;&#125;</span><br><span class="line">    std::set&lt;int&gt;::iterator begin()</span><br><span class="line">    &#123;</span><br><span class="line">        return linep -&gt; begin();</span><br><span class="line">    &#125;</span><br><span class="line">    std::set&lt;int&gt;::iterator end()</span><br><span class="line">    &#123;</span><br><span class="line">        return linep -&gt; end();</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; &amp;get_file()</span><br><span class="line">    &#123;</span><br><span class="line">        return file;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::string world;</span><br><span class="line">    std::shared_ptr&lt;std::set&lt;int&gt;&gt; linep;</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//构造函数，在构造函数里储存将单词到行号的隐射</span><br><span class="line">TextQuery::TextQuery(std::ifstream &amp;infile) : ifile(new std::vector&lt;std::string&gt;) //初始化infile</span><br><span class="line">&#123;</span><br><span class="line">    std::string s,world;</span><br><span class="line">    int num(0);</span><br><span class="line">    while(getline(infile, s))</span><br><span class="line">    &#123;</span><br><span class="line">        ++num;</span><br><span class="line">        ifile -&gt; push_back(s);</span><br><span class="line">        std::istringstream line(s);</span><br><span class="line">        while(line &gt;&gt; world)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!wm[world]) //如果set还没有创建</span><br><span class="line">                wm[world].reset(new std::set&lt;int&gt;); //创建一个set</span><br><span class="line">            wm[world] -&gt; insert(num); //行号插入到set</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//查找</span><br><span class="line">//返回一个QueryResult类</span><br><span class="line">QueryResult TextQuery::query(std::string s) const</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;std::set&lt;int&gt;&gt; nodata(new std::set&lt;int&gt;); //一个空set</span><br><span class="line">    auto res = wm.find(s); //查找函数的本体，查找map对应字符串的行号set</span><br><span class="line">    if (res == wm.end()) //无内容返回空set</span><br><span class="line">        return QueryResult(s, nodata, ifile);</span><br><span class="line">    else //有内容返回set，访问map 的 second成员</span><br><span class="line">        return QueryResult(s, res -&gt; second, ifile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用&lt;&lt;操作符打印QueryResult的内容</span><br><span class="line">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const QueryResult &amp;qr)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; qr.world &lt;&lt; &quot;: \n&quot;;</span><br><span class="line">    for (auto num:*qr.linep) //对每个指针解引用然后遍历</span><br><span class="line">    &#123;</span><br><span class="line">        os &lt;&lt; num &lt;&lt; &quot; &quot;; //行号</span><br><span class="line">        os &lt;&lt; *(qr.file -&gt; begin() + num - 1) &lt;&lt; &quot;\n&quot;; //用迭代器输出vector的行文本</span><br><span class="line">    &#125;</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//一个抽象基类，继承查询类型</span><br><span class="line">class Query_base</span><br><span class="line">&#123;</span><br><span class="line">friend class Query;</span><br><span class="line">protected:</span><br><span class="line">    virtual ~Query_base() = default;</span><br><span class="line">private:</span><br><span class="line">    virtual QueryResult eval(const TextQuery &amp;t) const = 0;</span><br><span class="line">    virtual std::string rep() const = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Query</span><br><span class="line">&#123;</span><br><span class="line">friend Query operator~(const Query &amp;q);</span><br><span class="line">friend Query operator&amp;(const Query &amp;q1, const Query &amp;q2);</span><br><span class="line">friend Query operator|(const Query &amp;q1, const Query &amp;q2);</span><br><span class="line">public:</span><br><span class="line">    //构造一个WordQuery</span><br><span class="line">    Query(const std::string &amp;s);</span><br><span class="line">    QueryResult eval(const TextQuery &amp;t) const</span><br><span class="line">    &#123;</span><br><span class="line">        return q -&gt; eval(t); //虚调用</span><br><span class="line">    &#125;</span><br><span class="line">    std::string rep() const</span><br><span class="line">    &#123;</span><br><span class="line">        return q -&gt; rep(); //虚调用</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Query(std::shared_ptr&lt;Query_base&gt; sq) : q(sq) &#123;&#125;</span><br><span class="line">    std::shared_ptr&lt;Query_base&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> //继承查询基类</span><br><span class="line">class WordQuery : public Query_base</span><br><span class="line">&#123;</span><br><span class="line">    //默认都是私有成员，由友元Query（用户借口类）访问</span><br><span class="line">    friend class Query;</span><br><span class="line">    //保存要查询的词</span><br><span class="line">    WordQuery(const std::string &amp;s) : query_world(s) &#123;&#125;</span><br><span class="line">    QueryResult eval(const TextQuery &amp;t) const override</span><br><span class="line">    &#123;</span><br><span class="line">        return t.query(query_world); </span><br><span class="line">    &#125;</span><br><span class="line">    std::string rep() const override &#123;return query_world;&#125;</span><br><span class="line">    std::string query_world; //查询的词</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">Query::Query(const std::string &amp;s) : q(new WordQuery(s)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">class NotQuery : public Query_base</span><br><span class="line">&#123;</span><br><span class="line">    friend Query operator~(const Query  &amp;q);</span><br><span class="line">    NotQuery(const Query &amp;q) : query(q) &#123;&#125;;</span><br><span class="line">    std::string rep() const override</span><br><span class="line">    &#123; //输出要查询的词，附带~符号和括号</span><br><span class="line">        return &quot;~(&quot; + query.rep() + &quot;)&quot;; </span><br><span class="line">    &#125;</span><br><span class="line">    QueryResult eval(const TextQuery &amp;t) const override;</span><br><span class="line">    Query query; //保存传递的query参数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">Query operator~(const Query &amp;q)</span><br><span class="line">&#123;//返回一个shared_ptr</span><br><span class="line">    return std::shared_ptr&lt;Query_base&gt; (new NotQuery(q));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BinaryQuery : public Query_base</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    BinaryQuery(const Query &amp;l, const Query &amp;r, std::string s) : </span><br><span class="line">        lq(l), rq(r), ops(s) &#123;&#125;</span><br><span class="line">    std::string rep() const override</span><br><span class="line">    &#123; //输出查找的词和符号</span><br><span class="line">        return &quot;(&quot; + lq.rep() + &quot; &quot; </span><br><span class="line">            + ops + &quot; &quot; </span><br><span class="line">            + rq.rep() + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //没有覆盖eval()，仍是抽象基类</span><br><span class="line">    Query lq, rq; //左右操作数</span><br><span class="line">    std::string ops; //运算符</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//&amp;运算和|运算相似</span><br><span class="line">class AndQuery : public BinaryQuery</span><br><span class="line">&#123;</span><br><span class="line">    friend Query operator&amp;(const Query &amp;q1, const Query &amp;q2);</span><br><span class="line">    AndQuery(const Query &amp;q1, const Query &amp;a2) : </span><br><span class="line">        BinaryQuery(q1, a2, &quot;&amp;&quot;) &#123;&#125;</span><br><span class="line">    QueryResult eval(const TextQuery &amp;t) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">Query operator&amp;(const   Query &amp;q1,const Query &amp;q2)</span><br><span class="line">&#123;</span><br><span class="line">    return std::shared_ptr&lt;Query_base&gt; (new AndQuery(q1, q2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OrQuery : public BinaryQuery</span><br><span class="line">&#123;</span><br><span class="line">    friend Query operator|(const Query &amp;q1, const Query &amp;q2);</span><br><span class="line">    OrQuery(const Query &amp;q1, const Query &amp;a2) : </span><br><span class="line">        BinaryQuery(q1, a2, &quot;|&quot;) &#123;&#125;</span><br><span class="line">    QueryResult eval(const TextQuery &amp;t) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">Query operator|(const   Query &amp;q1,const Query &amp;q2)</span><br><span class="line">&#123;</span><br><span class="line">    return std::shared_ptr&lt;Query_base&gt; (new OrQuery(q1, q2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &apos;|&apos; 操作</span><br><span class="line">QueryResult</span><br><span class="line">OrQuery::eval(const TextQuery &amp;t) const</span><br><span class="line">&#123;</span><br><span class="line">    QueryResult lqr = lq.eval(t), rqr = rq.eval(t);</span><br><span class="line">    //左QueryResult的行号or上右QueryResult行号</span><br><span class="line">    auto ret_lines = std::make_shared&lt;std::set&lt;int&gt;&gt;(lqr.begin(), lqr.end());</span><br><span class="line">    ret_lines -&gt; insert(rqr.begin(), rqr.end());</span><br><span class="line">    //初始化一个新QueryResult</span><br><span class="line">    return QueryResult(rep(), ret_lines, lqr.get_file());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &apos;&amp;&apos;操作</span><br><span class="line">QueryResult</span><br><span class="line">AndQuery::eval(const TextQuery &amp;t) const</span><br><span class="line">&#123;</span><br><span class="line">    QueryResult lqr = lq.eval(t), rqr = rq.eval(t);</span><br><span class="line">    //一个指向空set的指针</span><br><span class="line">    auto ret_lines = std::make_shared&lt;std::set&lt;int&gt;&gt;();</span><br><span class="line">    ret_lines -&gt; insert(rqr.begin(), rqr.end());</span><br><span class="line">    //使用标准库算法求并集</span><br><span class="line">    set_intersection(lqr.begin(), lqr.end(),</span><br><span class="line">            rqr.begin(), rqr.end(),</span><br><span class="line">            inserter(*ret_lines, ret_lines -&gt; begin()));</span><br><span class="line">    return QueryResult(rep(), ret_lines, lqr.get_file());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &apos;~&apos;操作</span><br><span class="line">QueryResult</span><br><span class="line">NotQuery::eval(const TextQuery &amp;t) const</span><br><span class="line">&#123;</span><br><span class="line">    QueryResult qr = query.eval(t);</span><br><span class="line">    //一个指向空set的指针</span><br><span class="line">    auto ret_lines = std::make_shared&lt;std::set&lt;int&gt;&gt;();</span><br><span class="line">    auto qrb = qr.begin(), qre = qr.end();</span><br><span class="line">    auto sz = qr.get_file() -&gt; size();</span><br><span class="line">    for (auto n = 0; n != sz; ++n)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*qrb != n + 1)</span><br><span class="line">            //如果行号不在查询结果里面，插入到set中</span><br><span class="line">            ret_lines -&gt; insert(n+1);</span><br><span class="line">        else if(qrb != qre)</span><br><span class="line">            ++qrb;</span><br><span class="line">    &#125;</span><br><span class="line">    return QueryResult(rep(), ret_lines, qr.get_file());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//主函数调用</span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    ifstream infile(&quot;text.txt&quot;);</span><br><span class="line">    TextQuery tq(infile);</span><br><span class="line">    auto res = Query(&quot;harry&quot;) &amp; Query(&quot;my&quot;) | ~Query(&quot;haha&quot;);</span><br><span class="line">    cout &lt;&lt; res.eval(tq);</span><br><span class="line">/*</span><br><span class="line">    ((harry &amp; my) | ~(haha)): </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ..</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>16.19</p>
<p>输出容器内容的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void my_print(const vector&lt;T&gt; &amp;ve)</span><br><span class="line">&#123;</span><br><span class="line">    //typename指定成员类型</span><br><span class="line">    typename vector&lt;T&gt;::size_type sz = ve.size(), i;</span><br><span class="line">    for(i=0; i != sz; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ve[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    my_print(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16.20</p>
<p>使用迭代器的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void my_print(const vector&lt;T&gt; &amp;ve)</span><br><span class="line">&#123;</span><br><span class="line">    typename vector&lt;T&gt;::const_iterator bg = ve.begin(), be = ve.end();</span><br><span class="line">    while(bg != be)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *bg++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    my_print(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">ostream  &amp;my_print(ostream &amp;os, const T &amp;ve)</span><br><span class="line">&#123;</span><br><span class="line">    typename T::const_iterator bg = ve.begin(), be = ve.end();</span><br><span class="line">    while(bg != be)</span><br><span class="line">    &#123;</span><br><span class="line">        os &lt;&lt; *bg++;</span><br><span class="line">    &#125;</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () </span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vec=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    my_print(cout, vec) &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-11-26</span><i class="fa fa-tag"></i><a class="tag" href="/tags/c-plus/" title="c_plus">c_plus </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2016/11/26/Note/cpp/cpp_primer_part3/,Harryx,C++ Primer,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/03/14/hello-world/" title="Hello World">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2016/11/05/Note/python/library/web/flask/flask_deploy/" title="flask部署">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>greenlet · Harryx</title><meta name="description" content="greenlet是stackless的副产品，stackless是CPython的一个支持tasklets微线程的版本。
greenlet用于协程。与generators相比较的好处是，可以调用嵌套函数，以及不用使用yield关键字生成值。
示例假如有个循环读取用户输入并打印的线程12345678d"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Harryx</a></h3><div class="description"><p>good good study good good play~</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/harryx520"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/Booooyakasha"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="http://7xrooc.com1.z0.glb.clouddn.com/avatar.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>greenlet</a></h3></div><div class="post-content"><p>greenlet是stackless的副产品，stackless是CPython的一个支持tasklets微线程的版本。</p>
<p>greenlet用于协程。与generators相比较的好处是，可以调用嵌套函数，以及不用使用yield关键字生成值。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>假如有个循环读取用户输入并打印的线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def process_command():</div><div class="line">    while True:</div><div class="line">        value = read_next_char()</div><div class="line">        print(value)</div><div class="line"></div><div class="line">def read_next_char():</div><div class="line">    value = input()</div><div class="line">    return value</div></pre></td></tr></table></figure></p>
<p>现在希望将这个功能插入到一个现有项目中，通过事件的方式调用<code>read_next_char()</code>，可能会考虑用独立的线程处理<code>process_command()</code>，但是用greelet是一种替代方案，没有相关锁定和关闭的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">def process_command():</div><div class="line">    while True:</div><div class="line">        value = read_next_char()</div><div class="line">        print(value)</div><div class="line"></div><div class="line"></div><div class="line">def event_call(value):</div><div class="line">    g_processor.switch(value)</div><div class="line"></div><div class="line"></div><div class="line">def read_next_char():</div><div class="line">    g_self = greenlet.getcurrent()</div><div class="line">    value = g_self.parent.switch()</div><div class="line">    return value</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    g_processor = greenlet.greenlet(process_command)</div><div class="line">    g_processor.switch()</div><div class="line"></div><div class="line">    while True:</div><div class="line">        line = input()</div><div class="line">        event_call(line)</div></pre></td></tr></table></figure>
<p>首先利用greelet启动<code>process_command()</code>函数，当调用<code>switch()</code>时开始执行，然后<code>process_command()</code> 调用<code>read_next_char()</code>，当执行到<code>parent.switch()</code>时g_processor挂起并切换到父greelet，也就是主线程，main下的while True就是一个主线程，当主线程调用<code>event_call(line)</code>时，该函数调用<code>switch()</code>切换到g_processor，继续执行挂起的<code>read_next_char()</code>并传递参数，<code>process_command</code>获得返回的值并打印。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>greenlet是一个独立的伪线程，可以想象成一个小的frame堆，底部frame是调用的初始函数(greenlet指定的函数)，顶部frame是当前暂停的函数。通过创建大量这样的堆并且在它们之间切换以完成任务，注意不会隐式切换，需要明确调用。</p>
<p>当创建一个greenlet时，获得了一个空堆，当switch到它时，开始运行这个greenlet指定的函数，这个函数可能调用其他函数或者切换到其他greenlet。当堆底部函数结束调用时，这个greenlet的堆又变为空，然后就认为这个greenlet结束生命周期，greenlet也可能因为未捕获异常结束生命周期。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def test1():</div><div class="line">    print(1)</div><div class="line">    gr2.switch()</div><div class="line">    print(2)</div><div class="line"></div><div class="line"></div><div class="line">def test2():</div><div class="line">    print(3)</div><div class="line">    gr1.switch()</div><div class="line">    print(4)</div><div class="line"></div><div class="line"></div><div class="line">gr1 = greenlet.greenlet(test1)</div><div class="line">gr2 = greenlet.greenlet(test2)</div><div class="line">gr1.switch()</div></pre></td></tr></table></figure></p>
<p>首先创建了两个greenlet，当调用<code>gr1.switch()</code>时，执行指定的<code>test1()</code>函数，打印一个1，然后挂起切换到<code>test2()</code>，打印一个3，然后切换回<code>test1()</code>，继续之前挂起的内容，打印2，<code>test1()</code> 执行完成，gr1现在完成了生命周期，回到<code>gr1.switch()</code>语句，然后程序运行结束，这里4不会被打印出来。</p>
<h2 id="Parents"><a href="#Parents" class="headerlink" title="Parents"></a>Parents</h2><p>每个greenlet有一个父greenlet，父greenlet在创建这个greenlet的地方(可以在任何时候修改)初始化，当greenlet完成完成生命周期后会回到父greenlet执行。这些greenlet通过这种方式组织为树结构，而不在用户创建的greenlet中运行的顶层代码为树的根，隐藏在main greenlet中。</p>
<p>上面的例子中，gr1和gr2都把main greenlet作为父项，每当其中一个生命周期结束，执行回到main。</p>
<p>没有捕获的异常也会传播到父项。比如如果上例中test2抛出异常，会把gr2杀掉并传递异常给父项，也就是main greenlet，虽然是由test1切换给test2，但traceback将显示test2异常，而不是test1。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><code>greenlet.greenlet(run=None, parent=None)</code><br>greenlet object，run参数指定调用对象，parent指定父greenlet，默认指定当前greenlet。</p>
<p><code>greenlet.getcurrent()</code><br>获取当前greenlet。</p>
<p><code>greenlet.GreenletExit</code><br>这个特殊的异常不会传递给父项，用于杀死某个greenlet。</p>
<p>greenlet可以被继承，一个greenlet通过调用run属性运行，子类也可以定义一个名为run的方法替代run属性。</p>
<h2 id="Switching"><a href="#Switching" class="headerlink" title="Switching"></a>Switching</h2><p>多个greenlet之间，当一个greenlet的switch()被调用时进行切换，这种情况下，执行跳转到调用switch()的greenlet，或者当一个greenlet完成生命周期，这种情况下，执行跳转到父greenlet。切换时，对象或者异常被发送给目标greenlet，可用于在greenlet之间传递消息。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def test1(x, y):</div><div class="line">    z = gr2.switch(x + y)</div><div class="line">    print(z)</div><div class="line"></div><div class="line"></div><div class="line">def test2(z):</div><div class="line">    z *= 2</div><div class="line">    gr1.switch(z)</div><div class="line"></div><div class="line"></div><div class="line">gr1 = greenlet.greenlet(test1)</div><div class="line">gr2 = greenlet.greenlet(test2)</div><div class="line">gr1.switch(1, 2)</div></pre></td></tr></table></figure>
<p>这里打印出6。</p>
<p><code>g.switch()</code><br>切换执行并发送参数给greenlet <code>g</code>，特殊情况下，如果<code>g</code>没有在执行，这个调用会使其开始运行。</p>
<p>Dying greenlet<br>如果一个greenlet的run()调用结束，它的返回值会被发送给父项，如果run()由于异常中断，异常会被传递给父项(除非是greenlet.GreenletExit)。</p>
<p>除了以上几种情况，目标greenlet通常接收那个挂起的对象的传入值作为switch()的返回值，事实上，尽管switch调用不会立即返回，但它会在未来的某个时间点切换回来的时候返回。当出现这种情况，暂停将在switch()之后回复，并且switch()本身会返回刚刚发送的对象。意味着，<code>x = g.switch(y)</code>会发送<code>y</code>给<code>g</code>，并且随后会将一些其他greenlet传递的对象返回赋值给<code>x</code>。</p>
<h2 id="greenlet的方法和属性"><a href="#greenlet的方法和属性" class="headerlink" title="greenlet的方法和属性"></a>greenlet的方法和属性</h2><p><code>g.switch(*args, **kwargs)</code><br>挂起当前greenlet，切换执行到greenlet <code>g</code>。</p>
<p><code>g.run</code><br><code>g</code>的可调用对象，将在开始时调用。</p>
<p><code>g.parent</code><br>父parent，是可写的，但是不允许创建环状父项。</p>
<p><code>g.gr_frame</code><br>当前顶部frame，或者None，比如上例中，当从test1切换到test2时，gr1的顶部frame就是刚刚暂停的test1。而test2正在执行，没有顶层frame，所以<code>gr2.gr_frame</code>为None。</p>
<p><code>g.dead</code><br>判断<code>g</code>有没有完成生命周期</p>
<p><code>bool(g)</code><br>如果g是活跃的，返回True，如果已经完成生命周期或者还没开始，返回False。</p>
<p><code>g.throw([typ[, val[, tb]]])</code><br>挂起当前greenlet，切换执行到<code>g</code>，但是在<code>g</code>中立刻抛出给与的异常。如果没有提供参数，默认为greenlet.GreenletExit。效果等同于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def raiser():</div><div class="line">    raise typ, val, tb</div><div class="line">g_raiser = greenlet(raiser, parent=g)</div><div class="line">g_raiser.switch()</div></pre></td></tr></table></figure>
<h2 id="Greenlets和Python-threads"><a href="#Greenlets和Python-threads" class="headerlink" title="Greenlets和Python threads"></a>Greenlets和Python threads</h2><p>greenlets可以和Python threads结合使用，这种情况下，每个线程有个独立的main greenlet以及独立的树结构。不同线程的greenlet之前不能混合或切换。</p>
<h2 id="垃圾回收greenlets"><a href="#垃圾回收greenlets" class="headerlink" title="垃圾回收greenlets"></a>垃圾回收greenlets</h2><p>如果一个greeblet的所有引用都消失(包括父项的以及其他greenlet的引用)，那么就没办法切换回这个greenlet。这种情况下，greenlet生成一个GreenletExit异常，这是greenlet收到异步执行的唯一情况。这给与<code>try:finally:</code>有机会清理greenlet持有的资源。这个特性支持使用无限循环等待数据并处理的编程风格，这个循环会在所有引用消失时中断。</p>
<p>一个greenlet期望于要么结束生命周期要么由于一个新的引用复苏，仅仅捕获并或略GreenletExot异常往往导致一个无限循环。</p>
<p>greenlet不参与垃圾回收，greenlet内部的循环引用将不会被检测到，保存greenlet的循环引用将导致内存泄漏。</p>
<h2 id="跟踪支持"><a href="#跟踪支持" class="headerlink" title="跟踪支持"></a>跟踪支持</h2><p>标准Python跟踪和分析对greenlet不起作用，因为帧和堆在同一Python线程。使用传统方法很难检测到greenlet切换，所以为了改善调试，greenlet模块有一些新的函数用于追踪和分析greenlet代码。</p>
<p><code>greenlet.gettrace()</code><br>返回一个之前设置的跟踪函数或者None。</p>
<p><code>greenlet.settrace(callback)</code><br>设置一个新的跟踪函数，并且返回一个之前设置的跟踪函数，或者None。callback在各种事件中被调用，预计有一下签名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def callback(event, args):</div><div class="line">    if event == &apos;switch&apos;:</div><div class="line">        origin, target = args</div><div class="line">        # 处理一个从origin到target的switch调用。</div><div class="line">        # 注意callback在target greenlet上下文运行。</div><div class="line">        # 异常使用target.throw()传递。</div><div class="line">    if event == &apos;throw&apos;:</div><div class="line">        origin, target = args</div><div class="line">        # 处理一个从origin到target的throw调用。</div><div class="line">        # Note that callback is running in the context of target</div><div class="line">        # greenlet and any exceptions will replace the original, as</div><div class="line">        # if target.throw() was used with the replacing exception.</div><div class="line">        return</div></pre></td></tr></table></figure></p>
<p>为了兼容性，只有当event是switch或者throw时对args解包才是重要的，这个API可以被扩展到新的类似<code>sys.settracfe()</code>的事件。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-03</span><i class="fa fa-tag"></i><a href="/tags/python/" title="python" class="tag">python </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2018/03/03/Note/python/library/coroutine/greenlet/,Harryx,greenlet,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2018/03/03/Note/basic/server/" title="常见服务模型" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2018/02/28/Note/cpp/asio/" title="asio" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
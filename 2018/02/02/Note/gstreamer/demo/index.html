<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>gstreamer example · Harryx</title><meta name="description" content="播放一个amr的音频文件头文件如下:12345678910111213141516171819202122232425262728#include &amp;quot;gst/gst.h&amp;quot;#include &amp;lt;thread&amp;gt;typedef struct&amp;#123;	GMainLoop *"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Harryx</a></h3><div class="description"><p>good good study good good play~</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/harryx520"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/Booooyakasha"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/avator.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>gstreamer example</a></h3></div><div class="post-content"><h1 id="播放一个amr的音频文件"><a href="#播放一个amr的音频文件" class="headerlink" title="播放一个amr的音频文件"></a>播放一个amr的音频文件</h1><p>头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &lt;thread&gt;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GMainLoop *loop;</div><div class="line">	GstElement *pipeline;</div><div class="line">	GstElement *filesrc, *audioparse, *audiodec, *audioconvert, *audiosink;</div><div class="line">&#125;AudioPlayerData;</div><div class="line"></div><div class="line">class AudioPlayer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	explicit AudioPlayer(QString path);</div><div class="line">	~AudioPlayer();</div><div class="line"></div><div class="line">	void start();</div><div class="line">	void stop();</div><div class="line">	bool is_running();</div><div class="line"></div><div class="line">private:</div><div class="line">	void run();</div><div class="line"></div><div class="line">private:</div><div class="line">	AudioPlayerData *data;</div><div class="line"></div><div class="line">	std::thread t;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>播放amr音频文件需要用到以下元件:</p>
<ul>
<li>filesrc</li>
<li>amrparse</li>
<li>amrnbdec</li>
<li>audioconvert</li>
<li>autoaudiosink</li>
</ul>
<p>因为需要监听播放完成事件，所以创建一个mainloop:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data-&gt;loop = g_main_loop_new(NULL, FALSE);</div></pre></td></tr></table></figure></p>
<p>创建各个元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data-&gt;pipeline = gst_pipeline_new(&quot;audio_player&quot;);</div><div class="line">data-&gt;filesrc = gst_element_factory_make(&quot;filesrc&quot;, &quot;audio_player_filesrc&quot;);</div><div class="line">data-&gt;audioparse = gst_element_factory_make(&quot;amrparse&quot;, &quot;audio_player_parse&quot;);</div><div class="line">data-&gt;audiodec = gst_element_factory_make(&quot;amrnbdec&quot;, &quot;audio_player_dec&quot;);</div><div class="line">data-&gt;audioconvert = gst_element_factory_make(&quot;audioconvert&quot;, &quot;audio_player_convert&quot;);</div><div class="line">data-&gt;audiosink = gst_element_factory_make(&quot;autoaudiosink&quot;, &quot;audio_player_sink&quot;);</div></pre></td></tr></table></figure></p>
<p>指定一下filesrc文件路径:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g_object_set(data-&gt;filesrc,</div><div class="line">	&quot;location&quot;, path.toStdString().c_str(),</div><div class="line">	NULL);</div></pre></td></tr></table></figure></p>
<p>从pipeline中获取一个GstBus对象，然后设置监听并绑定一个回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(data-&gt;pipeline));</div><div class="line">gst_bus_add_watch(bus, call_back, data);</div><div class="line">gst_object_unref(bus);</div></pre></td></tr></table></figure></p>
<p>定义一个回调函数， 当获取到播放完成或错误事件的时候关闭通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static gboolean call_back(GstBus *, GstMessage *msg, gpointer data)</div><div class="line">&#123;</div><div class="line">	switch (GST_MESSAGE_TYPE(msg))</div><div class="line">	&#123;</div><div class="line">		case GST_MESSAGE_EOS:</div><div class="line">		case GST_MESSAGE_ERROR:</div><div class="line">			gst_element_set_state(static_cast&lt;AudioPlayerData*&gt;(data)-&gt;pipeline, GST_STATE_NULL);</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将元件添加到pipeline并连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;filesrc, data-&gt;audioparse,</div><div class="line">	data-&gt;audiodec, data-&gt;audioconvert, data-&gt;audiosink, NULL);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;filesrc, data-&gt;audioparse, data-&gt;audiodec, data-&gt;audioconvert, data-&gt;audiosink, NULL))</div><div class="line">&#123;</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link audio player&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提供一些简单的接口，用于查询控制播放，这里用一个单独的线程跑loop：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void AudioPlayer::start()</div><div class="line">&#123;</div><div class="line">	t = std::thread(&amp;AudioPlayer::run, this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void AudioPlayer::stop()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_main_loop_quit(data-&gt;loop);</div><div class="line">	if (t.joinable())</div><div class="line">		t.join();</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool AudioPlayer::is_running()</div><div class="line">&#123;</div><div class="line">	GstState state;</div><div class="line">	gst_element_get_state(data-&gt;pipeline, &amp;state, NULL, GstClockTime(1000000));</div><div class="line">	return state == GST_STATE_PLAYING;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void AudioPlayer::run()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">	g_main_loop_run(data-&gt;loop);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>析构的时候关闭通道释放资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AudioPlayer::~AudioPlayer()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_main_loop_quit(data-&gt;loop);</div><div class="line">	if(t.joinable())</div><div class="line">		t.join();</div><div class="line">	g_object_unref(data-&gt;pipeline);</div><div class="line">	g_free(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="生成一个amr音频文件"><a href="#生成一个amr音频文件" class="headerlink" title="生成一个amr音频文件"></a>生成一个amr音频文件</h1><p>头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GstElement *pipeline;</div><div class="line">	GstElement *audiosrc, *audioconv, *audioenc, *filesink;</div><div class="line">&#125;ShortAudioData;</div><div class="line"></div><div class="line">class ShortAudio</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	explicit ShortAudio(QString path);</div><div class="line">	~ShortAudio();</div><div class="line"></div><div class="line">	void start();</div><div class="line">	void stop();</div><div class="line"></div><div class="line">private:</div><div class="line">	ShortAudioData *data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>生成amr用到以下元件:</p>
<ul>
<li>autoaudiosrc</li>
<li>audioconvert</li>
<li>amrnbenc</li>
<li>filesink</li>
</ul>
<p>生成的amr文件是不能直接播放的，需要添加头:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const char header[6] = &#123; 0x23, 0x21, 0x41, 0x4d, 0x52, 0x0a&#125;;</div><div class="line">std::ofstream of(path.toStdString(), std::ofstream::binary);</div><div class="line">of.write(header, 6);</div></pre></td></tr></table></figure></p>
<p>设置码率和模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g_object_set(data-&gt;audioenc, </div><div class="line">	&quot;target&quot;, &quot;bitrate&quot;,</div><div class="line">	&quot;bitrate&quot;, 192,</div><div class="line">	NULL);</div></pre></td></tr></table></figure></p>
<p>设置文件路径，因为已经输入了头，所以指定以append的方式添加数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g_object_set(data-&gt;filesink,</div><div class="line">	&quot;append&quot;, true,</div><div class="line">	&quot;location&quot;, path.toStdString().c_str(),</div><div class="line">	NULL);</div></pre></td></tr></table></figure></p>
<p>连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;audiosrc, data-&gt;audioconv,</div><div class="line">	data-&gt;audioenc, data-&gt;filesink);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;audiosrc, data-&gt;audioconv, data-&gt;audioenc, data-&gt;filesink, NULL))</div><div class="line">&#123;</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link short video&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提供简单的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void ShortAudio::start()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void ShortAudio::stop()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>析构的时候释放资源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ShortAudio::~ShortAudio()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_object_unref(data-&gt;pipeline);</div><div class="line">	g_free(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="预览并录制保存mp4-视频"><a href="#预览并录制保存mp4-视频" class="headerlink" title="预览并录制保存mp4 视频"></a>预览并录制保存mp4 视频</h1><p>头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;QWidget&gt;</div><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &lt;gst/video/videooverlay.h&gt;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GstElement *pipeline_view, *view_src, *view_sink;</div><div class="line">	GstElement *pipeline;</div><div class="line">	GstElement *videosrc, *videorate, *videoconvert, *encqueue, *videoenc, *videodec, *videoparse;</div><div class="line">	GstElement *videotee, *sinkqueue, *videosinkconv, *videosink;</div><div class="line">	GstElement *audiosrc, *audiorate, *audioconvert, *audioenc;</div><div class="line">	GstElement *muxer, *filesink, *fakesink;</div><div class="line">&#125;ShortVideoData;</div><div class="line"></div><div class="line">class ShortVideo</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	explicit ShortVideo(QString path, QWidget *window);</div><div class="line">	~ShortVideo();</div><div class="line"></div><div class="line">	void start();</div><div class="line">	void stop();</div><div class="line"></div><div class="line">private:</div><div class="line">	ShortVideoData *data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>首先建立一个用于预览的通道，直接连接视频源和播放器，因为需要指定播放器播放的界面，所以这里用d3dvideosink作为播放元件，后面会指定界面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data-&gt;pipeline_view = gst_pipeline_new(&quot;video_view&quot;);</div><div class="line"></div><div class="line">data-&gt;view_src = gst_element_factory_make(&quot;autovideosrc&quot;, &quot;view_src&quot;);</div><div class="line">data-&gt;view_sink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;view_sink&quot;);</div><div class="line"></div><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline_view), data-&gt;view_src, data-&gt;view_sink, NULL);</div><div class="line">if (!gst_element_link_many(data-&gt;view_src, data-&gt;view_sink, NULL))</div><div class="line">&#123;</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link view&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>录制通道视频源需要分成两路，一路用于预览，一路用于生成视频文件，需要注意的是如果直接把数据源分两路，会使通道卡死，原因未知，所以先编码成h264然后用tee元件分成两路:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data-&gt;videosrc = gst_element_factory_make(&quot;autovideosrc&quot;, &quot;shortvideo_src&quot;);</div><div class="line">data-&gt;videoconvert = gst_element_factory_make(&quot;videoconvert&quot;, &quot;shortvideo_conv2&quot;);</div><div class="line">data-&gt;videoenc = gst_element_factory_make(&quot;openh264enc&quot;, &quot;shortvideo_enc&quot;);</div><div class="line">data-&gt;videoparse = gst_element_factory_make(&quot;h264parse&quot;, &quot;shortvideo_parse&quot;);</div><div class="line">data-&gt;videotee = gst_element_factory_make(&quot;tee&quot;, &quot;shortvideo_tee&quot;);</div></pre></td></tr></table></figure></p>
<p>建立预览通道:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data-&gt;sinkqueue = gst_element_factory_make(&quot;queue&quot;, &quot;shortvideo_sinkqueue&quot;);</div><div class="line">data-&gt;videodec = gst_element_factory_make(&quot;avdec_h264&quot;, &quot;shortvideo_decodebin&quot;);</div><div class="line">data-&gt;videosink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;shortvideo_sink&quot;);</div></pre></td></tr></table></figure></p>
<p>编码通道需要使用mp4mux与音频混合成mp4视频文件，音频使用的是voaacenc元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">data-&gt;audiosrc = gst_element_factory_make(&quot;autoaudiosrc&quot;, &quot;shortaudio_src&quot;);</div><div class="line">data-&gt;audiorate = gst_element_factory_make(&quot;audiorate&quot;, &quot;shortaudio_rate&quot;);</div><div class="line">data-&gt;audioconvert = gst_element_factory_make(&quot;audioconvert&quot;, &quot;shortaudio_conv&quot;);</div><div class="line">data-&gt;audioenc = gst_element_factory_make(&quot;voaacenc&quot;, &quot;shortaudio_enc&quot;);</div><div class="line"></div><div class="line">data-&gt;muxer = gst_element_factory_make(&quot;mp4mux&quot;, &quot;short_mm&quot;);</div><div class="line">data-&gt;filesink = gst_element_factory_make(&quot;filesink&quot;, &quot;short_fs&quot;);</div><div class="line"></div><div class="line">data-&gt;fakesink = gst_element_factory_make(&quot;fakesink&quot;, &quot;short_video_fakesink&quot;);</div></pre></td></tr></table></figure></p>
<p>设置文件路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_object_set(data-&gt;filesink, &quot;location&quot;, path.toStdString().c_str(), NULL);</div></pre></td></tr></table></figure></p>
<p>将录制通道所有元件添加到pipeline:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;videosrc, data-&gt;videoconvert, data-&gt;videoenc, data-&gt;videoparse,</div><div class="line">	data-&gt;videotee, data-&gt;sinkqueue, data-&gt;videodec, data-&gt;videosink, data-&gt;encqueue,</div><div class="line">	data-&gt;audiosrc, data-&gt;audiorate, data-&gt;audioconvert, data-&gt;audioenc, data-&gt;muxer, data-&gt;filesink, NULL);</div></pre></td></tr></table></figure></p>
<p>连接视频源通道:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (!gst_element_link_many(data-&gt;videosrc, data-&gt;videoconvert, data-&gt;videoenc, data-&gt;videoparse, data-&gt;videotee, NULL))</div><div class="line">&#123;</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link video&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>连接预览通道:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GstPad *srcpad, *sinkpad;</div><div class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_0&quot;);</div><div class="line">sinkpad = gst_element_get_static_pad(data-&gt;sinkqueue, &quot;sink&quot;);</div><div class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link tee and sendconv&quot;;</div><div class="line">gst_object_unref(srcpad);</div><div class="line">gst_object_unref(sinkpad);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;sinkqueue, data-&gt;videodec, data-&gt;videosink, NULL))</div><div class="line">&#123;</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link video&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>连接录制通道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_1&quot;);</div><div class="line">sinkpad = gst_element_get_static_pad(data-&gt;encqueue, &quot;sink&quot;);</div><div class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link tee and playsink&quot;;</div><div class="line">gst_object_unref(srcpad);</div><div class="line">gst_object_unref(sinkpad);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;audiosrc, data-&gt;audiorate, data-&gt;audioconvert, data-&gt;audioenc, NULL))</div><div class="line">&#123;</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link audio&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将视频和音频混合:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">srcpad = gst_element_get_static_pad(data-&gt;encqueue, &quot;src&quot;);</div><div class="line">sinkpad = gst_element_get_request_pad(data-&gt;muxer, &quot;video_0&quot;);</div><div class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link video and muxer&quot;;</div><div class="line">gst_object_unref(srcpad);</div><div class="line">gst_object_unref(sinkpad);</div><div class="line"></div><div class="line">srcpad = gst_element_get_static_pad(data-&gt;audioenc, &quot;src&quot;);</div><div class="line">sinkpad = gst_element_get_request_pad(data-&gt;muxer, &quot;audio_0&quot;);</div><div class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link audio and muxer&quot;;</div><div class="line">gst_object_unref(srcpad);</div><div class="line">gst_object_unref(sinkpad);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;muxer, data-&gt;filesink, NULL))</div><div class="line">&#123;</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link file&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置界面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WId d3d = window-&gt;winId();</div><div class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;videosink), d3d);</div><div class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;view_sink), d3d);</div></pre></td></tr></table></figure></p>
<p>启动预览:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gst_element_set_state(data-&gt;pipeline_view, GST_STATE_PLAYING);</div></pre></td></tr></table></figure></p>
<p>播放时关闭预览，开启录制，注意需要在结束后给出一个结束信号，并且稍微延时，不然文件不能播放，停止时全部关闭:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void ShortVideo::start()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline_view, GST_STATE_NULL);</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void ShortVideo::stop()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline_view, GST_STATE_NULL);</div><div class="line">	gst_element_send_event(data-&gt;pipeline, gst_event_new_eos());</div><div class="line">	_sleep(1000);</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>释放资源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ShortVideo::~ShortVideo()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline_view, GST_STATE_NULL);</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_object_unref(data-&gt;pipeline);</div><div class="line">	g_object_unref(data-&gt;pipeline_view);</div><div class="line">	g_free(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="取MP4视频的其中一帧图像并保存"><a href="#取MP4视频的其中一帧图像并保存" class="headerlink" title="取MP4视频的其中一帧图像并保存"></a>取MP4视频的其中一帧图像并保存</h1><p>头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;QImage&gt;</div><div class="line">#include &lt;QString&gt;</div><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &quot;string.h&quot;</div><div class="line">#include &lt;gst/app/gstappsink.h&gt;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	std::string video_view_path;</div><div class="line">	GstElement *pipeline;</div><div class="line">	GstElement *filesrc, *qtdemux, *queue, *videodec, *videobox, *videoconv, *appsink;</div><div class="line">&#125;VideoImageViewData;</div><div class="line"></div><div class="line">class VideoImageView</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	explicit VideoImageView(QString path);</div><div class="line">	~VideoImageView();</div><div class="line"></div><div class="line">private:</div><div class="line">	static void new_video_sample_pad(GstElement *element, GstPad *pad, gpointer data);</div><div class="line">	static GstFlowReturn new_image_from_appsink(GstElement * elt, VideoImageViewData * data);</div><div class="line"></div><div class="line">private:</div><div class="line">	VideoImageViewData *data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用到如下元件:</p>
<ul>
<li>filesrc</li>
<li>qtdemux</li>
<li>queue</li>
<li>avdec_h264</li>
<li>videobox</li>
<li>videoconvert</li>
<li>appesink</li>
</ul>
<p>初始化元件，设置图片保存路径以及视频源路径:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">data-&gt;video_view_path = (path + &quot;.jpg&quot;).toStdString();</div><div class="line">data-&gt;pipeline = gst_pipeline_new(&quot;video_sample&quot;);</div><div class="line">data-&gt;filesrc = gst_element_factory_make(&quot;filesrc&quot;, &quot;video_sample_file_src&quot;);</div><div class="line">data-&gt;qtdemux = gst_element_factory_make(&quot;qtdemux&quot;, &quot;video_sample_demux&quot;);</div><div class="line">data-&gt;queue = gst_element_factory_make(&quot;queue&quot;, &quot;video_sample_queue&quot;);</div><div class="line">data-&gt;videodec = gst_element_factory_make(&quot;avdec_h264&quot;, &quot;video_sample_videodec&quot;);</div><div class="line">data-&gt;videobox = gst_element_factory_make(&quot;videobox&quot;, &quot;video_sample_videobox&quot;);</div><div class="line">data-&gt;videoconv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;video_sample_conv&quot;);</div><div class="line">data-&gt;appsink = gst_element_factory_make(&quot;appsink&quot;, &quot;video_sample_appsink&quot;);</div><div class="line">g_object_set(data-&gt;filesrc,</div><div class="line">	&quot;location&quot;, path.toStdString().c_str(),</div><div class="line">	NULL);</div></pre></td></tr></table></figure></p>
<p>对视频进行裁剪:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_object_set(G_OBJECT(data-&gt;videobox), &quot;autocrop&quot;, TRUE, NULL);</div></pre></td></tr></table></figure></p>
<p>定义appsink的caps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define VIDEO_SAMPLE_CONV_CAPS &quot;video/x-raw, format=(string)RGB16, width=(int)120, height=(int)160&quot;</div></pre></td></tr></table></figure></p>
<p>设置appsink的caps以及数据获取方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GstCaps *convert_caps;</div><div class="line">convert_caps = gst_caps_from_string(VIDEO_SAMPLE_CONV_CAPS);</div><div class="line">g_object_set(G_OBJECT(data-&gt;appsink), &quot;emit-signals&quot;, TRUE, &quot;sync&quot;, FALSE, NULL);</div><div class="line">g_object_set(G_OBJECT(data-&gt;videoconv), &quot;caps&quot;, convert_caps, NULL);</div><div class="line">g_object_set(G_OBJECT(data-&gt;appsink), &quot;caps&quot;, convert_caps, NULL);</div><div class="line">gst_caps_unref(convert_caps);</div></pre></td></tr></table></figure></p>
<p>分别连接源和视频处理通道，qtdemux需要以回调的方式连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (!gst_element_link_many(data-&gt;filesrc, data-&gt;qtdemux, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link filesrc qtdemux&quot;;</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;queue, data-&gt;videodec, data-&gt;videobox, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link queue videodec videobox&quot;;</div></pre></td></tr></table></figure></p>
<p>定义videobox和videoconvert之间的caps，连接后面的元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GstCaps *caps_box;</div><div class="line">caps_box = gst_caps_from_string(VIDEO_SAMPLE_BOX_CAPS);</div><div class="line">if (!gst_element_link_filtered(data-&gt;videobox, data-&gt;videoconv, caps_box))</div><div class="line">	qDebug() &lt;&lt; &quot;Failed to link caps&quot;;</div><div class="line">gst_caps_unref(caps_box);</div><div class="line">if (!gst_element_link_many(data-&gt;videoconv, data-&gt;appsink, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link videoconv appsink&quot;;</div></pre></td></tr></table></figure></p>
<p>定义qtdemux连接回调，因为只需要视频，当出现新连接，如果是视频sink则进行连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void VideoImageView::new_video_sample_pad(GstElement *, GstPad *pad, gpointer data)</div><div class="line">&#123;</div><div class="line">	GstPad *sinkpad;</div><div class="line">	sinkpad = gst_element_get_static_pad(static_cast&lt;VideoImageViewData*&gt;(data)-&gt;queue, &quot;sink&quot;);</div><div class="line">	if (gst_pad_link(pad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">		qDebug() &lt;&lt; &quot;fail to link qtdemux and videodec&quot;;</div><div class="line">	gst_object_unref(sinkpad);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>绑定pad-added信号和回调:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_signal_connect(data-&gt;qtdemux, &quot;pad-added&quot;, G_CALLBACK(new_video_sample_pad), data);</div></pre></td></tr></table></figure></p>
<p>定义appsink数据回调，当有新数据时，保存为图片:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GstFlowReturn</div><div class="line">VideoImageView::new_image_from_appsink(GstElement * elt, VideoImageViewData * data)</div><div class="line">&#123;</div><div class="line">	GstSample *sample;</div><div class="line">	GstBuffer *buffer;</div><div class="line">	GstMapInfo map;</div><div class="line">	sample = gst_app_sink_pull_sample(GST_APP_SINK(elt));</div><div class="line">	if (!sample)</div><div class="line">		return GstFlowReturn(0);</div><div class="line">	buffer = gst_sample_get_buffer(sample);</div><div class="line">	gst_buffer_map(buffer, &amp;map, GST_MAP_READ);</div><div class="line">	gst_sample_unref(sample);</div><div class="line"></div><div class="line">	QImage image = QImage(map.data, VIDEO_SAMPLE_WIDTH, VIDEO_SAMPLE_HEIGHT, QImage::Format_RGB16);</div><div class="line">	image.save(QString((data-&gt;video_view_path).c_str()), &quot;JPG&quot;);</div><div class="line"></div><div class="line">	gst_buffer_unmap(buffer, &amp;map);</div><div class="line"></div><div class="line">	return GstFlowReturn(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>绑定appsin的信号和回调函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g_signal_connect(data-&gt;qtdemux, &quot;pad-added&quot;, G_CALLBACK(new_video_sample_pad), data);</div><div class="line">g_signal_connect(data-&gt;appsink, &quot;new-sample&quot;, G_CALLBACK(new_image_from_appsink), data);</div></pre></td></tr></table></figure></p>
<p>直接启动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div></pre></td></tr></table></figure></p>
<p>析构时停止:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">VideoImageView::~VideoImageView()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_object_unref(data-&gt;pipeline);</div><div class="line">	g_free(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="播放一个mp4文件"><a href="#播放一个mp4文件" class="headerlink" title="播放一个mp4文件"></a>播放一个mp4文件</h1><p>头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;QWidget&gt;</div><div class="line">#include &lt;QDir&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;QDebug&gt;</div><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &lt;gst/video/videooverlay.h&gt;</div><div class="line">#include &lt;gst/app/gstappsrc.h&gt;</div><div class="line">#include &lt;gst/app/gstappsink.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GMainLoop *loop;</div><div class="line">	GstElement *playbin, *videosink;</div><div class="line">	GstElement *pipeline;</div><div class="line">	GstElement *filesrc, *qtdemux;</div><div class="line">	GstElement *video_queue, *video_dec, *video_flip, *video_conv, *video_sink;</div><div class="line">	GstElement *audio_queue, *audio_dec, *audio_conv, *audio_sink;</div><div class="line">&#125;VideoPlayerData;</div><div class="line"></div><div class="line">class VideoPlayer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	explicit VideoPlayer(QString path, QWidget* widget);</div><div class="line">	~VideoPlayer();</div><div class="line"></div><div class="line">	void start();</div><div class="line">	void stop();</div><div class="line">	bool is_running();</div><div class="line">	gint64 get_pos();</div><div class="line">	gint64 get_dur();</div><div class="line"></div><div class="line">private:</div><div class="line">	void run();</div><div class="line">	static gboolean call_back(GstBus *, GstMessage *msg, gpointer data);</div><div class="line">	static void new_player_pad(GstElement *, GstPad *pad, gpointer data);</div><div class="line"></div><div class="line">private:</div><div class="line">	VideoPlayerData *data;</div><div class="line">	std::thread t;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>需要用到的元件:</p>
<ul>
<li>filesrc</li>
<li>qtdemux</li>
<li>queue</li>
<li>avdec_h264</li>
<li>videoflip</li>
<li>videoconvert</li>
<li>d3dvideosink</li>
<li>queue</li>
<li>avdec_aac</li>
<li>audioconvert</li>
<li>autoaudiosink</li>
</ul>
<p>初始化元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">data-&gt;loop = g_main_loop_new(NULL, FALSE);</div><div class="line"></div><div class="line">data-&gt;pipeline = gst_pipeline_new(&quot;player_pipeline&quot;);</div><div class="line">data-&gt;filesrc = gst_element_factory_make(&quot;filesrc&quot;, &quot;player_filesrc&quot;);</div><div class="line">data-&gt;qtdemux = gst_element_factory_make(&quot;qtdemux&quot;, &quot;player_qtdemux&quot;);</div><div class="line"></div><div class="line">data-&gt;video_queue = gst_element_factory_make(&quot;queue&quot;, &quot;player_video_queue&quot;);</div><div class="line">data-&gt;video_dec = gst_element_factory_make(&quot;avdec_h264&quot;, &quot;player_video_dec&quot;);</div><div class="line">data-&gt;video_flip = gst_element_factory_make(&quot;videoflip&quot;, &quot;player_video_flip&quot;);</div><div class="line">data-&gt;video_conv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;player_video_convert&quot;);</div><div class="line">data-&gt;video_sink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;player_video_sink&quot;);</div><div class="line"></div><div class="line">data-&gt;audio_queue = gst_element_factory_make(&quot;queue&quot;, &quot;player_audio_queue&quot;);</div><div class="line">data-&gt;audio_dec = gst_element_factory_make(&quot;avdec_aac&quot;, &quot;player_audio_dec&quot;);</div><div class="line">data-&gt;audio_conv = gst_element_factory_make(&quot;audioconvert&quot;, &quot;player_audio_conv&quot;);</div><div class="line">data-&gt;audio_sink = gst_element_factory_make(&quot;autoaudiosink&quot;, &quot;player_audio_sink&quot;);</div></pre></td></tr></table></figure></p>
<p>这里使用了mainloop，但应该是不需要的，因为并没有需要检测停止信号。</p>
<p>设置文件路径，设置视频自动旋转，这样videoflip会自动检测视频是否需要旋转，并进行旋转操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g_object_set(data-&gt;filesrc, &quot;location&quot;, path.toStdString().c_str(), NULL);</div><div class="line">g_object_set(data-&gt;video_flip, &quot;method&quot;, 8, NULL);</div></pre></td></tr></table></figure></p>
<p>qtdemux需要用信号的方式连接，因此先连接几个通道:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;filesrc, data-&gt;qtdemux, </div><div class="line">	data-&gt;video_queue, data-&gt;video_dec, data-&gt;video_flip, data-&gt;video_conv, data-&gt;video_sink,</div><div class="line">	data-&gt;audio_queue, data-&gt;audio_dec, data-&gt;audio_conv, data-&gt;audio_sink, NULL);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;filesrc, data-&gt;qtdemux, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link filesrc qtdemux&quot;;</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;video_queue, data-&gt;video_dec, data-&gt;video_flip, </div><div class="line">	data-&gt;video_conv, data-&gt;video_sink, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link player video queue&quot;;</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;audio_queue, data-&gt;audio_dec, data-&gt;audio_conv,</div><div class="line">	data-&gt;audio_sink, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link player audio queue&quot;;</div></pre></td></tr></table></figure></p>
<p>定义qtdemux的连接回调函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void VideoPlayer::new_player_pad(GstElement *, GstPad *pad, gpointer data)</div><div class="line">&#123;</div><div class="line">	auto name = gst_object_get_name(GST_OBJECT_CAST(pad));</div><div class="line"></div><div class="line">	if (QString(static_cast&lt;char*&gt;(name)) == &quot;video_0&quot;)</div><div class="line">	&#123;</div><div class="line">		GstPad *sinkpad;</div><div class="line">		sinkpad = gst_element_get_static_pad(static_cast&lt;VideoPlayerData*&gt;(data)-&gt;video_queue, &quot;sink&quot;);</div><div class="line">		if (gst_pad_link(pad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">			qDebug() &lt;&lt; &quot;fail to link qtdemux and videodec&quot;;</div><div class="line">		gst_object_unref(sinkpad);</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		GstPad *sinkpad;</div><div class="line">		sinkpad = gst_element_get_static_pad(static_cast&lt;VideoPlayerData*&gt;(data)-&gt;audio_queue, &quot;sink&quot;);</div><div class="line">		if (gst_pad_link(pad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">			qDebug() &lt;&lt; &quot;fail to link qtdemux and audiodec&quot;;</div><div class="line">		gst_object_unref(sinkpad);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>绑定信号:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_signal_connect(data-&gt;qtdemux, &quot;pad-added&quot;, G_CALLBACK(new_player_pad), data);</div></pre></td></tr></table></figure></p>
<p>设置界面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WId d3d = widget-&gt;winId();</div><div class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;video_sink), d3d);</div></pre></td></tr></table></figure></p>
<p>提供控制接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void VideoPlayer::start()</div><div class="line">&#123;</div><div class="line">	t = std::thread(&amp;VideoPlayer::run, this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void VideoPlayer::stop()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_main_loop_quit(data-&gt;loop);</div><div class="line">	if (t.joinable())</div><div class="line">		t.join();</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool VideoPlayer::is_running()</div><div class="line">&#123;</div><div class="line">	GstState state;</div><div class="line">	gst_element_get_state(data-&gt;pipeline, &amp;state, NULL, GstClockTime(1000000));</div><div class="line">	return state == GST_STATE_PLAYING;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void VideoPlayer::run()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">	g_main_loop_run(data-&gt;loop);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提供获取播放信息的接口，分别是播放的位置，以及总长度:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gint64 VideoPlayer::get_pos()</div><div class="line">&#123;</div><div class="line">	GstFormat fmt = GST_FORMAT_TIME;</div><div class="line">	gint64 res;</div><div class="line">	gst_element_query_position(data-&gt;pipeline, fmt, &amp;res);</div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gint64 VideoPlayer::get_dur()</div><div class="line">&#123;</div><div class="line">	GstFormat fmt = GST_FORMAT_TIME;</div><div class="line">	gint64 res;</div><div class="line">	gst_element_query_duration(data-&gt;pipeline, fmt, &amp;res);</div><div class="line">	return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="TCP发送音频流"><a href="#TCP发送音频流" class="headerlink" title="TCP发送音频流"></a>TCP发送音频流</h1><p>这里继承了QThread，头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;QThread&gt;</div><div class="line">#include &lt;QDebug&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;winsock2.h&gt;</div><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &lt;gst/app/gstappsrc.h&gt;</div><div class="line">#include &lt;gst/app/gstappsink.h&gt;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GMainLoop *loop;</div><div class="line">	GstElement *src, *convert, *encoder, *sink;</div><div class="line">	GstElement *pipeline;</div><div class="line">	SOCKET sock;</div><div class="line">	SOCKADDR_IN address;</div><div class="line">&#125; AudioSenderData;</div><div class="line"></div><div class="line"></div><div class="line">class AudioSender : public QThread</div><div class="line">&#123;</div><div class="line">    Q_OBJECT</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit AudioSender(SOCKET &amp;sk, QString host);</div><div class="line">    ~AudioSender();</div><div class="line"></div><div class="line">	void run();</div><div class="line">	static GstFlowReturn</div><div class="line">		on_new_sample_from_sink(GstElement * elt, AudioSenderData * data);</div><div class="line">	static int32_t	bytes_count;</div><div class="line"></div><div class="line">private:</div><div class="line">	AudioSenderData *data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用到的元件如下:</p>
<ul>
<li>autoaudiosrc</li>
<li>audioconvert</li>
<li>voaacenc</li>
<li>appsink</li>
</ul>
<p>初始化元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data-&gt;sock = sk;</div><div class="line">data-&gt;pipeline = gst_pipeline_new(&quot;audio_pipeline_sender&quot;);</div><div class="line">data-&gt;src = gst_element_factory_make(&quot;autoaudiosrc&quot;, &quot;audio_src_sender&quot;);</div><div class="line">data-&gt;convert = gst_element_factory_make(&quot;audioconvert&quot;, &quot;audio_conv_sender&quot;);</div><div class="line">data-&gt;encoder = gst_element_factory_make(&quot;voaacenc&quot;, &quot;audio_enc_sender&quot;);</div><div class="line">data-&gt;sink = gst_element_factory_make(&quot;appsink&quot;, &quot;audio_sink_sender&quot;);</div></pre></td></tr></table></figure></p>
<p>设置一下码率:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_object_set(G_OBJECT(data-&gt;encoder), &quot;bitrate&quot;, bitrate, NULL);</div></pre></td></tr></table></figure></p>
<p>设置appsink以信号方式获取数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_object_set(G_OBJECT(data-&gt;sink), &quot;emit-signals&quot;, TRUE, &quot;sync&quot;, FALSE, NULL);</div></pre></td></tr></table></figure></p>
<p>定义一个处理数据的回调，取出数据之后通过TCP发送:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">GstFlowReturn AudioSender::on_new_sample_from_sink(GstElement * elt, AudioSenderData * data)</div><div class="line">&#123;</div><div class="line">	GstSample *sample;</div><div class="line">	GstBuffer *buffer;</div><div class="line">	GstMapInfo map;</div><div class="line">	sample = gst_app_sink_pull_sample(GST_APP_SINK(elt));</div><div class="line">	if (!sample)</div><div class="line">		return GstFlowReturn(0);</div><div class="line">	buffer = gst_sample_get_buffer(sample);</div><div class="line">	gst_buffer_map(buffer, &amp;map, GST_MAP_READ);</div><div class="line"></div><div class="line">	gst_sample_unref(sample);</div><div class="line"></div><div class="line">	gsize map_size;</div><div class="line">	gsize total_size;</div><div class="line">	map_size = map.size;</div><div class="line">	total_size = map_size + 2;</div><div class="line"></div><div class="line">	guint8 size_buffer[6];</div><div class="line">	size_buffer[0] = total_size;</div><div class="line">	size_buffer[1] = total_size &gt;&gt; 8;</div><div class="line">	size_buffer[2] = total_size &gt;&gt; 16;</div><div class="line">	size_buffer[3] = total_size &gt;&gt; 24;</div><div class="line"></div><div class="line">	size_buffer[4] = 0;</div><div class="line">	size_buffer[5] = 0;</div><div class="line"></div><div class="line">	gsize send_size = 0;</div><div class="line">	gsize server_send;</div><div class="line">	while (send_size &lt; 6)</div><div class="line">	&#123;</div><div class="line">		server_send = send(data-&gt;sock, (char *)size_buffer + send_size, </div><div class="line">			6 - send_size, 0);</div><div class="line">		send_size += server_send;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	send_size = 0;</div><div class="line">	while (send_size &lt; map_size)</div><div class="line">	&#123;</div><div class="line">		server_send = send(data-&gt;sock, (char *)(map.data) + send_size,</div><div class="line">			map_size - send_size, 0);</div><div class="line">		send_size += server_send;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	gst_buffer_unmap(buffer, &amp;map);</div><div class="line"></div><div class="line">	return GstFlowReturn(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置appsink回调:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g_signal_connect(data-&gt;sink, &quot;new-sample&quot;,</div><div class="line">	G_CALLBACK(on_new_sample_from_sink), data);</div></pre></td></tr></table></figure></p>
<p>设置appsink caps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define AUDIO_AAC_SENDER &quot;audio/mpeg, mpegversion=(int)4, channels=(int)1, rate=(int)8000, base-profile=(string)lc, stream-format=(string)adts&quot;</div><div class="line"></div><div class="line"></div><div class="line">GstCaps *caps;</div><div class="line">caps = gst_caps_from_string(AUDIO_AAC_SENDER);</div><div class="line">g_object_set(G_OBJECT(data-&gt;sink), &quot;caps&quot;, caps, NULL);</div><div class="line">gst_caps_unref(caps);</div></pre></td></tr></table></figure></p>
<p>连接通道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;src, data-&gt;convert, data-&gt;encoder,</div><div class="line">	data-&gt;sink, NULL);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;src, data-&gt;convert, data-&gt;encoder, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link audio sender pipeline&quot;;</div></pre></td></tr></table></figure></p>
<p>连接encoder和sink时插入caps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GstCaps *caps_enc;</div><div class="line">caps_enc = gst_caps_from_string(AUDIO_AAC_SENDER);</div><div class="line">if (!gst_element_link_filtered(data-&gt;encoder, data-&gt;sink, caps_enc))</div><div class="line">	qDebug() &lt;&lt; &quot;Failed to link caps&quot;;</div><div class="line">gst_caps_unref(caps_enc);</div></pre></td></tr></table></figure></p>
<p>启动接口以及释放资源:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">AudioSender::~AudioSender()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_object_unref(data-&gt;pipeline);</div><div class="line">	g_free(data);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void AudioSender::run()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="TCP-接收播放音频流"><a href="#TCP-接收播放音频流" class="headerlink" title="TCP 接收播放音频流"></a>TCP 接收播放音频流</h1><p>继承QThread，头文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;QThread&gt;</div><div class="line">#include &lt;QDebug&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;winsock2.h&gt;</div><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &lt;gst/app/gstappsrc.h&gt;</div><div class="line">#include &lt;gst/app/gstappsink.h&gt;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GstElement *pipeline, *appsrc, *parse, *decoder, *conv, *sink;</div><div class="line">	SOCKET sock;</div><div class="line">&#125; AudioRecData;</div><div class="line"></div><div class="line">namespace Ui &#123;</div><div class="line">class AudioRec;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class AudioRec : public QThread</div><div class="line">&#123;</div><div class="line">    Q_OBJECT</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit AudioRec(SOCKET &amp;sk);</div><div class="line">    ~AudioRec();</div><div class="line"></div><div class="line">	void run();</div><div class="line">	void prepare_data();</div><div class="line"></div><div class="line">	static long cout_miss;</div><div class="line">	static long cout_rec;</div><div class="line"></div><div class="line">private:</div><div class="line">	AudioRecData *data;</div><div class="line">	int flag;</div><div class="line">	int last_number = -1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用元件:</p>
<ul>
<li>appsrc</li>
<li>aacparse</li>
<li>avdec_aac</li>
<li>audioconvert</li>
<li>autoaudiosink</li>
</ul>
<p>初始化元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">data-&gt;sock = sk;</div><div class="line">data-&gt;pipeline = gst_pipeline_new(&quot;audio_piprec&quot;);</div><div class="line">data-&gt;appsrc = gst_element_factory_make(&quot;appsrc&quot;, &quot;audio_srcrec&quot;);</div><div class="line">data-&gt;parse = gst_element_factory_make(&quot;aacparse&quot;, &quot;audio_parserec&quot;);</div><div class="line">data-&gt;decoder = gst_element_factory_make(&quot;avdec_aac&quot;, &quot;audio_decrec&quot;);</div><div class="line">data-&gt;conv = gst_element_factory_make(&quot;audioconvert&quot;, &quot;audio_convrec&quot;);</div><div class="line">data-&gt;sink = gst_element_factory_make(&quot;autoaudiosink&quot;, &quot;audio_sinkrec&quot;);</div></pre></td></tr></table></figure></p>
<p>设置appsrc的caps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define AUDIO_AAC_REC &quot;audio/mpeg, mpegversion=(int)4, channels=(int)1, rate=(int)8000, base-profile=(string)lc, stream-format=(string)adts&quot;</div><div class="line"></div><div class="line">GstCaps *caps;</div><div class="line">caps = gst_caps_from_string(AUDIO_AAC_REC);</div><div class="line">g_object_set(G_OBJECT(data-&gt;appsrc), &quot;caps&quot;, caps, NULL);</div><div class="line">gst_caps_unref(caps);</div></pre></td></tr></table></figure></p>
<p>设置block，以循环push的方式往通道传入参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g_object_set(data-&gt;appsrc,</div><div class="line">	&quot;format&quot;, GST_FORMAT_TIME,</div><div class="line">	&quot;block&quot;, TRUE,</div><div class="line">	NULL);</div></pre></td></tr></table></figure></p>
<p>设置sync参数，在丢包时通道不会卡住:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_object_set(G_OBJECT(data-&gt;sink), &quot;sync&quot;, FALSE, NULL);</div></pre></td></tr></table></figure></p>
<p>连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;appsrc, data-&gt;parse, data-&gt;decoder, data-&gt;conv, data-&gt;sink, NULL);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;appsrc, data-&gt;parse, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link audio receive pipeline&quot;;</div></pre></td></tr></table></figure></p>
<p>连接parse和decoder时指定caps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GstCaps *caps_dec;</div><div class="line">caps_dec = gst_caps_from_string(AUDIO_DEC_REC);</div><div class="line">if (!gst_element_link_filtered(data-&gt;parse, data-&gt;decoder, caps_dec))</div><div class="line">	qDebug() &lt;&lt; &quot;Failed to link caps&quot;;</div><div class="line">gst_caps_unref(caps_dec);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;decoder, data-&gt;conv, data-&gt;sink, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link audio receive pipeline&quot;;</div></pre></td></tr></table></figure></p>
<p>循环从tcp读取数据并传入通道:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">void AudioRec::prepare_data()</div><div class="line">&#123;</div><div class="line">	guint8 size_buffer[6];</div><div class="line">	gsize rec_size = 0;</div><div class="line">	gsize client_rec_size;</div><div class="line"></div><div class="line">	while (rec_size &lt; 6)</div><div class="line">	&#123;</div><div class="line">		client_rec_size = recv(data-&gt;sock, (char *)size_buffer + rec_size,</div><div class="line">			6 - rec_size, 0);</div><div class="line">		if (client_rec_size &gt; 6 || client_rec_size == SOCKET_ERROR)</div><div class="line">		&#123;</div><div class="line">			flag = 0;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		rec_size += client_rec_size;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	gsize total_size;</div><div class="line">	total_size = size_buffer[0]</div><div class="line">		+ (size_buffer[1] &lt;&lt; 8)</div><div class="line">		+ (size_buffer[2] &lt;&lt; 16)</div><div class="line">		+ (size_buffer[3] &lt;&lt; 24);</div><div class="line"></div><div class="line">	gsize map_size;</div><div class="line">	map_size = total_size - 2;</div><div class="line"></div><div class="line">	//qDebug() &lt;&lt; &quot;audio recive size: &quot; &lt;&lt; total_size;</div><div class="line"></div><div class="line">	if (map_size &gt; USHRT_MAX || total_size &lt; 2)</div><div class="line">	&#123;</div><div class="line">		qDebug() &lt;&lt; &quot;audio size is not valid&quot;;</div><div class="line">		flag = 0;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	char *frame_buffer = (char *)g_malloc(map_size * sizeof(char));</div><div class="line"></div><div class="line">	rec_size = 0;</div><div class="line">	while (rec_size &lt; map_size)</div><div class="line">	&#123;</div><div class="line">		client_rec_size = recv(data-&gt;sock, &amp;frame_buffer[rec_size],</div><div class="line">			map_size - rec_size, 0);</div><div class="line">		if (client_rec_size &gt; map_size || client_rec_size == SOCKET_ERROR)</div><div class="line">		&#123;</div><div class="line">			flag = 0;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		rec_size += client_rec_size;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	GstBuffer *buffer;</div><div class="line">	buffer = gst_buffer_new_wrapped((gpointer)(frame_buffer), map_size * sizeof(char));</div><div class="line"></div><div class="line">	gst_app_src_push_buffer(GST_APP_SRC(data-&gt;appsrc), buffer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void AudioRec::run()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">	flag = 1;</div><div class="line">	while (flag)</div><div class="line">	&#123;</div><div class="line">		prepare_data();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="TCP-发送视频流"><a href="#TCP-发送视频流" class="headerlink" title="TCP 发送视频流"></a>TCP 发送视频流</h1><p>头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;QThread&gt;</div><div class="line">#include &lt;QDebug&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;winsock2.h&gt;</div><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &lt;gst/app/gstappsrc.h&gt;</div><div class="line">#include &lt;gst/app/gstappsink.h&gt;</div><div class="line">#include &lt;gst/video/videooverlay.h&gt;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GMainLoop *loop;</div><div class="line">	GstElement *videosrc, *videorate, *videobox, *videotee, *sendqueue, *playqueue, </div><div class="line">		*sendconv, *encoder, *sendsink, *playsrc, *playconv, *playsink;</div><div class="line">	GstElement *pipeline;</div><div class="line">	SOCKET sock;</div><div class="line">	SOCKADDR_IN address;</div><div class="line">&#125; VideoSenderData;</div><div class="line"></div><div class="line"></div><div class="line">class VideoSender : public QThread</div><div class="line">&#123;</div><div class="line">    Q_OBJECT</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit VideoSender(SOCKET&amp; sk, QString host, QWidget* w);</div><div class="line">    ~VideoSender();</div><div class="line"></div><div class="line">    void run();</div><div class="line">	static GstFlowReturn</div><div class="line">		on_new_sample_from_sink(GstElement * elt, VideoSenderData * data);</div><div class="line">	static int32_t	bytes_count;</div><div class="line"></div><div class="line">private:</div><div class="line">	VideoSenderData *data;</div><div class="line"></div><div class="line">	QString phone_ip;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用到的元件:</p>
<ul>
<li>autovideosrc</li>
<li>videorate</li>
<li>videobox</li>
<li>tee</li>
<li>queue</li>
<li>videoconvert</li>
<li>openh264enc</li>
<li>appsink</li>
<li>d3dvideosink</li>
</ul>
<p>初始化元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">data-&gt;sock = sk;</div><div class="line">data-&gt;pipeline = gst_pipeline_new(&quot;pipeline_src_sender&quot;);</div><div class="line"></div><div class="line">data-&gt;videosrc = gst_element_factory_make(&quot;autovideosrc&quot;, &quot;source_sender&quot;);</div><div class="line">data-&gt;videorate = gst_element_factory_make(&quot;videorate&quot;, &quot;rate_sender&quot;);</div><div class="line">data-&gt;videobox = gst_element_factory_make(&quot;videobox&quot;, &quot;box_sender&quot;);</div><div class="line">data-&gt;videotee = gst_element_factory_make(&quot;tee&quot;, &quot;selfsink_sender&quot;);</div><div class="line"></div><div class="line">data-&gt;sendqueue = gst_element_factory_make(&quot;queue&quot;, &quot;sendqueue_sender&quot;);</div><div class="line">data-&gt;sendconv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;convert2_sender&quot;);</div><div class="line">data-&gt;encoder = gst_element_factory_make(&quot;openh264enc&quot;, &quot;encoder_sender&quot;);</div><div class="line">data-&gt;sendsink = gst_element_factory_make(&quot;appsink&quot;, &quot;appsink_sender&quot;);</div><div class="line"></div><div class="line">data-&gt;playqueue = gst_element_factory_make(&quot;queue&quot;, &quot;playqueue_sender&quot;);</div><div class="line">data-&gt;playconv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;convert3_sender&quot;);</div><div class="line">data-&gt;playsink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;d3d_sender&quot;);</div></pre></td></tr></table></figure></p>
<p>设置码率，根据码率选择不同的分辨率的caps，设置appsink的caps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#define VIDEO_CAPS_SENDER_480 &quot;video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, profile=(string)baseline, width=(int)360, height=(int)480, framerate=(fraction)30/1&quot;</div><div class="line"></div><div class="line">#define VIDEO_CAPS_SENDER_320 &quot;video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, profile=(string)baseline, width=(int)240, height=(int)320, framerate=(fraction)30/1&quot;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">if (bitrate &lt;= 128000)</div><div class="line">&#123;</div><div class="line">	caps = gst_caps_from_string(VIDEO_CAPS_SENDER_320);</div><div class="line">	bitrate *= 0.8;</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">	caps = gst_caps_from_string(VIDEO_CAPS_SENDER_480);</div><div class="line">&#125;</div><div class="line"></div><div class="line">g_object_set(G_OBJECT(data-&gt;encoder),</div><div class="line">	&quot;bitrate&quot;, bitrate,</div><div class="line">	&quot;rate-control&quot;, 1,</div><div class="line">	&quot;max-bitrate&quot;, bitrate,</div><div class="line">	&quot;enable-frame-skip&quot;, true,</div><div class="line">	NULL);</div><div class="line"></div><div class="line">g_object_set(G_OBJECT(data-&gt;sendsink), &quot;emit-signals&quot;, TRUE, &quot;sync&quot;, FALSE, NULL);</div><div class="line">g_object_set(G_OBJECT(data-&gt;sendsink), &quot;caps&quot;, caps, NULL);</div><div class="line">gst_caps_unref(caps);</div></pre></td></tr></table></figure></p>
<p>设置裁剪方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_object_set(G_OBJECT(data-&gt;videobox), &quot;autocrop&quot;, TRUE, NULL);</div></pre></td></tr></table></figure></p>
<p>定义回调函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">GstFlowReturn </div><div class="line">VideoSender::on_new_sample_from_sink(GstElement * elt, VideoSenderData * data)</div><div class="line">&#123;</div><div class="line">	GstSample *sample;</div><div class="line">	GstBuffer *buffer;</div><div class="line">	GstMapInfo map;</div><div class="line">	sample = gst_app_sink_pull_sample(GST_APP_SINK(elt));</div><div class="line">	if (!sample)</div><div class="line">		return GstFlowReturn(0);</div><div class="line">	buffer = gst_sample_get_buffer(sample);</div><div class="line">	gst_buffer_map(buffer, &amp;map, GST_MAP_READ);</div><div class="line">	gst_sample_unref(sample);</div><div class="line"></div><div class="line">	gsize map_size;</div><div class="line">	gsize total_size;</div><div class="line">	map_size = map.size;</div><div class="line">	total_size = map_size + 2;</div><div class="line"></div><div class="line">	guint8 size_buffer[6];</div><div class="line">	size_buffer[0] = total_size;</div><div class="line">	size_buffer[1] = total_size &gt;&gt; 8;</div><div class="line">	size_buffer[2] = total_size &gt;&gt; 16;</div><div class="line">	size_buffer[3] = total_size &gt;&gt; 24;</div><div class="line"></div><div class="line">	size_buffer[4] = 0;</div><div class="line">	size_buffer[5] = 0;</div><div class="line"></div><div class="line">	gsize send_size = 0;</div><div class="line">	gsize server_send;</div><div class="line">	while (send_size &lt; 6)</div><div class="line">	&#123;</div><div class="line">		server_send = send(data-&gt;sock, (char *)size_buffer + send_size,</div><div class="line">			6 - send_size, 0);</div><div class="line">		send_size += server_send;</div><div class="line">	&#125;</div><div class="line">	send_size = 0;</div><div class="line">	while (send_size &lt; map_size)</div><div class="line">	&#123;</div><div class="line">		server_send = send(data-&gt;sock, (char *)(map.data) + send_size,</div><div class="line">			map_size - send_size, 0);</div><div class="line">		send_size += server_send;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	gst_buffer_unmap(buffer, &amp;map);</div><div class="line"></div><div class="line">	return GstFlowReturn(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>appsink信号绑定回调:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g_signal_connect(data-&gt;sendsink, &quot;new-sample&quot;,</div><div class="line">	G_CALLBACK(on_new_sample_from_sink), data);</div></pre></td></tr></table></figure></p>
<p>视频源分成两路，一路通过appsink由TCP发送，一路通过播放元件预览:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GstPad *srcpad, *sinkpad;</div><div class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_0&quot;);</div><div class="line">sinkpad = gst_element_get_static_pad(data-&gt;sendqueue, &quot;sink&quot;);</div><div class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link tee and sendconv&quot;;</div><div class="line">gst_object_unref(srcpad);</div><div class="line">gst_object_unref(sinkpad);</div><div class="line"></div><div class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_1&quot;);</div><div class="line">sinkpad = gst_element_get_static_pad(data-&gt;playqueue, &quot;sink&quot;);</div><div class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link tee and playsink&quot;;</div><div class="line">gst_object_unref(srcpad);</div><div class="line">gst_object_unref(sinkpad);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;sendqueue, data-&gt;sendconv, data-&gt;encoder, data-&gt;sendsink, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link sender pipeline&quot;;</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;playqueue, data-&gt;playconv, data-&gt;playsink, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link sender pipeline&quot;;</div></pre></td></tr></table></figure></p>
<p>设置预览界面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WId d3d = w-&gt;winId();</div><div class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;playsink), d3d);</div></pre></td></tr></table></figure></p>
<p>析构函数释放资源，提供启动接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">VideoSender::~VideoSender()</div><div class="line">&#123;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_object_unref(data-&gt;pipeline);</div><div class="line">	g_free(data);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void VideoSender::run()</div><div class="line">&#123;</div><div class="line">	//gst_element_set_state(data-&gt;sendsink, GST_STATE_PLAYING);</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="TCP-接收视频流并显示"><a href="#TCP-接收视频流并显示" class="headerlink" title="TCP 接收视频流并显示"></a>TCP 接收视频流并显示</h1><p>头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &lt;QThread&gt;</div><div class="line">#include &lt;QDebug&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;winsock2.h&gt;</div><div class="line">#include &lt;QWidget&gt;</div><div class="line">#include &quot;gst/gst.h&quot;</div><div class="line">#include &lt;gst/app/gstappsrc.h&gt;</div><div class="line">#include &lt;gst/app/gstappsink.h&gt;</div><div class="line">#include &lt;gst/video/videooverlay.h&gt;</div><div class="line">#include &lt;gst/video/gstvideofilter.h&gt;</div><div class="line">#include &lt;gst/video/video.h&gt;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	GstElement *pipeline, *appsrc, *decoder, *videoflip, *conv, *videosink;</div><div class="line">	SOCKET sock;</div><div class="line">&#125; VideoRecData;</div><div class="line"></div><div class="line"></div><div class="line">class VideoRec : public QThread</div><div class="line">&#123;</div><div class="line">    Q_OBJECT</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit VideoRec(SOCKET &amp;sk, QWidget* w);</div><div class="line">    ~VideoRec();</div><div class="line"></div><div class="line">    void run();</div><div class="line">	void prepare_data();</div><div class="line">	void flip();</div><div class="line">	GstState get_state();</div><div class="line"></div><div class="line">	static long cout_miss;</div><div class="line">	static long cout_rec;</div><div class="line"></div><div class="line">private:</div><div class="line">	VideoRecData *data;</div><div class="line">	int flag;</div><div class="line">	int last_number = -1;</div><div class="line">	int rotate_index = 0;</div><div class="line">	std::vector&lt;const char*&gt; rotate&#123; &quot;none&quot;, &quot;clockwise&quot;, &quot;rotate-180&quot;, &quot;counterclockwise&quot; &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用到的元件:</p>
<ul>
<li>appsrc</li>
<li>openh264dec</li>
<li>videoflip</li>
<li>videoconvert</li>
<li>d3dvideosink</li>
</ul>
<p>初始化元件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">data-&gt;sock = sk;</div><div class="line">data-&gt;pipeline = gst_pipeline_new(&quot;video_pipeline_rec&quot;);</div><div class="line">data-&gt;appsrc = gst_element_factory_make(&quot;appsrc&quot;, &quot;video_srcrec&quot;);</div><div class="line">data-&gt;decoder = gst_element_factory_make(&quot;openh264dec&quot;, &quot;video_decrec&quot;);</div><div class="line">data-&gt;videoflip = gst_element_factory_make(&quot;videoflip&quot;, &quot;video_flip&quot;);</div><div class="line">data-&gt;conv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;video_convrec&quot;);</div><div class="line">data-&gt;videosink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;video_sinkrec&quot;);</div></pre></td></tr></table></figure></p>
<p>设置sync参数，否则丢包会导致播放失败:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_object_set(G_OBJECT(data-&gt;videosink), &quot;sync&quot;, FALSE, NULL);</div></pre></td></tr></table></figure></p>
<p>设置appsrc的caps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define VIDEO_CAPS_REC &quot;video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, profile=(string)baseline&quot;</div><div class="line"></div><div class="line"></div><div class="line">GstCaps *caps;</div><div class="line">caps = gst_caps_from_string(VIDEO_CAPS_REC);</div><div class="line">g_object_set(G_OBJECT(data-&gt;appsrc), &quot;caps&quot;, caps, NULL);</div><div class="line">gst_caps_unref(caps);</div></pre></td></tr></table></figure></p>
<p>appsink的blok属性设为true，以循环push的方式读取数据并传入通道:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g_object_set(data-&gt;appsrc,</div><div class="line">	&quot;format&quot;, GST_FORMAT_TIME,</div><div class="line">	&quot;blok&quot;, TRUE,</div><div class="line">	NULL);</div></pre></td></tr></table></figure></p>
<p>连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;appsrc,</div><div class="line">	data-&gt;decoder, data-&gt;videoflip, data-&gt;conv, data-&gt;videosink, NULL);</div><div class="line"></div><div class="line">if (!gst_element_link_many(data-&gt;appsrc, data-&gt;decoder, data-&gt;videoflip, data-&gt;conv, data-&gt;videosink, NULL))</div><div class="line">	qDebug() &lt;&lt; &quot;fail to link video receiver&quot;;</div></pre></td></tr></table></figure></p>
<p>设置界面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WId d3d = w-&gt;winId();</div><div class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;videosink), d3d);</div></pre></td></tr></table></figure></p>
<p>通过设置videoflip的属性实现旋转图像，各个角度的属性在头文件定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void VideoRec::flip()</div><div class="line">&#123;</div><div class="line">	rotate_index += 1;</div><div class="line">	rotate_index %= 4;</div><div class="line">	gst_util_set_object_arg(G_OBJECT(data-&gt;videoflip), &quot;method&quot;, rotate[rotate_index]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>循环读取数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">void VideoRec::prepare_data()</div><div class="line">&#123;</div><div class="line">	guint8 size_buffer[6];</div><div class="line">	gsize rec_size = 0;</div><div class="line">	gsize client_rec_size;</div><div class="line"></div><div class="line">	while (rec_size &lt; 6)</div><div class="line">	&#123;</div><div class="line">		client_rec_size = recv(data-&gt;sock, (char *)size_buffer + rec_size,</div><div class="line">			6 - rec_size, 0);</div><div class="line">		if (client_rec_size &gt; 6 || client_rec_size == SOCKET_ERROR)</div><div class="line">		&#123;</div><div class="line">			flag = 0;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		rec_size += client_rec_size;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	gsize total_size;</div><div class="line">	total_size = size_buffer[0]</div><div class="line">		+ (size_buffer[1] &lt;&lt; 8)</div><div class="line">		+ (size_buffer[2] &lt;&lt; 16)</div><div class="line">		+ (size_buffer[3] &lt;&lt; 24);</div><div class="line"></div><div class="line">	gsize map_size;</div><div class="line">	map_size = total_size - 2;</div><div class="line"></div><div class="line">	//qDebug() &lt;&lt; &quot;video recive size: &quot; &lt;&lt; total_size;</div><div class="line"></div><div class="line">	if (map_size &gt; USHRT_MAX || total_size &lt; 2)</div><div class="line">	&#123;</div><div class="line">		qDebug() &lt;&lt; &quot;video size is not valid&quot;;</div><div class="line">		flag = 0;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	char *frame_buffer = (char *)g_malloc(map_size * sizeof(char));</div><div class="line"></div><div class="line">	rec_size = 0;</div><div class="line">	while (rec_size &lt; map_size)</div><div class="line">	&#123;</div><div class="line">		client_rec_size = recv(data-&gt;sock, &amp;frame_buffer[rec_size],</div><div class="line">			map_size - rec_size, 0);</div><div class="line">		if (client_rec_size &gt; map_size || client_rec_size == SOCKET_ERROR)</div><div class="line">		&#123;</div><div class="line">			flag = 0;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		rec_size += client_rec_size;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	GstBuffer *buffer;</div><div class="line">	buffer = gst_buffer_new_wrapped((gpointer)(frame_buffer), map_size * sizeof(char));</div><div class="line"></div><div class="line">	gst_app_src_push_buffer(GST_APP_SRC(data-&gt;appsrc), buffer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void VideoRec::run()</div><div class="line">&#123;</div><div class="line">	//gst_element_set_state(data-&gt;appsrc, GST_STATE_PLAYING);</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</div><div class="line">	flag = 1;</div><div class="line">	while (flag)</div><div class="line">	&#123;</div><div class="line">		prepare_data();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>析构函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">VideoRec::~VideoRec()</div><div class="line">&#123;</div><div class="line">	flag = 0;</div><div class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</div><div class="line">	g_object_unref(data-&gt;pipeline);</div><div class="line">	g_free(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-02</span><i class="fa fa-tag"></i><a href="/tags/gstreamer/" title="gstreamer" class="tag">gstreamer </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2018/02/02/Note/gstreamer/demo/,Harryx,gstreamer example,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2018/02/03/Note/tools/cmake/" title="cmake" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2018/01/27/Note/python/library/basic/functools/" title="functools" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
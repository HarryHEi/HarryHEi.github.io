<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>gstreamer example · Harryx</title><meta name="description" content="播放一个amr的音频文件头文件如下:
12345678910111213141516171819202122232425262728#include &amp;quot;gst/gst.h&amp;quot;#include &amp;lt;thread&amp;gt;typedef struct&amp;#123;	GMainLoop "><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Harryx</a></h3><div class="description"><p>good good study good good play~</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/harryx520"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/Booooyakasha"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备19072417号-1</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/avator.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>gstreamer example</a></h3></div><div class="post-content"><h1 id="播放一个amr的音频文件"><a href="#播放一个amr的音频文件" class="headerlink" title="播放一个amr的音频文件"></a>播放一个amr的音频文件</h1><p>头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GMainLoop *loop;</span><br><span class="line">	GstElement *pipeline;</span><br><span class="line">	GstElement *filesrc, *audioparse, *audiodec, *audioconvert, *audiosink;</span><br><span class="line">&#125;AudioPlayerData;</span><br><span class="line"></span><br><span class="line">class AudioPlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit AudioPlayer(QString path);</span><br><span class="line">	~AudioPlayer();</span><br><span class="line"></span><br><span class="line">	void start();</span><br><span class="line">	void stop();</span><br><span class="line">	bool is_running();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void run();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	AudioPlayerData *data;</span><br><span class="line"></span><br><span class="line">	std::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>播放amr音频文件需要用到以下元件:</p>
<ul>
<li>filesrc</li>
<li>amrparse</li>
<li>amrnbdec</li>
<li>audioconvert</li>
<li>autoaudiosink</li>
</ul>
<p>因为需要监听播放完成事件，所以创建一个mainloop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;loop = g_main_loop_new(NULL, FALSE);</span><br></pre></td></tr></table></figure>

<p>创建各个元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;pipeline = gst_pipeline_new(&quot;audio_player&quot;);</span><br><span class="line">data-&gt;filesrc = gst_element_factory_make(&quot;filesrc&quot;, &quot;audio_player_filesrc&quot;);</span><br><span class="line">data-&gt;audioparse = gst_element_factory_make(&quot;amrparse&quot;, &quot;audio_player_parse&quot;);</span><br><span class="line">data-&gt;audiodec = gst_element_factory_make(&quot;amrnbdec&quot;, &quot;audio_player_dec&quot;);</span><br><span class="line">data-&gt;audioconvert = gst_element_factory_make(&quot;audioconvert&quot;, &quot;audio_player_convert&quot;);</span><br><span class="line">data-&gt;audiosink = gst_element_factory_make(&quot;autoaudiosink&quot;, &quot;audio_player_sink&quot;);</span><br></pre></td></tr></table></figure>

<p>指定一下filesrc文件路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(data-&gt;filesrc,</span><br><span class="line">	&quot;location&quot;, path.toStdString().c_str(),</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>

<p>从pipeline中获取一个GstBus对象，然后设置监听并绑定一个回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(data-&gt;pipeline));</span><br><span class="line">gst_bus_add_watch(bus, call_back, data);</span><br><span class="line">gst_object_unref(bus);</span><br></pre></td></tr></table></figure>

<p>定义一个回调函数， 当获取到播放完成或错误事件的时候关闭通道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static gboolean call_back(GstBus *, GstMessage *msg, gpointer data)</span><br><span class="line">&#123;</span><br><span class="line">	switch (GST_MESSAGE_TYPE(msg))</span><br><span class="line">	&#123;</span><br><span class="line">		case GST_MESSAGE_EOS:</span><br><span class="line">		case GST_MESSAGE_ERROR:</span><br><span class="line">			gst_element_set_state(static_cast&lt;AudioPlayerData*&gt;(data)-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将元件添加到pipeline并连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;filesrc, data-&gt;audioparse,</span><br><span class="line">	data-&gt;audiodec, data-&gt;audioconvert, data-&gt;audiosink, NULL);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;filesrc, data-&gt;audioparse, data-&gt;audiodec, data-&gt;audioconvert, data-&gt;audiosink, NULL))</span><br><span class="line">&#123;</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link audio player&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供一些简单的接口，用于查询控制播放，这里用一个单独的线程跑loop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void AudioPlayer::start()</span><br><span class="line">&#123;</span><br><span class="line">	t = std::thread(&amp;AudioPlayer::run, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioPlayer::stop()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_main_loop_quit(data-&gt;loop);</span><br><span class="line">	if (t.joinable())</span><br><span class="line">		t.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool AudioPlayer::is_running()</span><br><span class="line">&#123;</span><br><span class="line">	GstState state;</span><br><span class="line">	gst_element_get_state(data-&gt;pipeline, &amp;state, NULL, GstClockTime(1000000));</span><br><span class="line">	return state == GST_STATE_PLAYING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioPlayer::run()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">	g_main_loop_run(data-&gt;loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构的时候关闭通道释放资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AudioPlayer::~AudioPlayer()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_main_loop_quit(data-&gt;loop);</span><br><span class="line">	if(t.joinable())</span><br><span class="line">		t.join();</span><br><span class="line">	g_object_unref(data-&gt;pipeline);</span><br><span class="line">	g_free(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="生成一个amr音频文件"><a href="#生成一个amr音频文件" class="headerlink" title="生成一个amr音频文件"></a>生成一个amr音频文件</h1><p>头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GstElement *pipeline;</span><br><span class="line">	GstElement *audiosrc, *audioconv, *audioenc, *filesink;</span><br><span class="line">&#125;ShortAudioData;</span><br><span class="line"></span><br><span class="line">class ShortAudio</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit ShortAudio(QString path);</span><br><span class="line">	~ShortAudio();</span><br><span class="line"></span><br><span class="line">	void start();</span><br><span class="line">	void stop();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	ShortAudioData *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>生成amr用到以下元件:</p>
<ul>
<li>autoaudiosrc</li>
<li>audioconvert</li>
<li>amrnbenc</li>
<li>filesink</li>
</ul>
<p>生成的amr文件是不能直接播放的，需要添加头:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char header[6] = &#123; 0x23, 0x21, 0x41, 0x4d, 0x52, 0x0a&#125;;</span><br><span class="line">std::ofstream of(path.toStdString(), std::ofstream::binary);</span><br><span class="line">of.write(header, 6);</span><br></pre></td></tr></table></figure>

<p>设置码率和模式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(data-&gt;audioenc, </span><br><span class="line">	&quot;target&quot;, &quot;bitrate&quot;,</span><br><span class="line">	&quot;bitrate&quot;, 192,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>

<p>设置文件路径，因为已经输入了头，所以指定以append的方式添加数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(data-&gt;filesink,</span><br><span class="line">	&quot;append&quot;, true,</span><br><span class="line">	&quot;location&quot;, path.toStdString().c_str(),</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>

<p>连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;audiosrc, data-&gt;audioconv,</span><br><span class="line">	data-&gt;audioenc, data-&gt;filesink);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;audiosrc, data-&gt;audioconv, data-&gt;audioenc, data-&gt;filesink, NULL))</span><br><span class="line">&#123;</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link short video&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供简单的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ShortAudio::start()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShortAudio::stop()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构的时候释放资源:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ShortAudio::~ShortAudio()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_object_unref(data-&gt;pipeline);</span><br><span class="line">	g_free(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="预览并录制保存mp4-视频"><a href="#预览并录制保存mp4-视频" class="headerlink" title="预览并录制保存mp4 视频"></a>预览并录制保存mp4 视频</h1><p>头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &lt;gst/video/videooverlay.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GstElement *pipeline_view, *view_src, *view_sink;</span><br><span class="line">	GstElement *pipeline;</span><br><span class="line">	GstElement *videosrc, *videorate, *videoconvert, *encqueue, *videoenc, *videodec, *videoparse;</span><br><span class="line">	GstElement *videotee, *sinkqueue, *videosinkconv, *videosink;</span><br><span class="line">	GstElement *audiosrc, *audiorate, *audioconvert, *audioenc;</span><br><span class="line">	GstElement *muxer, *filesink, *fakesink;</span><br><span class="line">&#125;ShortVideoData;</span><br><span class="line"></span><br><span class="line">class ShortVideo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit ShortVideo(QString path, QWidget *window);</span><br><span class="line">	~ShortVideo();</span><br><span class="line"></span><br><span class="line">	void start();</span><br><span class="line">	void stop();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	ShortVideoData *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先建立一个用于预览的通道，直接连接视频源和播放器，因为需要指定播放器播放的界面，所以这里用d3dvideosink作为播放元件，后面会指定界面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;pipeline_view = gst_pipeline_new(&quot;video_view&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;view_src = gst_element_factory_make(&quot;autovideosrc&quot;, &quot;view_src&quot;);</span><br><span class="line">data-&gt;view_sink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;view_sink&quot;);</span><br><span class="line"></span><br><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline_view), data-&gt;view_src, data-&gt;view_sink, NULL);</span><br><span class="line">if (!gst_element_link_many(data-&gt;view_src, data-&gt;view_sink, NULL))</span><br><span class="line">&#123;</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link view&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>录制通道视频源需要分成两路，一路用于预览，一路用于生成视频文件，需要注意的是如果直接把数据源分两路，会使通道卡死，原因未知，所以先编码成h264然后用tee元件分成两路:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;videosrc = gst_element_factory_make(&quot;autovideosrc&quot;, &quot;shortvideo_src&quot;);</span><br><span class="line">data-&gt;videoconvert = gst_element_factory_make(&quot;videoconvert&quot;, &quot;shortvideo_conv2&quot;);</span><br><span class="line">data-&gt;videoenc = gst_element_factory_make(&quot;openh264enc&quot;, &quot;shortvideo_enc&quot;);</span><br><span class="line">data-&gt;videoparse = gst_element_factory_make(&quot;h264parse&quot;, &quot;shortvideo_parse&quot;);</span><br><span class="line">data-&gt;videotee = gst_element_factory_make(&quot;tee&quot;, &quot;shortvideo_tee&quot;);</span><br></pre></td></tr></table></figure>

<p>建立预览通道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;sinkqueue = gst_element_factory_make(&quot;queue&quot;, &quot;shortvideo_sinkqueue&quot;);</span><br><span class="line">data-&gt;videodec = gst_element_factory_make(&quot;avdec_h264&quot;, &quot;shortvideo_decodebin&quot;);</span><br><span class="line">data-&gt;videosink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;shortvideo_sink&quot;);</span><br></pre></td></tr></table></figure>

<p>编码通道需要使用mp4mux与音频混合成mp4视频文件，音频使用的是voaacenc元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;audiosrc = gst_element_factory_make(&quot;autoaudiosrc&quot;, &quot;shortaudio_src&quot;);</span><br><span class="line">data-&gt;audiorate = gst_element_factory_make(&quot;audiorate&quot;, &quot;shortaudio_rate&quot;);</span><br><span class="line">data-&gt;audioconvert = gst_element_factory_make(&quot;audioconvert&quot;, &quot;shortaudio_conv&quot;);</span><br><span class="line">data-&gt;audioenc = gst_element_factory_make(&quot;voaacenc&quot;, &quot;shortaudio_enc&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;muxer = gst_element_factory_make(&quot;mp4mux&quot;, &quot;short_mm&quot;);</span><br><span class="line">data-&gt;filesink = gst_element_factory_make(&quot;filesink&quot;, &quot;short_fs&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;fakesink = gst_element_factory_make(&quot;fakesink&quot;, &quot;short_video_fakesink&quot;);</span><br></pre></td></tr></table></figure>

<p>设置文件路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(data-&gt;filesink, &quot;location&quot;, path.toStdString().c_str(), NULL);</span><br></pre></td></tr></table></figure>

<p>将录制通道所有元件添加到pipeline:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;videosrc, data-&gt;videoconvert, data-&gt;videoenc, data-&gt;videoparse,</span><br><span class="line">	data-&gt;videotee, data-&gt;sinkqueue, data-&gt;videodec, data-&gt;videosink, data-&gt;encqueue,</span><br><span class="line">	data-&gt;audiosrc, data-&gt;audiorate, data-&gt;audioconvert, data-&gt;audioenc, data-&gt;muxer, data-&gt;filesink, NULL);</span><br></pre></td></tr></table></figure>

<p>连接视频源通道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!gst_element_link_many(data-&gt;videosrc, data-&gt;videoconvert, data-&gt;videoenc, data-&gt;videoparse, data-&gt;videotee, NULL))</span><br><span class="line">&#123;</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link video&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接预览通道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GstPad *srcpad, *sinkpad;</span><br><span class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_0&quot;);</span><br><span class="line">sinkpad = gst_element_get_static_pad(data-&gt;sinkqueue, &quot;sink&quot;);</span><br><span class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link tee and sendconv&quot;;</span><br><span class="line">gst_object_unref(srcpad);</span><br><span class="line">gst_object_unref(sinkpad);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;sinkqueue, data-&gt;videodec, data-&gt;videosink, NULL))</span><br><span class="line">&#123;</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link video&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接录制通道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_1&quot;);</span><br><span class="line">sinkpad = gst_element_get_static_pad(data-&gt;encqueue, &quot;sink&quot;);</span><br><span class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link tee and playsink&quot;;</span><br><span class="line">gst_object_unref(srcpad);</span><br><span class="line">gst_object_unref(sinkpad);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;audiosrc, data-&gt;audiorate, data-&gt;audioconvert, data-&gt;audioenc, NULL))</span><br><span class="line">&#123;</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link audio&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将视频和音频混合:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">srcpad = gst_element_get_static_pad(data-&gt;encqueue, &quot;src&quot;);</span><br><span class="line">sinkpad = gst_element_get_request_pad(data-&gt;muxer, &quot;video_0&quot;);</span><br><span class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link video and muxer&quot;;</span><br><span class="line">gst_object_unref(srcpad);</span><br><span class="line">gst_object_unref(sinkpad);</span><br><span class="line"></span><br><span class="line">srcpad = gst_element_get_static_pad(data-&gt;audioenc, &quot;src&quot;);</span><br><span class="line">sinkpad = gst_element_get_request_pad(data-&gt;muxer, &quot;audio_0&quot;);</span><br><span class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link audio and muxer&quot;;</span><br><span class="line">gst_object_unref(srcpad);</span><br><span class="line">gst_object_unref(sinkpad);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;muxer, data-&gt;filesink, NULL))</span><br><span class="line">&#123;</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link file&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置界面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WId d3d = window-&gt;winId();</span><br><span class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;videosink), d3d);</span><br><span class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;view_sink), d3d);</span><br></pre></td></tr></table></figure>

<p>启动预览:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst_element_set_state(data-&gt;pipeline_view, GST_STATE_PLAYING);</span><br></pre></td></tr></table></figure>

<p>播放时关闭预览，开启录制，注意需要在结束后给出一个结束信号，并且稍微延时，不然文件不能播放，停止时全部关闭:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void ShortVideo::start()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline_view, GST_STATE_NULL);</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShortVideo::stop()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline_view, GST_STATE_NULL);</span><br><span class="line">	gst_element_send_event(data-&gt;pipeline, gst_event_new_eos());</span><br><span class="line">	_sleep(1000);</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放资源:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ShortVideo::~ShortVideo()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline_view, GST_STATE_NULL);</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_object_unref(data-&gt;pipeline);</span><br><span class="line">	g_object_unref(data-&gt;pipeline_view);</span><br><span class="line">	g_free(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="取MP4视频的其中一帧图像并保存"><a href="#取MP4视频的其中一帧图像并保存" class="headerlink" title="取MP4视频的其中一帧图像并保存"></a>取MP4视频的其中一帧图像并保存</h1><p>头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QImage&gt;</span><br><span class="line">#include &lt;QString&gt;</span><br><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &lt;gst/app/gstappsink.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	std::string video_view_path;</span><br><span class="line">	GstElement *pipeline;</span><br><span class="line">	GstElement *filesrc, *qtdemux, *queue, *videodec, *videobox, *videoconv, *appsink;</span><br><span class="line">&#125;VideoImageViewData;</span><br><span class="line"></span><br><span class="line">class VideoImageView</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit VideoImageView(QString path);</span><br><span class="line">	~VideoImageView();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	static void new_video_sample_pad(GstElement *element, GstPad *pad, gpointer data);</span><br><span class="line">	static GstFlowReturn new_image_from_appsink(GstElement * elt, VideoImageViewData * data);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	VideoImageViewData *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用到如下元件:</p>
<ul>
<li>filesrc</li>
<li>qtdemux</li>
<li>queue</li>
<li>avdec_h264</li>
<li>videobox</li>
<li>videoconvert</li>
<li>appesink</li>
</ul>
<p>初始化元件，设置图片保存路径以及视频源路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;video_view_path = (path + &quot;.jpg&quot;).toStdString();</span><br><span class="line">data-&gt;pipeline = gst_pipeline_new(&quot;video_sample&quot;);</span><br><span class="line">data-&gt;filesrc = gst_element_factory_make(&quot;filesrc&quot;, &quot;video_sample_file_src&quot;);</span><br><span class="line">data-&gt;qtdemux = gst_element_factory_make(&quot;qtdemux&quot;, &quot;video_sample_demux&quot;);</span><br><span class="line">data-&gt;queue = gst_element_factory_make(&quot;queue&quot;, &quot;video_sample_queue&quot;);</span><br><span class="line">data-&gt;videodec = gst_element_factory_make(&quot;avdec_h264&quot;, &quot;video_sample_videodec&quot;);</span><br><span class="line">data-&gt;videobox = gst_element_factory_make(&quot;videobox&quot;, &quot;video_sample_videobox&quot;);</span><br><span class="line">data-&gt;videoconv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;video_sample_conv&quot;);</span><br><span class="line">data-&gt;appsink = gst_element_factory_make(&quot;appsink&quot;, &quot;video_sample_appsink&quot;);</span><br><span class="line">g_object_set(data-&gt;filesrc,</span><br><span class="line">	&quot;location&quot;, path.toStdString().c_str(),</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>

<p>对视频进行裁剪:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(G_OBJECT(data-&gt;videobox), &quot;autocrop&quot;, TRUE, NULL);</span><br></pre></td></tr></table></figure>

<p>定义appsink的caps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define VIDEO_SAMPLE_CONV_CAPS &quot;video/x-raw, format=(string)RGB16, width=(int)120, height=(int)160&quot;</span><br></pre></td></tr></table></figure>

<p>设置appsink的caps以及数据获取方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GstCaps *convert_caps;</span><br><span class="line">convert_caps = gst_caps_from_string(VIDEO_SAMPLE_CONV_CAPS);</span><br><span class="line">g_object_set(G_OBJECT(data-&gt;appsink), &quot;emit-signals&quot;, TRUE, &quot;sync&quot;, FALSE, NULL);</span><br><span class="line">g_object_set(G_OBJECT(data-&gt;videoconv), &quot;caps&quot;, convert_caps, NULL);</span><br><span class="line">g_object_set(G_OBJECT(data-&gt;appsink), &quot;caps&quot;, convert_caps, NULL);</span><br><span class="line">gst_caps_unref(convert_caps);</span><br></pre></td></tr></table></figure>

<p>分别连接源和视频处理通道，qtdemux需要以回调的方式连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!gst_element_link_many(data-&gt;filesrc, data-&gt;qtdemux, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link filesrc qtdemux&quot;;</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;queue, data-&gt;videodec, data-&gt;videobox, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link queue videodec videobox&quot;;</span><br></pre></td></tr></table></figure>

<p>定义videobox和videoconvert之间的caps，连接后面的元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GstCaps *caps_box;</span><br><span class="line">caps_box = gst_caps_from_string(VIDEO_SAMPLE_BOX_CAPS);</span><br><span class="line">if (!gst_element_link_filtered(data-&gt;videobox, data-&gt;videoconv, caps_box))</span><br><span class="line">	qDebug() &lt;&lt; &quot;Failed to link caps&quot;;</span><br><span class="line">gst_caps_unref(caps_box);</span><br><span class="line">if (!gst_element_link_many(data-&gt;videoconv, data-&gt;appsink, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link videoconv appsink&quot;;</span><br></pre></td></tr></table></figure>

<p>定义qtdemux连接回调，因为只需要视频，当出现新连接，如果是视频sink则进行连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void VideoImageView::new_video_sample_pad(GstElement *, GstPad *pad, gpointer data)</span><br><span class="line">&#123;</span><br><span class="line">	GstPad *sinkpad;</span><br><span class="line">	sinkpad = gst_element_get_static_pad(static_cast&lt;VideoImageViewData*&gt;(data)-&gt;queue, &quot;sink&quot;);</span><br><span class="line">	if (gst_pad_link(pad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">		qDebug() &lt;&lt; &quot;fail to link qtdemux and videodec&quot;;</span><br><span class="line">	gst_object_unref(sinkpad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定pad-added信号和回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(data-&gt;qtdemux, &quot;pad-added&quot;, G_CALLBACK(new_video_sample_pad), data);</span><br></pre></td></tr></table></figure>

<p>定义appsink数据回调，当有新数据时，保存为图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GstFlowReturn</span><br><span class="line">VideoImageView::new_image_from_appsink(GstElement * elt, VideoImageViewData * data)</span><br><span class="line">&#123;</span><br><span class="line">	GstSample *sample;</span><br><span class="line">	GstBuffer *buffer;</span><br><span class="line">	GstMapInfo map;</span><br><span class="line">	sample = gst_app_sink_pull_sample(GST_APP_SINK(elt));</span><br><span class="line">	if (!sample)</span><br><span class="line">		return GstFlowReturn(0);</span><br><span class="line">	buffer = gst_sample_get_buffer(sample);</span><br><span class="line">	gst_buffer_map(buffer, &amp;map, GST_MAP_READ);</span><br><span class="line">	gst_sample_unref(sample);</span><br><span class="line"></span><br><span class="line">	QImage image = QImage(map.data, VIDEO_SAMPLE_WIDTH, VIDEO_SAMPLE_HEIGHT, QImage::Format_RGB16);</span><br><span class="line">	image.save(QString((data-&gt;video_view_path).c_str()), &quot;JPG&quot;);</span><br><span class="line"></span><br><span class="line">	gst_buffer_unmap(buffer, &amp;map);</span><br><span class="line"></span><br><span class="line">	return GstFlowReturn(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定appsin的信号和回调函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(data-&gt;qtdemux, &quot;pad-added&quot;, G_CALLBACK(new_video_sample_pad), data);</span><br><span class="line">g_signal_connect(data-&gt;appsink, &quot;new-sample&quot;, G_CALLBACK(new_image_from_appsink), data);</span><br></pre></td></tr></table></figure>

<p>直接启动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br></pre></td></tr></table></figure>

<p>析构时停止:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VideoImageView::~VideoImageView()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_object_unref(data-&gt;pipeline);</span><br><span class="line">	g_free(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="播放一个mp4文件"><a href="#播放一个mp4文件" class="headerlink" title="播放一个mp4文件"></a>播放一个mp4文件</h1><p>头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QDir&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &lt;gst/video/videooverlay.h&gt;</span><br><span class="line">#include &lt;gst/app/gstappsrc.h&gt;</span><br><span class="line">#include &lt;gst/app/gstappsink.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GMainLoop *loop;</span><br><span class="line">	GstElement *playbin, *videosink;</span><br><span class="line">	GstElement *pipeline;</span><br><span class="line">	GstElement *filesrc, *qtdemux;</span><br><span class="line">	GstElement *video_queue, *video_dec, *video_flip, *video_conv, *video_sink;</span><br><span class="line">	GstElement *audio_queue, *audio_dec, *audio_conv, *audio_sink;</span><br><span class="line">&#125;VideoPlayerData;</span><br><span class="line"></span><br><span class="line">class VideoPlayer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit VideoPlayer(QString path, QWidget* widget);</span><br><span class="line">	~VideoPlayer();</span><br><span class="line"></span><br><span class="line">	void start();</span><br><span class="line">	void stop();</span><br><span class="line">	bool is_running();</span><br><span class="line">	gint64 get_pos();</span><br><span class="line">	gint64 get_dur();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void run();</span><br><span class="line">	static gboolean call_back(GstBus *, GstMessage *msg, gpointer data);</span><br><span class="line">	static void new_player_pad(GstElement *, GstPad *pad, gpointer data);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	VideoPlayerData *data;</span><br><span class="line">	std::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要用到的元件:</p>
<ul>
<li>filesrc</li>
<li>qtdemux</li>
<li>queue</li>
<li>avdec_h264</li>
<li>videoflip</li>
<li>videoconvert</li>
<li>d3dvideosink</li>
<li>queue</li>
<li>avdec_aac</li>
<li>audioconvert</li>
<li>autoaudiosink</li>
</ul>
<p>初始化元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;loop = g_main_loop_new(NULL, FALSE);</span><br><span class="line"></span><br><span class="line">data-&gt;pipeline = gst_pipeline_new(&quot;player_pipeline&quot;);</span><br><span class="line">data-&gt;filesrc = gst_element_factory_make(&quot;filesrc&quot;, &quot;player_filesrc&quot;);</span><br><span class="line">data-&gt;qtdemux = gst_element_factory_make(&quot;qtdemux&quot;, &quot;player_qtdemux&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;video_queue = gst_element_factory_make(&quot;queue&quot;, &quot;player_video_queue&quot;);</span><br><span class="line">data-&gt;video_dec = gst_element_factory_make(&quot;avdec_h264&quot;, &quot;player_video_dec&quot;);</span><br><span class="line">data-&gt;video_flip = gst_element_factory_make(&quot;videoflip&quot;, &quot;player_video_flip&quot;);</span><br><span class="line">data-&gt;video_conv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;player_video_convert&quot;);</span><br><span class="line">data-&gt;video_sink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;player_video_sink&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;audio_queue = gst_element_factory_make(&quot;queue&quot;, &quot;player_audio_queue&quot;);</span><br><span class="line">data-&gt;audio_dec = gst_element_factory_make(&quot;avdec_aac&quot;, &quot;player_audio_dec&quot;);</span><br><span class="line">data-&gt;audio_conv = gst_element_factory_make(&quot;audioconvert&quot;, &quot;player_audio_conv&quot;);</span><br><span class="line">data-&gt;audio_sink = gst_element_factory_make(&quot;autoaudiosink&quot;, &quot;player_audio_sink&quot;);</span><br></pre></td></tr></table></figure>

<p>这里使用了mainloop，但应该是不需要的，因为并没有需要检测停止信号。</p>
<p>设置文件路径，设置视频自动旋转，这样videoflip会自动检测视频是否需要旋转，并进行旋转操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(data-&gt;filesrc, &quot;location&quot;, path.toStdString().c_str(), NULL);</span><br><span class="line">g_object_set(data-&gt;video_flip, &quot;method&quot;, 8, NULL);</span><br></pre></td></tr></table></figure>

<p>qtdemux需要用信号的方式连接，因此先连接几个通道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;filesrc, data-&gt;qtdemux, </span><br><span class="line">	data-&gt;video_queue, data-&gt;video_dec, data-&gt;video_flip, data-&gt;video_conv, data-&gt;video_sink,</span><br><span class="line">	data-&gt;audio_queue, data-&gt;audio_dec, data-&gt;audio_conv, data-&gt;audio_sink, NULL);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;filesrc, data-&gt;qtdemux, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link filesrc qtdemux&quot;;</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;video_queue, data-&gt;video_dec, data-&gt;video_flip, </span><br><span class="line">	data-&gt;video_conv, data-&gt;video_sink, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link player video queue&quot;;</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;audio_queue, data-&gt;audio_dec, data-&gt;audio_conv,</span><br><span class="line">	data-&gt;audio_sink, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link player audio queue&quot;;</span><br></pre></td></tr></table></figure>

<p>定义qtdemux的连接回调函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void VideoPlayer::new_player_pad(GstElement *, GstPad *pad, gpointer data)</span><br><span class="line">&#123;</span><br><span class="line">	auto name = gst_object_get_name(GST_OBJECT_CAST(pad));</span><br><span class="line"></span><br><span class="line">	if (QString(static_cast&lt;char*&gt;(name)) == &quot;video_0&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		GstPad *sinkpad;</span><br><span class="line">		sinkpad = gst_element_get_static_pad(static_cast&lt;VideoPlayerData*&gt;(data)-&gt;video_queue, &quot;sink&quot;);</span><br><span class="line">		if (gst_pad_link(pad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">			qDebug() &lt;&lt; &quot;fail to link qtdemux and videodec&quot;;</span><br><span class="line">		gst_object_unref(sinkpad);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		GstPad *sinkpad;</span><br><span class="line">		sinkpad = gst_element_get_static_pad(static_cast&lt;VideoPlayerData*&gt;(data)-&gt;audio_queue, &quot;sink&quot;);</span><br><span class="line">		if (gst_pad_link(pad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">			qDebug() &lt;&lt; &quot;fail to link qtdemux and audiodec&quot;;</span><br><span class="line">		gst_object_unref(sinkpad);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定信号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(data-&gt;qtdemux, &quot;pad-added&quot;, G_CALLBACK(new_player_pad), data);</span><br></pre></td></tr></table></figure>

<p>设置界面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WId d3d = widget-&gt;winId();</span><br><span class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;video_sink), d3d);</span><br></pre></td></tr></table></figure>

<p>提供控制接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void VideoPlayer::start()</span><br><span class="line">&#123;</span><br><span class="line">	t = std::thread(&amp;VideoPlayer::run, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void VideoPlayer::stop()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_main_loop_quit(data-&gt;loop);</span><br><span class="line">	if (t.joinable())</span><br><span class="line">		t.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool VideoPlayer::is_running()</span><br><span class="line">&#123;</span><br><span class="line">	GstState state;</span><br><span class="line">	gst_element_get_state(data-&gt;pipeline, &amp;state, NULL, GstClockTime(1000000));</span><br><span class="line">	return state == GST_STATE_PLAYING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void VideoPlayer::run()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">	g_main_loop_run(data-&gt;loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供获取播放信息的接口，分别是播放的位置，以及总长度:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gint64 VideoPlayer::get_pos()</span><br><span class="line">&#123;</span><br><span class="line">	GstFormat fmt = GST_FORMAT_TIME;</span><br><span class="line">	gint64 res;</span><br><span class="line">	gst_element_query_position(data-&gt;pipeline, fmt, &amp;res);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gint64 VideoPlayer::get_dur()</span><br><span class="line">&#123;</span><br><span class="line">	GstFormat fmt = GST_FORMAT_TIME;</span><br><span class="line">	gint64 res;</span><br><span class="line">	gst_element_query_duration(data-&gt;pipeline, fmt, &amp;res);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP发送音频流"><a href="#TCP发送音频流" class="headerlink" title="TCP发送音频流"></a>TCP发送音频流</h1><p>这里继承了QThread，头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QThread&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &lt;gst/app/gstappsrc.h&gt;</span><br><span class="line">#include &lt;gst/app/gstappsink.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GMainLoop *loop;</span><br><span class="line">	GstElement *src, *convert, *encoder, *sink;</span><br><span class="line">	GstElement *pipeline;</span><br><span class="line">	SOCKET sock;</span><br><span class="line">	SOCKADDR_IN address;</span><br><span class="line">&#125; AudioSenderData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AudioSender : public QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit AudioSender(SOCKET &amp;sk, QString host);</span><br><span class="line">    ~AudioSender();</span><br><span class="line"></span><br><span class="line">	void run();</span><br><span class="line">	static GstFlowReturn</span><br><span class="line">		on_new_sample_from_sink(GstElement * elt, AudioSenderData * data);</span><br><span class="line">	static int32_t	bytes_count;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	AudioSenderData *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用到的元件如下:</p>
<ul>
<li>autoaudiosrc</li>
<li>audioconvert</li>
<li>voaacenc</li>
<li>appsink</li>
</ul>
<p>初始化元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;sock = sk;</span><br><span class="line">data-&gt;pipeline = gst_pipeline_new(&quot;audio_pipeline_sender&quot;);</span><br><span class="line">data-&gt;src = gst_element_factory_make(&quot;autoaudiosrc&quot;, &quot;audio_src_sender&quot;);</span><br><span class="line">data-&gt;convert = gst_element_factory_make(&quot;audioconvert&quot;, &quot;audio_conv_sender&quot;);</span><br><span class="line">data-&gt;encoder = gst_element_factory_make(&quot;voaacenc&quot;, &quot;audio_enc_sender&quot;);</span><br><span class="line">data-&gt;sink = gst_element_factory_make(&quot;appsink&quot;, &quot;audio_sink_sender&quot;);</span><br></pre></td></tr></table></figure>

<p>设置一下码率:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(G_OBJECT(data-&gt;encoder), &quot;bitrate&quot;, bitrate, NULL);</span><br></pre></td></tr></table></figure>

<p>设置appsink以信号方式获取数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(G_OBJECT(data-&gt;sink), &quot;emit-signals&quot;, TRUE, &quot;sync&quot;, FALSE, NULL);</span><br></pre></td></tr></table></figure>

<p>定义一个处理数据的回调，取出数据之后通过TCP发送:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">GstFlowReturn AudioSender::on_new_sample_from_sink(GstElement * elt, AudioSenderData * data)</span><br><span class="line">&#123;</span><br><span class="line">	GstSample *sample;</span><br><span class="line">	GstBuffer *buffer;</span><br><span class="line">	GstMapInfo map;</span><br><span class="line">	sample = gst_app_sink_pull_sample(GST_APP_SINK(elt));</span><br><span class="line">	if (!sample)</span><br><span class="line">		return GstFlowReturn(0);</span><br><span class="line">	buffer = gst_sample_get_buffer(sample);</span><br><span class="line">	gst_buffer_map(buffer, &amp;map, GST_MAP_READ);</span><br><span class="line"></span><br><span class="line">	gst_sample_unref(sample);</span><br><span class="line"></span><br><span class="line">	gsize map_size;</span><br><span class="line">	gsize total_size;</span><br><span class="line">	map_size = map.size;</span><br><span class="line">	total_size = map_size + 2;</span><br><span class="line"></span><br><span class="line">	guint8 size_buffer[6];</span><br><span class="line">	size_buffer[0] = total_size;</span><br><span class="line">	size_buffer[1] = total_size &gt;&gt; 8;</span><br><span class="line">	size_buffer[2] = total_size &gt;&gt; 16;</span><br><span class="line">	size_buffer[3] = total_size &gt;&gt; 24;</span><br><span class="line"></span><br><span class="line">	size_buffer[4] = 0;</span><br><span class="line">	size_buffer[5] = 0;</span><br><span class="line"></span><br><span class="line">	gsize send_size = 0;</span><br><span class="line">	gsize server_send;</span><br><span class="line">	while (send_size &lt; 6)</span><br><span class="line">	&#123;</span><br><span class="line">		server_send = send(data-&gt;sock, (char *)size_buffer + send_size, </span><br><span class="line">			6 - send_size, 0);</span><br><span class="line">		send_size += server_send;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	send_size = 0;</span><br><span class="line">	while (send_size &lt; map_size)</span><br><span class="line">	&#123;</span><br><span class="line">		server_send = send(data-&gt;sock, (char *)(map.data) + send_size,</span><br><span class="line">			map_size - send_size, 0);</span><br><span class="line">		send_size += server_send;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gst_buffer_unmap(buffer, &amp;map);</span><br><span class="line"></span><br><span class="line">	return GstFlowReturn(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置appsink回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(data-&gt;sink, &quot;new-sample&quot;,</span><br><span class="line">	G_CALLBACK(on_new_sample_from_sink), data);</span><br></pre></td></tr></table></figure>

<p>设置appsink caps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define AUDIO_AAC_SENDER &quot;audio/mpeg, mpegversion=(int)4, channels=(int)1, rate=(int)8000, base-profile=(string)lc, stream-format=(string)adts&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GstCaps *caps;</span><br><span class="line">caps = gst_caps_from_string(AUDIO_AAC_SENDER);</span><br><span class="line">g_object_set(G_OBJECT(data-&gt;sink), &quot;caps&quot;, caps, NULL);</span><br><span class="line">gst_caps_unref(caps);</span><br></pre></td></tr></table></figure>

<p>连接通道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;src, data-&gt;convert, data-&gt;encoder,</span><br><span class="line">	data-&gt;sink, NULL);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;src, data-&gt;convert, data-&gt;encoder, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link audio sender pipeline&quot;;</span><br></pre></td></tr></table></figure>

<p>连接encoder和sink时插入caps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GstCaps *caps_enc;</span><br><span class="line">caps_enc = gst_caps_from_string(AUDIO_AAC_SENDER);</span><br><span class="line">if (!gst_element_link_filtered(data-&gt;encoder, data-&gt;sink, caps_enc))</span><br><span class="line">	qDebug() &lt;&lt; &quot;Failed to link caps&quot;;</span><br><span class="line">gst_caps_unref(caps_enc);</span><br></pre></td></tr></table></figure>

<p>启动接口以及释放资源:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AudioSender::~AudioSender()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_object_unref(data-&gt;pipeline);</span><br><span class="line">	g_free(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioSender::run()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP-接收播放音频流"><a href="#TCP-接收播放音频流" class="headerlink" title="TCP 接收播放音频流"></a>TCP 接收播放音频流</h1><p>继承QThread，头文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QThread&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &lt;gst/app/gstappsrc.h&gt;</span><br><span class="line">#include &lt;gst/app/gstappsink.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GstElement *pipeline, *appsrc, *parse, *decoder, *conv, *sink;</span><br><span class="line">	SOCKET sock;</span><br><span class="line">&#125; AudioRecData;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class AudioRec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AudioRec : public QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit AudioRec(SOCKET &amp;sk);</span><br><span class="line">    ~AudioRec();</span><br><span class="line"></span><br><span class="line">	void run();</span><br><span class="line">	void prepare_data();</span><br><span class="line"></span><br><span class="line">	static long cout_miss;</span><br><span class="line">	static long cout_rec;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	AudioRecData *data;</span><br><span class="line">	int flag;</span><br><span class="line">	int last_number = -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用元件:</p>
<ul>
<li>appsrc</li>
<li>aacparse</li>
<li>avdec_aac</li>
<li>audioconvert</li>
<li>autoaudiosink</li>
</ul>
<p>初始化元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;sock = sk;</span><br><span class="line">data-&gt;pipeline = gst_pipeline_new(&quot;audio_piprec&quot;);</span><br><span class="line">data-&gt;appsrc = gst_element_factory_make(&quot;appsrc&quot;, &quot;audio_srcrec&quot;);</span><br><span class="line">data-&gt;parse = gst_element_factory_make(&quot;aacparse&quot;, &quot;audio_parserec&quot;);</span><br><span class="line">data-&gt;decoder = gst_element_factory_make(&quot;avdec_aac&quot;, &quot;audio_decrec&quot;);</span><br><span class="line">data-&gt;conv = gst_element_factory_make(&quot;audioconvert&quot;, &quot;audio_convrec&quot;);</span><br><span class="line">data-&gt;sink = gst_element_factory_make(&quot;autoaudiosink&quot;, &quot;audio_sinkrec&quot;);</span><br></pre></td></tr></table></figure>

<p>设置appsrc的caps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define AUDIO_AAC_REC &quot;audio/mpeg, mpegversion=(int)4, channels=(int)1, rate=(int)8000, base-profile=(string)lc, stream-format=(string)adts&quot;</span><br><span class="line"></span><br><span class="line">GstCaps *caps;</span><br><span class="line">caps = gst_caps_from_string(AUDIO_AAC_REC);</span><br><span class="line">g_object_set(G_OBJECT(data-&gt;appsrc), &quot;caps&quot;, caps, NULL);</span><br><span class="line">gst_caps_unref(caps);</span><br></pre></td></tr></table></figure>

<p>设置block，以循环push的方式往通道传入参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(data-&gt;appsrc,</span><br><span class="line">	&quot;format&quot;, GST_FORMAT_TIME,</span><br><span class="line">	&quot;block&quot;, TRUE,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>

<p>设置sync参数，在丢包时通道不会卡住:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(G_OBJECT(data-&gt;sink), &quot;sync&quot;, FALSE, NULL);</span><br></pre></td></tr></table></figure>

<p>连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;appsrc, data-&gt;parse, data-&gt;decoder, data-&gt;conv, data-&gt;sink, NULL);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;appsrc, data-&gt;parse, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link audio receive pipeline&quot;;</span><br></pre></td></tr></table></figure>

<p>连接parse和decoder时指定caps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GstCaps *caps_dec;</span><br><span class="line">caps_dec = gst_caps_from_string(AUDIO_DEC_REC);</span><br><span class="line">if (!gst_element_link_filtered(data-&gt;parse, data-&gt;decoder, caps_dec))</span><br><span class="line">	qDebug() &lt;&lt; &quot;Failed to link caps&quot;;</span><br><span class="line">gst_caps_unref(caps_dec);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;decoder, data-&gt;conv, data-&gt;sink, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link audio receive pipeline&quot;;</span><br></pre></td></tr></table></figure>

<p>循环从tcp读取数据并传入通道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void AudioRec::prepare_data()</span><br><span class="line">&#123;</span><br><span class="line">	guint8 size_buffer[6];</span><br><span class="line">	gsize rec_size = 0;</span><br><span class="line">	gsize client_rec_size;</span><br><span class="line"></span><br><span class="line">	while (rec_size &lt; 6)</span><br><span class="line">	&#123;</span><br><span class="line">		client_rec_size = recv(data-&gt;sock, (char *)size_buffer + rec_size,</span><br><span class="line">			6 - rec_size, 0);</span><br><span class="line">		if (client_rec_size &gt; 6 || client_rec_size == SOCKET_ERROR)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = 0;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		rec_size += client_rec_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gsize total_size;</span><br><span class="line">	total_size = size_buffer[0]</span><br><span class="line">		+ (size_buffer[1] &lt;&lt; 8)</span><br><span class="line">		+ (size_buffer[2] &lt;&lt; 16)</span><br><span class="line">		+ (size_buffer[3] &lt;&lt; 24);</span><br><span class="line"></span><br><span class="line">	gsize map_size;</span><br><span class="line">	map_size = total_size - 2;</span><br><span class="line"></span><br><span class="line">	//qDebug() &lt;&lt; &quot;audio recive size: &quot; &lt;&lt; total_size;</span><br><span class="line"></span><br><span class="line">	if (map_size &gt; USHRT_MAX || total_size &lt; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		qDebug() &lt;&lt; &quot;audio size is not valid&quot;;</span><br><span class="line">		flag = 0;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char *frame_buffer = (char *)g_malloc(map_size * sizeof(char));</span><br><span class="line"></span><br><span class="line">	rec_size = 0;</span><br><span class="line">	while (rec_size &lt; map_size)</span><br><span class="line">	&#123;</span><br><span class="line">		client_rec_size = recv(data-&gt;sock, &amp;frame_buffer[rec_size],</span><br><span class="line">			map_size - rec_size, 0);</span><br><span class="line">		if (client_rec_size &gt; map_size || client_rec_size == SOCKET_ERROR)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = 0;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		rec_size += client_rec_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GstBuffer *buffer;</span><br><span class="line">	buffer = gst_buffer_new_wrapped((gpointer)(frame_buffer), map_size * sizeof(char));</span><br><span class="line"></span><br><span class="line">	gst_app_src_push_buffer(GST_APP_SRC(data-&gt;appsrc), buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioRec::run()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">	flag = 1;</span><br><span class="line">	while (flag)</span><br><span class="line">	&#123;</span><br><span class="line">		prepare_data();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP-发送视频流"><a href="#TCP-发送视频流" class="headerlink" title="TCP 发送视频流"></a>TCP 发送视频流</h1><p>头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QThread&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &lt;gst/app/gstappsrc.h&gt;</span><br><span class="line">#include &lt;gst/app/gstappsink.h&gt;</span><br><span class="line">#include &lt;gst/video/videooverlay.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GMainLoop *loop;</span><br><span class="line">	GstElement *videosrc, *videorate, *videobox, *videotee, *sendqueue, *playqueue, </span><br><span class="line">		*sendconv, *encoder, *sendsink, *playsrc, *playconv, *playsink;</span><br><span class="line">	GstElement *pipeline;</span><br><span class="line">	SOCKET sock;</span><br><span class="line">	SOCKADDR_IN address;</span><br><span class="line">&#125; VideoSenderData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class VideoSender : public QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit VideoSender(SOCKET&amp; sk, QString host, QWidget* w);</span><br><span class="line">    ~VideoSender();</span><br><span class="line"></span><br><span class="line">    void run();</span><br><span class="line">	static GstFlowReturn</span><br><span class="line">		on_new_sample_from_sink(GstElement * elt, VideoSenderData * data);</span><br><span class="line">	static int32_t	bytes_count;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	VideoSenderData *data;</span><br><span class="line"></span><br><span class="line">	QString phone_ip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用到的元件:</p>
<ul>
<li>autovideosrc</li>
<li>videorate</li>
<li>videobox</li>
<li>tee</li>
<li>queue</li>
<li>videoconvert</li>
<li>openh264enc</li>
<li>appsink</li>
<li>d3dvideosink</li>
</ul>
<p>初始化元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;sock = sk;</span><br><span class="line">data-&gt;pipeline = gst_pipeline_new(&quot;pipeline_src_sender&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;videosrc = gst_element_factory_make(&quot;autovideosrc&quot;, &quot;source_sender&quot;);</span><br><span class="line">data-&gt;videorate = gst_element_factory_make(&quot;videorate&quot;, &quot;rate_sender&quot;);</span><br><span class="line">data-&gt;videobox = gst_element_factory_make(&quot;videobox&quot;, &quot;box_sender&quot;);</span><br><span class="line">data-&gt;videotee = gst_element_factory_make(&quot;tee&quot;, &quot;selfsink_sender&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;sendqueue = gst_element_factory_make(&quot;queue&quot;, &quot;sendqueue_sender&quot;);</span><br><span class="line">data-&gt;sendconv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;convert2_sender&quot;);</span><br><span class="line">data-&gt;encoder = gst_element_factory_make(&quot;openh264enc&quot;, &quot;encoder_sender&quot;);</span><br><span class="line">data-&gt;sendsink = gst_element_factory_make(&quot;appsink&quot;, &quot;appsink_sender&quot;);</span><br><span class="line"></span><br><span class="line">data-&gt;playqueue = gst_element_factory_make(&quot;queue&quot;, &quot;playqueue_sender&quot;);</span><br><span class="line">data-&gt;playconv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;convert3_sender&quot;);</span><br><span class="line">data-&gt;playsink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;d3d_sender&quot;);</span><br></pre></td></tr></table></figure>

<p>设置码率，根据码率选择不同的分辨率的caps，设置appsink的caps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#define VIDEO_CAPS_SENDER_480 &quot;video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, profile=(string)baseline, width=(int)360, height=(int)480, framerate=(fraction)30/1&quot;</span><br><span class="line"></span><br><span class="line">#define VIDEO_CAPS_SENDER_320 &quot;video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, profile=(string)baseline, width=(int)240, height=(int)320, framerate=(fraction)30/1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (bitrate &lt;= 128000)</span><br><span class="line">&#123;</span><br><span class="line">	caps = gst_caps_from_string(VIDEO_CAPS_SENDER_320);</span><br><span class="line">	bitrate *= 0.8;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	caps = gst_caps_from_string(VIDEO_CAPS_SENDER_480);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_object_set(G_OBJECT(data-&gt;encoder),</span><br><span class="line">	&quot;bitrate&quot;, bitrate,</span><br><span class="line">	&quot;rate-control&quot;, 1,</span><br><span class="line">	&quot;max-bitrate&quot;, bitrate,</span><br><span class="line">	&quot;enable-frame-skip&quot;, true,</span><br><span class="line">	NULL);</span><br><span class="line"></span><br><span class="line">g_object_set(G_OBJECT(data-&gt;sendsink), &quot;emit-signals&quot;, TRUE, &quot;sync&quot;, FALSE, NULL);</span><br><span class="line">g_object_set(G_OBJECT(data-&gt;sendsink), &quot;caps&quot;, caps, NULL);</span><br><span class="line">gst_caps_unref(caps);</span><br></pre></td></tr></table></figure>

<p>设置裁剪方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(G_OBJECT(data-&gt;videobox), &quot;autocrop&quot;, TRUE, NULL);</span><br></pre></td></tr></table></figure>

<p>定义回调函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">GstFlowReturn </span><br><span class="line">VideoSender::on_new_sample_from_sink(GstElement * elt, VideoSenderData * data)</span><br><span class="line">&#123;</span><br><span class="line">	GstSample *sample;</span><br><span class="line">	GstBuffer *buffer;</span><br><span class="line">	GstMapInfo map;</span><br><span class="line">	sample = gst_app_sink_pull_sample(GST_APP_SINK(elt));</span><br><span class="line">	if (!sample)</span><br><span class="line">		return GstFlowReturn(0);</span><br><span class="line">	buffer = gst_sample_get_buffer(sample);</span><br><span class="line">	gst_buffer_map(buffer, &amp;map, GST_MAP_READ);</span><br><span class="line">	gst_sample_unref(sample);</span><br><span class="line"></span><br><span class="line">	gsize map_size;</span><br><span class="line">	gsize total_size;</span><br><span class="line">	map_size = map.size;</span><br><span class="line">	total_size = map_size + 2;</span><br><span class="line"></span><br><span class="line">	guint8 size_buffer[6];</span><br><span class="line">	size_buffer[0] = total_size;</span><br><span class="line">	size_buffer[1] = total_size &gt;&gt; 8;</span><br><span class="line">	size_buffer[2] = total_size &gt;&gt; 16;</span><br><span class="line">	size_buffer[3] = total_size &gt;&gt; 24;</span><br><span class="line"></span><br><span class="line">	size_buffer[4] = 0;</span><br><span class="line">	size_buffer[5] = 0;</span><br><span class="line"></span><br><span class="line">	gsize send_size = 0;</span><br><span class="line">	gsize server_send;</span><br><span class="line">	while (send_size &lt; 6)</span><br><span class="line">	&#123;</span><br><span class="line">		server_send = send(data-&gt;sock, (char *)size_buffer + send_size,</span><br><span class="line">			6 - send_size, 0);</span><br><span class="line">		send_size += server_send;</span><br><span class="line">	&#125;</span><br><span class="line">	send_size = 0;</span><br><span class="line">	while (send_size &lt; map_size)</span><br><span class="line">	&#123;</span><br><span class="line">		server_send = send(data-&gt;sock, (char *)(map.data) + send_size,</span><br><span class="line">			map_size - send_size, 0);</span><br><span class="line">		send_size += server_send;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gst_buffer_unmap(buffer, &amp;map);</span><br><span class="line"></span><br><span class="line">	return GstFlowReturn(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>appsink信号绑定回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect(data-&gt;sendsink, &quot;new-sample&quot;,</span><br><span class="line">	G_CALLBACK(on_new_sample_from_sink), data);</span><br></pre></td></tr></table></figure>

<p>视频源分成两路，一路通过appsink由TCP发送，一路通过播放元件预览:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GstPad *srcpad, *sinkpad;</span><br><span class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_0&quot;);</span><br><span class="line">sinkpad = gst_element_get_static_pad(data-&gt;sendqueue, &quot;sink&quot;);</span><br><span class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link tee and sendconv&quot;;</span><br><span class="line">gst_object_unref(srcpad);</span><br><span class="line">gst_object_unref(sinkpad);</span><br><span class="line"></span><br><span class="line">srcpad = gst_element_get_request_pad(data-&gt;videotee, &quot;src_1&quot;);</span><br><span class="line">sinkpad = gst_element_get_static_pad(data-&gt;playqueue, &quot;sink&quot;);</span><br><span class="line">if (gst_pad_link(srcpad, sinkpad) != GST_PAD_LINK_OK)</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link tee and playsink&quot;;</span><br><span class="line">gst_object_unref(srcpad);</span><br><span class="line">gst_object_unref(sinkpad);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;sendqueue, data-&gt;sendconv, data-&gt;encoder, data-&gt;sendsink, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link sender pipeline&quot;;</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;playqueue, data-&gt;playconv, data-&gt;playsink, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link sender pipeline&quot;;</span><br></pre></td></tr></table></figure>

<p>设置预览界面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WId d3d = w-&gt;winId();</span><br><span class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;playsink), d3d);</span><br></pre></td></tr></table></figure>

<p>析构函数释放资源，提供启动接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VideoSender::~VideoSender()</span><br><span class="line">&#123;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_object_unref(data-&gt;pipeline);</span><br><span class="line">	g_free(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void VideoSender::run()</span><br><span class="line">&#123;</span><br><span class="line">	//gst_element_set_state(data-&gt;sendsink, GST_STATE_PLAYING);</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP-接收视频流并显示"><a href="#TCP-接收视频流并显示" class="headerlink" title="TCP 接收视频流并显示"></a>TCP 接收视频流并显示</h1><p>头文件如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QThread&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &quot;gst/gst.h&quot;</span><br><span class="line">#include &lt;gst/app/gstappsrc.h&gt;</span><br><span class="line">#include &lt;gst/app/gstappsink.h&gt;</span><br><span class="line">#include &lt;gst/video/videooverlay.h&gt;</span><br><span class="line">#include &lt;gst/video/gstvideofilter.h&gt;</span><br><span class="line">#include &lt;gst/video/video.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	GstElement *pipeline, *appsrc, *decoder, *videoflip, *conv, *videosink;</span><br><span class="line">	SOCKET sock;</span><br><span class="line">&#125; VideoRecData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class VideoRec : public QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit VideoRec(SOCKET &amp;sk, QWidget* w);</span><br><span class="line">    ~VideoRec();</span><br><span class="line"></span><br><span class="line">    void run();</span><br><span class="line">	void prepare_data();</span><br><span class="line">	void flip();</span><br><span class="line">	GstState get_state();</span><br><span class="line"></span><br><span class="line">	static long cout_miss;</span><br><span class="line">	static long cout_rec;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	VideoRecData *data;</span><br><span class="line">	int flag;</span><br><span class="line">	int last_number = -1;</span><br><span class="line">	int rotate_index = 0;</span><br><span class="line">	std::vector&lt;const char*&gt; rotate&#123; &quot;none&quot;, &quot;clockwise&quot;, &quot;rotate-180&quot;, &quot;counterclockwise&quot; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用到的元件:</p>
<ul>
<li>appsrc</li>
<li>openh264dec</li>
<li>videoflip</li>
<li>videoconvert</li>
<li>d3dvideosink</li>
</ul>
<p>初始化元件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data-&gt;sock = sk;</span><br><span class="line">data-&gt;pipeline = gst_pipeline_new(&quot;video_pipeline_rec&quot;);</span><br><span class="line">data-&gt;appsrc = gst_element_factory_make(&quot;appsrc&quot;, &quot;video_srcrec&quot;);</span><br><span class="line">data-&gt;decoder = gst_element_factory_make(&quot;openh264dec&quot;, &quot;video_decrec&quot;);</span><br><span class="line">data-&gt;videoflip = gst_element_factory_make(&quot;videoflip&quot;, &quot;video_flip&quot;);</span><br><span class="line">data-&gt;conv = gst_element_factory_make(&quot;videoconvert&quot;, &quot;video_convrec&quot;);</span><br><span class="line">data-&gt;videosink = gst_element_factory_make(&quot;d3dvideosink&quot;, &quot;video_sinkrec&quot;);</span><br></pre></td></tr></table></figure>

<p>设置sync参数，否则丢包会导致播放失败:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(G_OBJECT(data-&gt;videosink), &quot;sync&quot;, FALSE, NULL);</span><br></pre></td></tr></table></figure>

<p>设置appsrc的caps:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define VIDEO_CAPS_REC &quot;video/x-h264, stream-format=(string)byte-stream, alignment=(string)au, profile=(string)baseline&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GstCaps *caps;</span><br><span class="line">caps = gst_caps_from_string(VIDEO_CAPS_REC);</span><br><span class="line">g_object_set(G_OBJECT(data-&gt;appsrc), &quot;caps&quot;, caps, NULL);</span><br><span class="line">gst_caps_unref(caps);</span><br></pre></td></tr></table></figure>

<p>appsink的blok属性设为true，以循环push的方式读取数据并传入通道:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_object_set(data-&gt;appsrc,</span><br><span class="line">	&quot;format&quot;, GST_FORMAT_TIME,</span><br><span class="line">	&quot;blok&quot;, TRUE,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>

<p>连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gst_bin_add_many(GST_BIN(data-&gt;pipeline), data-&gt;appsrc,</span><br><span class="line">	data-&gt;decoder, data-&gt;videoflip, data-&gt;conv, data-&gt;videosink, NULL);</span><br><span class="line"></span><br><span class="line">if (!gst_element_link_many(data-&gt;appsrc, data-&gt;decoder, data-&gt;videoflip, data-&gt;conv, data-&gt;videosink, NULL))</span><br><span class="line">	qDebug() &lt;&lt; &quot;fail to link video receiver&quot;;</span><br></pre></td></tr></table></figure>

<p>设置界面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WId d3d = w-&gt;winId();</span><br><span class="line">gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(data-&gt;videosink), d3d);</span><br></pre></td></tr></table></figure>

<p>通过设置videoflip的属性实现旋转图像，各个角度的属性在头文件定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void VideoRec::flip()</span><br><span class="line">&#123;</span><br><span class="line">	rotate_index += 1;</span><br><span class="line">	rotate_index %= 4;</span><br><span class="line">	gst_util_set_object_arg(G_OBJECT(data-&gt;videoflip), &quot;method&quot;, rotate[rotate_index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环读取数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void VideoRec::prepare_data()</span><br><span class="line">&#123;</span><br><span class="line">	guint8 size_buffer[6];</span><br><span class="line">	gsize rec_size = 0;</span><br><span class="line">	gsize client_rec_size;</span><br><span class="line"></span><br><span class="line">	while (rec_size &lt; 6)</span><br><span class="line">	&#123;</span><br><span class="line">		client_rec_size = recv(data-&gt;sock, (char *)size_buffer + rec_size,</span><br><span class="line">			6 - rec_size, 0);</span><br><span class="line">		if (client_rec_size &gt; 6 || client_rec_size == SOCKET_ERROR)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = 0;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		rec_size += client_rec_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gsize total_size;</span><br><span class="line">	total_size = size_buffer[0]</span><br><span class="line">		+ (size_buffer[1] &lt;&lt; 8)</span><br><span class="line">		+ (size_buffer[2] &lt;&lt; 16)</span><br><span class="line">		+ (size_buffer[3] &lt;&lt; 24);</span><br><span class="line"></span><br><span class="line">	gsize map_size;</span><br><span class="line">	map_size = total_size - 2;</span><br><span class="line"></span><br><span class="line">	//qDebug() &lt;&lt; &quot;video recive size: &quot; &lt;&lt; total_size;</span><br><span class="line"></span><br><span class="line">	if (map_size &gt; USHRT_MAX || total_size &lt; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		qDebug() &lt;&lt; &quot;video size is not valid&quot;;</span><br><span class="line">		flag = 0;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char *frame_buffer = (char *)g_malloc(map_size * sizeof(char));</span><br><span class="line"></span><br><span class="line">	rec_size = 0;</span><br><span class="line">	while (rec_size &lt; map_size)</span><br><span class="line">	&#123;</span><br><span class="line">		client_rec_size = recv(data-&gt;sock, &amp;frame_buffer[rec_size],</span><br><span class="line">			map_size - rec_size, 0);</span><br><span class="line">		if (client_rec_size &gt; map_size || client_rec_size == SOCKET_ERROR)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = 0;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		rec_size += client_rec_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	GstBuffer *buffer;</span><br><span class="line">	buffer = gst_buffer_new_wrapped((gpointer)(frame_buffer), map_size * sizeof(char));</span><br><span class="line"></span><br><span class="line">	gst_app_src_push_buffer(GST_APP_SRC(data-&gt;appsrc), buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void VideoRec::run()</span><br><span class="line">&#123;</span><br><span class="line">	//gst_element_set_state(data-&gt;appsrc, GST_STATE_PLAYING);</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_PLAYING);</span><br><span class="line">	flag = 1;</span><br><span class="line">	while (flag)</span><br><span class="line">	&#123;</span><br><span class="line">		prepare_data();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VideoRec::~VideoRec()</span><br><span class="line">&#123;</span><br><span class="line">	flag = 0;</span><br><span class="line">	gst_element_set_state(data-&gt;pipeline, GST_STATE_NULL);</span><br><span class="line">	g_object_unref(data-&gt;pipeline);</span><br><span class="line">	g_free(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-02</span><i class="fa fa-tag"></i><a class="tag" href="/tags/gstreamer/" title="gstreamer">gstreamer </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/02/02/Note/gstreamer/demo/,Harryx,gstreamer example,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/02/03/Note/tools/cmake/" title="cmake">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/01/27/Note/python/library/basic/functools/" title="functools">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>
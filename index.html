<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Harryx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Harryx">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Harryx">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Harryx">
  
    <link rel="alternate" href="/atom.xml" title="Harryx" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Harryx</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-effective-C" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/03/effective-C/" class="article-date">
  <time datetime="2017-06-03T06:47:42.000Z" itemprop="datePublished">2017-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/03/effective-C/">effective_C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>0.除非有需要使用隐式转换的构造函数，否则构造函数生命为<code>explicit</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Person</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	explicit Person(std::string name = &quot;None&quot;, unsigned int age = 0);</div><div class="line">	...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯<code>C++</code></h1><p>1.把C++视为语言联邦：</p>
<ul>
<li>C</li>
<li>面相对象</li>
<li>泛型编程</li>
<li>STL</li>
</ul>
<p>2.尽量以<code>const</code>，<code>enum</code>，<code>inline</code>替换<code>#define</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Person</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	static const int number = 1; //有初值的声明</div><div class="line">	int array[number];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const int Person::number; //定义</div></pre></td></tr></table></figure>
<p>使用<code>enum hack</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Person</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	enum &#123; number = 1 &#125;; //number成为1的记号</div><div class="line">	int array[number];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>3.尽量使用<code>const</code></p>
<p>当const和non-const成员函数有等价的实现时，可以用non-const版本调用const版本，避免代码重复，<br>但是不能反过来调用，因为可能带来风险。</p>
<p>4.确定对象使用前已被初始化</p>
<p>类构造函数进入函数体之前用成员初始化列表初始化</p>
<h1 id="构造、析构、赋值运算"><a href="#构造、析构、赋值运算" class="headerlink" title="构造、析构、赋值运算"></a>构造、析构、赋值运算</h1><p>5.了解<code>C++</code>默默编写并调用哪些函数</p>
<p>如果含有引用成员，或者const成员，必须自己定义拷贝赋值操作符</p>
<p>如果基类将拷贝赋值运算符声明为private，编译器将拒绝为其派生类生成拷贝赋值运算符</p>
<p>6.若不想使用编译器自动生成的函数，就应该明确拒绝</p>
<p>将其声明为<code>private</code></p>
<p>7.为多态基类声明<code>virtual</code>析构函数</p>
<p>给基类添加virtual析构函数，当销毁基类指针指向的派生类对象时，正确销毁整个对象</p>
<p>如果不希望基类被实例化，可以把析构函数声明为纯虚函数</p>
<p>析构函数运作方式是先最深的开始，然后往基类调用，所以需要先实现基类析构函数的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual ~A() = 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A::A() &#123;&#125; //定义纯虚函数的定义</div></pre></td></tr></table></figure>
<p>如果设计目的不是具有多态性质，就不该声明virtual函数</p>
<p>8.别让异常逃离析构函数</p>
<p>析构函数绝对不要突出异常，如果析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，吞下或结束程序</p>
<p>9.绝不在构造和析构过程中调用<code>virtual</code>函数</p>
<p>在析构函数和构造函数不要调用virtual函数，因为这类调用不会下降到派生类</p>
<p>10.令<code>operate=</code>返回一个<code>*this</code>的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Widget&amp; operator=(const Widget&amp; rhs)</div><div class="line">&#123;</div><div class="line">	return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>11.在<code>operator=</code>处理自我赋值</p>
<p>通过调整语句顺序实现自我赋值和异常安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Widget&amp; operator=(const Widtget&amp; rhs)</div><div class="line">&#123;</div><div class="line">	int* pOrig = pb;  //先备份</div><div class="line">	pb = new int(*rhs.pb);  //创建副本</div><div class="line">	delete pOrig; //删除原先的</div><div class="line">	return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>12.复制对象时勿忘其每一个成分</p>
<p>拷贝函数应该确保复制对象内的所有成员变量以及所有基类成分</p>
<p>不要尝试以一个拷贝函数实现另外一个拷贝函数，应该将共同机能放在第三个函数中，由另外两个拷贝函数调用</p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>13.以对象管理资源</p>
<p>RAII对象：构造函数中获取资源，析构函数中释放资源</p>
<p>常被使用的是<code>auto_ptr</code>和<code>shared_ptr</code></p>
<p>14.在资源管理类中小心拷贝行为</p>
<p>对资源进行引用计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Lock</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	eplicit Lock(Mutex *pm)   //以某个mutex初始化shared_ptr</div><div class="line">		: mutexPtr(pm, unlock)  //以unlock作为删除器</div><div class="line">	&#123;</div><div class="line">		lock(mutexPtr.get()); //用以返回智能指针内部的原始指针</div><div class="line">	&#125;</div><div class="line">private:</div><div class="line">	std::shared_ptr&lt;Mutex&gt; mutexPtr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>复制RAII对象必须一并复制它所管理的资源</p>
<p>创建的RAII复制行为是：抑制复制行为、使用引用计数法</p>
<p>15.在资源管理中提供对原始资源的访问</p>
<p>对原始资源的访问可能经由显式转换或隐式转换，显示比较安全，隐式比较方便</p>
<p>16.成对使用 <code>new</code>和<code>delete</code>时要采取相同形式</p>
<p>如果在调用<code>new</code>时使用<code>[]</code>，必须字对应调用<code>delete</code>时也使用<code>[]</code></p>
<p>17.以独立语句将newed对象置入智能指针</p>
<p>以独立语句将newed对象置入智能指针，如果不这样做，一旦异常被抛出，可能发生资源泄漏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), priority())</div></pre></td></tr></table></figure>
<p>应该使用独立的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::shared_ptr&lt;Widget&gt; pw(new Widget);</div><div class="line">processWidget(pw, priority());</div></pre></td></tr></table></figure>
<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><p>18.让接口容易被正确使用，不易被误用</p>
<p>19.设计<code>class</code>犹如设计<code>type</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/03/effective-C/" data-id="cj5c7k385000km0u4xhxqcbxn" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-traceback" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/01/traceback/" class="article-date">
  <time datetime="2017-04-01T09:11:08.000Z" itemprop="datePublished">2017-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/01/traceback/">异常处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>python捕获异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    a = 1 / 0</div><div class="line">except Exception, e:</div><div class="line">    print str(e)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">integer division or modulo by zero</div></pre></td></tr></table></figure>
<hr>
<p>可以继承Exception类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class AIsZeroError(Exception):</div><div class="line">    pass</div><div class="line"></div><div class="line">try:</div><div class="line">    raise AIsZeroError(&apos;a is 0&apos;)</div><div class="line">except AIsZeroError, e:</div><div class="line">    print str(e)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a is 0</div></pre></td></tr></table></figure>
<hr>
<p>python中使用traceback模块处理异常，sys模块也提供了特定的参数和函数。</p>
<p>sys.exc_info()</p>
<p>该函数会返回一个三元元组，包含异常信息（exc_type exc_value exc_traceback）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    a = 1 / 0</div><div class="line">except Exception:</div><div class="line">    t, value, tb = sys.exc_info()</div><div class="line">    print t</div><div class="line">    print value</div><div class="line">    print tb</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;type &apos;exceptions.ZeroDivisionError&apos;&gt;</div><div class="line">integer division or modulo by zero</div><div class="line">&lt;traceback object at 0x000000000367A5C8&gt;</div></pre></td></tr></table></figure>
<hr>
<p>traceback.print_exception()</p>
<p>格式化输出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    a = 1 / 0</div><div class="line">except Exception:</div><div class="line">    t, value, tb = sys.exc_info()</div><div class="line">    traceback.print_exception(t, value, tb)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;D:/MyData/code/python_test/just_fo_test/main.py&quot;, line 5, in &lt;module&gt;</div><div class="line">    a = 1 / 0</div><div class="line">ZeroDivisionError: integer division or modulo by zero</div></pre></td></tr></table></figure>
<hr>
<p>traceback.print_exc()</p>
<p>traceback.print_exc()函数只是traceback.print_exception()函数的一个简写形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    a = 1 / 0</div><div class="line">except Exception:</div><div class="line">    traceback.print_exc(file=sys.stdout)</div></pre></td></tr></table></figure>
<hr>
<p>traceback.format_exception()</p>
<p>传入参数，返回一个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    a = 1 / 0</div><div class="line">except Exception:</div><div class="line">    t, value, tb = sys.exc_info()</div><div class="line">    for l in traceback.format_exception(t, value, tb):</div><div class="line">        print l</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line"></div><div class="line">  File &quot;D:/MyData/code/python_test/just_fo_test/main.py&quot;, line 5, in &lt;module&gt;</div><div class="line">    a = 1 / 0</div><div class="line"></div><div class="line">ZeroDivisionError: integer division or modulo by zero</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/01/traceback/" data-id="cj5c7k43g004vm0u4j8suw1ys" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-logging" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/01/logging/" class="article-date">
  <time datetime="2017-04-01T07:00:20.000Z" itemprop="datePublished">2017-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/01/logging/">打印日志</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>logging模块用于python的日志记录</p>
<p>不进行配置时，默认日志级别为warning</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import logging</div><div class="line">logging.debug(&quot;1&quot;)</div><div class="line">logging.info(&quot;2&quot;)</div><div class="line">logging.warning(&quot;3&quot;)</div><div class="line">logging.error(&quot;4&quot;)</div><div class="line">logging.critical(&quot;5&quot;)</div></pre></td></tr></table></figure>
<p>输出内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WARNING:root:3</div><div class="line">ERROR:root:4</div><div class="line">CRITICAL:root:5</div></pre></td></tr></table></figure>
<hr>
<p>可以通过<code>logging.basicConfig</code>更改配置:</p>
<ul>
<li>level: 日志级别（DEBUG、INFO、WARNING、ERROR、CRITICAL）</li>
<li>format: 输出格式<ul>
<li>%(levelno)s: 日志级别数值</li>
<li>%(levelname)s: 日志级别名称</li>
<li>%(pathname)s: 执行的程序路径</li>
<li>%(filename)s: 执行文件名</li>
<li>%(funcName)s: 打印日志的函数</li>
<li>%(lineno)d: 行号</li>
<li>%(asctime)s: 时间</li>
<li>%(thread)d: 线程ID</li>
<li>%(threadName)s: 线程名称</li>
<li>%(process)d: 进程ID</li>
<li>%(message)s: 日志信息</li>
</ul>
</li>
<li>datefmt: 时间格式（%Y %b %d %a %H %M %S）（年、月、日、星期、时、分、秒）</li>
<li>filename: 日志文件名</li>
<li>filemode: ‘w’或者’a’</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">logging.basicConfig(</div><div class="line">    level=logging.DEBUG,</div><div class="line">    format=&apos;%(asctime)s.%(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;,</div><div class="line">    datefmt=&apos;%a, %d, %b, %Y, %H:%M:%S&apos;,</div><div class="line">    filename=os.path.join(os.path.dirname(__file__),</div><div class="line">                          time.strftime(&apos;%Y-%m-%d&apos;, time.localtime())),</div><div class="line">    filemode=&apos;w&apos;</div><div class="line">)</div></pre></td></tr></table></figure>
<hr>
<p>输出到屏幕</p>
<p>定义一个StreamHandler，将日志打印到屏幕，添加到当前日志处理对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">logging_handler = logging.StreamHandler()</div><div class="line">logging_handler.setLevel(logging.DEBUG)</div><div class="line">logging_handler.setFormatter(logging.Formatter(</div><div class="line">    &apos;%(asctime)s.%(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;))</div><div class="line">logging.getLogger(&apos;&apos;).addHandler(logging_handler)</div></pre></td></tr></table></figure>
<hr>
<p>日志回滚</p>
<p>限制每个日志文件大小最多1K（1024），最多备份五个日志文件，命名为my.log、my.log1~5，实际上一共6个文件，最新的为my.log，最旧的为my.log5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">logging_handler2 = logging.handlers.RotatingFileHandler(&apos;my.log&apos;, maxBytes=1024, backupCount=5)</div><div class="line">logging_handler2.setLevel(logging.DEBUG)</div><div class="line">logging_handler2.setFormatter(logging.Formatter(</div><div class="line">    &apos;%(asctime)s.%(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;</div><div class="line">))</div><div class="line">logging.getLogger(&apos;&apos;).addHandler(logging_handler2)</div></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html" target="_blank" rel="external">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/01/logging/" data-id="cj5c7k39u001sm0u45h95g2oo" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-construct" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/01/construct/" class="article-date">
  <time datetime="2017-04-01T06:33:10.000Z" itemprop="datePublished">2017-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/01/construct/">二进制数据处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>costruct</code>是python的二进制数据解析器和构造器</p>
<p>基本类型：</p>
<p>整数</p>
<p>Int{8,16,24,32,64}{u,s}{l,b,n}  对应选择位数、符号、字节序</p>
<p>Byte 等同于 Int8ub</p>
<p>浮点数</p>
<p>Float{32,64}{b,l,n}</p>
<p>Single、Double等同于Float{32,64}b</p>
<p>变长整型</p>
<p>VarInt</p>
<p>字段</p>
<p>Bytes</p>
<hr>
<p>用Struct建立一个format</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">c1 = Struct(</div><div class="line">    &apos;a&apos; / Byte,</div><div class="line">    &apos;b&apos; / Int16ul,</div><div class="line">    &apos;c&apos; / Single,</div><div class="line">    &apos;d&apos; / Const(b&apos;hello&apos;),</div><div class="line">)</div></pre></td></tr></table></figure>
<p>传入一个字符串，解析成Container，Container就相当于一个普通的字典，并且具有具有自己的输出格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p1 = c1.parse(b&apos;\x07\x00\x01\x00\x00\x00\x01hello&apos;)</div><div class="line">print p1</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Container: </div><div class="line">    a = 7</div><div class="line">    b = 256</div><div class="line">    c = 1.40129846432e-45</div><div class="line">    d = hello</div></pre></td></tr></table></figure>
<hr>
<p>建立10个单字节的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c2 = Byte[10]</div></pre></td></tr></table></figure>
<p>build函数的参数是个Container对象或者类似的鸭子类型（比如一个普通的类）</p>
<p>构建一个格式化的字符串，使用ord()获得对应的ASCII值输出查看效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b2 = c2.build([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])</div><div class="line">print [ord(b) for b in b2]</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</div></pre></td></tr></table></figure>
<p>解析刚才构建的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p2 = c2.parse(b2)</div><div class="line">print p2</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ListContainer: </div><div class="line">    1</div><div class="line">    2</div><div class="line">    3</div><div class="line">    4</div><div class="line">    5</div><div class="line">    6</div><div class="line">    7</div><div class="line">    8</div><div class="line">    9</div><div class="line">    0</div></pre></td></tr></table></figure>
<hr>
<p>可以在Struct内放入Struct</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">c3 = Struct(</div><div class="line">    &apos;a&apos; / Byte,</div><div class="line">    &apos;b&apos; / Struct(</div><div class="line">        &apos;c&apos; / Byte,</div><div class="line">        &apos;d&apos; / Int16ul,</div><div class="line">    )</div><div class="line">)</div></pre></td></tr></table></figure>
<p>传入Container对象构建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b3 = c3.build(Container(a=1, b=Container(c=2, d=3)))</div><div class="line">print [ord(b) for b in b3]</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3, 0]</div></pre></td></tr></table></figure>
<p>解析之前构建的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p3 = c3.parse(b3)</div><div class="line">print p3</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Container: </div><div class="line">    a = 1</div><div class="line">    b = Container: </div><div class="line">        c = 2</div><div class="line">        d = 3</div></pre></td></tr></table></figure></p>
<hr>
<p>可以通过&gt;&gt;构建格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c4 = Int16ul &gt;&gt; Byte &gt;&gt; Bytes(5)</div></pre></td></tr></table></figure>
<p>解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p4 = c4.parse(b&apos;\x01\x02\x03hello&apos;)</div><div class="line">print p4</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ListContainer: </div><div class="line">    513</div><div class="line">    3</div><div class="line">    hello</div></pre></td></tr></table></figure>
<p>Embedded用于嵌入格式<br>Switch类似于其他语言的switch语句，以一个lambda语句作为参数，lambda有个ctx上下文参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">from construct import *</div><div class="line"></div><div class="line">header = Struct(</div><div class="line">    &apos;head&apos; / Const(b&apos;hello&apos;),</div><div class="line">)</div><div class="line"></div><div class="line">frame = Struct(</div><div class="line">    Embedded(header),</div><div class="line">    &apos;a&apos; / Int8ul,</div><div class="line">    &apos;b&apos; / Switch(lambda ctx: ctx[&apos;a&apos;],</div><div class="line">                 &#123;</div><div class="line">                     0x01: Int8ul,</div><div class="line">                     0x02: Int16ul,</div><div class="line">                     0x03: Int32ul,</div><div class="line">                     0x04: VarInt,</div><div class="line">                 &#125;)</div><div class="line">)</div><div class="line"></div><div class="line">b = frame.build(Container(head=&apos;hello&apos;, a=4, b=1231231312))</div><div class="line">print [ord(c) for c in b]</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[104, 101, 108, 108, 111, 4, 208, 178, 140, 203, 4]</div></pre></td></tr></table></figure>
<p>使用<code>this</code>关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">frame = Struct(</div><div class="line">    &apos;length&apos; / Int8ul,</div><div class="line">    &apos;payload&apos; / Bytes(this.length)</div><div class="line">)</div><div class="line"></div><div class="line">b = frame.build(Container(length=2, payload=b&apos;hi&apos;))</div><div class="line">print [ord(c) for c in b]</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[2, 104, 105]</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://construct.readthedocs.io/en/latest/" target="_blank" rel="external">文档</a></p>
<p>以上是2.8版本的，2.5版本略有不同<a href="http://www.thinksaas.cn/topics/0/435/435656.html" target="_blank" rel="external">参考</a></p>
<hr>
<p>在网络编程中也常使用struct模块用于数据的打包和解包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">struct.pack(&apos;3B&apos;,1,2,3)</div><div class="line">&apos;\x01\x02\x03&apos;</div></pre></td></tr></table></figure>
<p>打包和解包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import struct</div><div class="line"></div><div class="line">s = struct.pack(&apos;!3BI&apos;, 1, 2, 3, 4)</div><div class="line">t = struct.unpack(&apos;!3BI&apos;, s)</div><div class="line">print [ord(c) for c in s]</div><div class="line">print t</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3, 0, 0, 0, 4]</div><div class="line">(1, 2, 3, 4)</div></pre></td></tr></table></figure>
<p>在前面使用不同符号表示字节不同的位排序</p>
<p><img src="http://7xrooc.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170406102515.png" alt=""></p>
<p>如果第一个字符不是当中的任何一个，自动添加一个<code>@</code>，启动本机序本机序是大端或者小端，取决于本机系统</p>
<p><code>@</code>尺寸取决本机系统，<code>=</code>尺寸为标准大小</p>
<p><code>&lt;</code>小端 <code>&gt;</code>大端 <code>!</code>网络序</p>
<p>各类型</p>
<p><img src="http://7xrooc.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170406101144.png" alt=""></p>
<p><a href="https://docs.python.org/2/library/struct.html" target="_blank" rel="external">文档</a><br><a href="http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html" target="_blank" rel="external">参考</a></p>
<hr>
<p>socket提供函数用于ip地址字符串与整型之间的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; socket.inet_aton(&quot;192.168.1.1&quot;)</div><div class="line">&apos;\xc0\xa8\x01\x01&apos;</div><div class="line">&gt;&gt;&gt; socket.inet_ntoa(&apos;\x01\x02\x03\x04&apos;)</div><div class="line">&apos;1.2.3.4&apos;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/01/construct/" data-id="cj5c7k38c000om0u4flmron9o" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Csharp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/29/Csharp/" class="article-date">
  <time datetime="2017-03-29T02:35:14.000Z" itemprop="datePublished">2017-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/29/Csharp/">C#面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>抽空研究了一下C#，稍微整理了下。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>和C++相比，C#省去了指针（内存）的直接操作，类也有一些细节上的变化。</p>
<p>和C++类似，C#使用<code>virtual</code>和<code>override</code>关键字继承类方法，使用<code>new</code>关键字隐藏方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">&#123;</div><div class="line">    public int num_of_legs;</div><div class="line">    public string food;</div><div class="line">    public Animal(int num, string f)</div><div class="line">    &#123;</div><div class="line">        num_of_legs = num;</div><div class="line">        food = f;</div><div class="line">    &#125;</div><div class="line">    public virtual string say()  // 使用virtual关键字创建虚函数</div><div class="line">    &#123;</div><div class="line">        return &quot;...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog : Animal</div><div class="line">&#123;</div><div class="line">    public Dog(int num, string f):</div><div class="line">        base(num, f)&#123;&#125;</div><div class="line">    public override string say()  // 这里的override关键词不能省略</div><div class="line">    &#123;</div><div class="line">        return &quot;汪!!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类使用base关键字访问基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Cat : Animal</div><div class="line">&#123;</div><div class="line">    public Cat(int num, string f):</div><div class="line">        base(num, f)&#123;&#125;</div><div class="line">    public override string say()</div><div class="line">    &#123;</div><div class="line">        return &quot;喵?&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BigCat : Cat</div><div class="line">&#123;</div><div class="line">    public BigCat(int num, string f):</div><div class="line">        base(num, f)&#123;&#125;</div><div class="line">    public override string say()</div><div class="line">    &#123;</div><div class="line">        return base.say() + &quot;喵?喵?&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>C#有个叫<code>interface</code>（接口）的东西（作用相当于契约），看上去和类差不多，但是接口不能被实例化</p>
<p>接口不能定义变量，只能定义某种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">interface IAnimal</div><div class="line">&#123;</div><div class="line">    int num_of_legs &#123; get; &#125;  // 定义属性方法</div><div class="line">    string food &#123; get; &#125;</div><div class="line">    string say();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Animal : IAnimal</div><div class="line">&#123;</div><div class="line">    public int num_of_legs &#123; get; &#125;</div><div class="line">    public string food &#123; get; &#125;</div><div class="line">    public Animal(int num, string f)</div><div class="line">    &#123;</div><div class="line">        num_of_legs = num;</div><div class="line">        food = f;</div><div class="line">    &#125;</div><div class="line">    public virtual string say()</div><div class="line">    &#123;</div><div class="line">        return &quot;...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以通过引用操作接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bird bird = new Bird(2, &quot;rice&quot;, 10);  // 一个Bird实例</div><div class="line">IAnimal animal = bird;  // IAnimal引用</div><div class="line">MessageBox.Show(animal.say());</div></pre></td></tr></table></figure>
<p>可以通过<code>is</code>查看是否实现了接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BigCat big_cat = new BigCat(4, &quot;fish&quot;);</div><div class="line">if(big_cat is IAnimal)</div><div class="line">	MessageBox.Show(big_cat.say());</div></pre></td></tr></table></figure>
<p>C#允许类使用<code>as</code>向下强制转换</p>
<p>如果向下转换失败，<code>as</code>语句返回null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Animal animal = new BigCat(4, &quot;fish&quot;);  // 把BigCat向上强制转换成Animal</div><div class="line">if (animal is BigCat)  // 通过is判断其是否实现了BigCat</div><div class="line">&#123;</div><div class="line">    BigCat big_cat = animal as BigCat;  // 向下强制转换</div><div class="line">    MessageBox.Show(big_cat.say());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口的继承</p>
<p>接口也可继承方法，然后建立新类实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">interface IAnimal</div><div class="line">&#123;</div><div class="line">    int num_of_legs &#123; get; &#125;</div><div class="line">    string food &#123; get; &#125;</div><div class="line">    string say();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface IFlyAnimal : IAnimal</div><div class="line">&#123;</div><div class="line">    int size_of_wings &#123; get; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bird : IFlyAnimal</div><div class="line">&#123;</div><div class="line">    public Bird(int num, string f, int s)</div><div class="line">    &#123;</div><div class="line">        num_of_legs = num;</div><div class="line">        food = f;</div><div class="line">        size_of_wings = s;</div><div class="line">    &#125;</div><div class="line">    public string food &#123; get; &#125;</div><div class="line">    public int num_of_legs &#123; get; &#125;</div><div class="line">    public int size_of_wings &#123; get; &#125;</div><div class="line"></div><div class="line">    public virtual string say()</div><div class="line">    &#123;</div><div class="line">        return &quot;...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现新类的时候可以同时继承基类和接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Bird : Animal, IFlyAnimal</div><div class="line">&#123;</div><div class="line">    public Bird(int num, string f, int s) :</div><div class="line">        base(num, f)</div><div class="line">    &#123;</div><div class="line">        size_of_wings = s;</div><div class="line">    &#125;</div><div class="line">    public int size_of_wings &#123; get; &#125;</div><div class="line">    public override string say()</div><div class="line">    &#123;</div><div class="line">        return &quot;啾！&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口作用</p>
<p>接口用起来就像一个指针，它可以用来表示实现了某个接口的所有类。</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类和类相似，可以继承、储存变量或者实现方法，但是和接口一样，不能实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">abstract class Animal : IAnimal</div><div class="line">&#123;</div><div class="line">    public int num_of_legs &#123; get; set; &#125;</div><div class="line">    public string food &#123; get; set; &#125;</div><div class="line">    public Animal(int num, string f)</div><div class="line">    &#123;</div><div class="line">        num_of_legs = num;</div><div class="line">        food = f;</div><div class="line">    &#125;</div><div class="line">    public virtual string say()</div><div class="line">    &#123;</div><div class="line">        return &quot;...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="实现比较方法"><a href="#实现比较方法" class="headerlink" title="实现比较方法"></a>实现比较方法</h1><p>C#的类先继承接口然后在实现方法，下面实现一个比较方法</p>
<p>Card类先继承<code>IComparable&lt;Card&gt;</code>接口，然后实现<code>CompareTo</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Card : IComparable&lt;Card&gt;</div><div class="line">&#123;</div><div class="line">    private Suit suit;</div><div class="line">    private Value value;</div><div class="line">    public Card(Suit suit, Value value)</div><div class="line">    &#123;</div><div class="line">        this.suit = suit;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 先比较花色然后比较数字大小</div><div class="line">    public int CompareTo(Card other)</div><div class="line">    &#123;</div><div class="line">        if (suit == other.suit)</div><div class="line">        &#123;</div><div class="line">            if (value &gt; other.value)</div><div class="line">                return 1;</div><div class="line">            else if (value &lt; other.value)</div><div class="line">                return -1;</div><div class="line">            else</div><div class="line">                return 0;</div><div class="line">        &#125;</div><div class="line">        else if (suit &gt; other.suit)</div><div class="line">            return 1;</div><div class="line">        else</div><div class="line">            return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public string get_name()</div><div class="line">    &#123;</div><div class="line">        return suit + &quot; &quot; + value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/29/Csharp/" data-id="cj5c7k37q0007m0u4xgw6xadf" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-thread2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/24/thread2/" class="article-date">
  <time datetime="2017-03-24T09:27:28.000Z" itemprop="datePublished">2017-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/24/thread2/">socket并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>服务器同时处理多个客户的并发服务器有许多种方式，可以使用Unix的fork函数创建子进程</p>
<p>(fork示例参考）(<a href="http://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html" target="_blank" rel="external">http://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html</a>)</p>
<p>本章内容使用的是python的多线程实现并发服务。</p>
<p>服务端使用SoketServer网络服务框架<br>如果设置daemon守护线程（t.daemon=True），在主线程结束时，子线程也会结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">import threading</div><div class="line">import SocketServer</div><div class="line"></div><div class="line"></div><div class="line">class TCPServerHandler(SocketServer.BaseRequestHandler):</div><div class="line">    def handle(self):</div><div class="line">        self.data = self.request.recv(1024).strip()</div><div class="line">        print &quot;&#123;&#125; wrote:&quot;.format(self.client_address[0])</div><div class="line">        print self.data</div><div class="line">        self.request.sendall(self.data.upper())</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    host, port = &quot;localhost&quot;, 6666</div><div class="line">    server = SocketServer.TCPServer((host, port), TCPServerHandler)</div><div class="line">    t = threading.Thread(target=server.serve_forever)</div><div class="line">    #t.daemon = True</div><div class="line">    t.start()</div><div class="line"></div><div class="line">    # client</div><div class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line"></div><div class="line">    try:</div><div class="line">        sock.connect((host, port))</div><div class="line">        sock.sendall(&quot;hello\n&quot;)</div><div class="line">        rec = sock.recv(1024)</div><div class="line">    finally:</div><div class="line">        sock.close()</div><div class="line"></div><div class="line">    print rec</div></pre></td></tr></table></figure>
<p>SocketServer.TCPServer(server_address, RequestHandlerClass, bind_and_activate=true)使用TCP协议，提供客户端与服务器之间的连续数据流。当bind_and_activate设置为true（默认为true），构造函数会自动尝试调用server_bind() 绑定地址和server_activate() 监听地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):</div><div class="line">    &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</div><div class="line">    BaseServer.__init__(self, server_address, RequestHandlerClass)</div><div class="line">    self.socket = socket.socket(self.address_family,</div><div class="line">                                self.socket_type)</div><div class="line">    if bind_and_activate:</div><div class="line">        try:</div><div class="line">            self.server_bind()</div><div class="line">            self.server_activate()</div><div class="line">        except:</div><div class="line">            self.server_close()</div><div class="line">            raise</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/24/thread2/" data-id="cj5c7k43e004sm0u4gd5srxcw" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soket/">soket</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rpc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/rpc/" class="article-date">
  <time datetime="2017-03-23T07:39:37.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/rpc/">rpc远程调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RPC（Remote Procedure Call Protocol）是基于TCP或者RPC等传输协议的远程过程调用协议。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>参考：<br>    <a href="https://github.com/seprich/py-bson-rpc" target="_blank" rel="external">github示例</a><br>    <a href="http://seprich.github.io/py-bson-rpc/index.html" target="_blank" rel="external">文档</a></p>
<p>python的<code>bsonrpc</code>库通过类装饰器的方式构造RPC服务</p>
<ul>
<li><code>@service_class</code>装饰RPC服务类</li>
<li><code>@request</code>装饰提供RPC调用的函数</li>
<li><code>@rpc_request</code>增加一个JSONRpc/BSONRpc对象作为参数</li>
<li><code>@notification</code>用于通知，有个字符串参数</li>
</ul>
<p>两种方式通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@rpc_request</div><div class="line">def long_process(self, rpc, a, b, c):</div><div class="line">	print(rpc.client_info)</div><div class="line">	# 2 ways to send notifications:</div><div class="line">	rpc.invoke_notification(&apos;report_progress&apos;, &apos;Stage 1&apos;)</div><div class="line">	client = rpc.get_peer_proxy()</div><div class="line">	client.n.report_progress(&apos;Stage 2&apos;)</div></pre></td></tr></table></figure>
<p>构建一个RPC类，然后将创建好的套接字作为参数传递给<code>JSONRpc</code>对象</p>
<p>下面是一个RPC客户端，主动<code>connect</code>PRC服务器，然后保存<code>self.server</code>用作调用远程方法</p>
<p>因为是TCP连接，在客户端调用<code>close()</code>方法之前，服务器也可通过RPC调用客户端服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">from bsonrpc import JSONRpc, request, service_class, notification</div><div class="line"></div><div class="line">@service_class</div><div class="line">class MyRpcServer(object):</div><div class="line"></div><div class="line">    @request</div><div class="line">    def my_double(self, a):</div><div class="line">        return a*2</div><div class="line"></div><div class="line">    @notification</div><div class="line">    def report_progress(self, mes):</div><div class="line">        print mes</div><div class="line"></div><div class="line">class ClientServer(object):</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">        self.s.connect((&apos;localhost&apos;, 6000))</div><div class="line">        self.rpc = JSONRpc(self.s, MyRpcServer())</div><div class="line">        self.server = self.rpc.get_peer_proxy()</div><div class="line"></div><div class="line">    def add(self, a, b):</div><div class="line">        return self.server.my_progress_add(a, b)</div><div class="line"></div><div class="line">    def close(self):</div><div class="line">        self.rpc.close()</div><div class="line"></div><div class="line">c = ClientServer()</div><div class="line">print c.add(2, 2)</div></pre></td></tr></table></figure>
<p>服务端和客户端类似，不同的是服务器需要等待客户端服务，因此使用线程会比较方便</p>
<p>通过使用单例模式，程序的其他地方可以通过实例化一个RPC类获取<code>client</code>，用来调用客户端方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">from bsonrpc import service_class, request, JSONRpc, rpc_request</div><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">@service_class</div><div class="line">class MyRpcServer(object):</div><div class="line"></div><div class="line">    def __new__(cls):</div><div class="line">        &quot;&quot;&quot;单例模式&quot;&quot;&quot;</div><div class="line">        if &quot;_sin&quot; not in cls.__dict__:</div><div class="line">            cls._sin = super(MyRpcServer, cls).__new__(cls)</div><div class="line">        return cls._sin</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        if &apos;client&apos; not in self.__dict__:</div><div class="line">            self.client = None</div><div class="line"></div><div class="line">    @request</div><div class="line">    def my_add(self, num_1, num_2):</div><div class="line">        return num_1 + num_2</div><div class="line"></div><div class="line">    @rpc_request</div><div class="line">    def my_progress_add(self, rpc, num_1, num_2):</div><div class="line">        print rpc.client_info</div><div class="line">        self.client = rpc.get_peer_proxy()</div><div class="line">        self.client.n.report_progress(&apos;hi&apos;)</div><div class="line">        result = self.client.my_double(3)</div><div class="line">        print result</div><div class="line">        return num_1 + num_2</div><div class="line"></div><div class="line"></div><div class="line">class ServiceServer(threading.Thread):</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">        self.ss.bind((&apos;localhost&apos;, 6000))</div><div class="line">        self.ss.listen(10)</div><div class="line"></div><div class="line">        threading.Thread.__init__(self)</div><div class="line"></div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            _s, _address = self.ss.accept()</div><div class="line">            JSONRpc(_s,</div><div class="line">                    MyRpcServer(),</div><div class="line">                    client_info=_address)</div><div class="line"></div><div class="line">s = ServiceServer()</div><div class="line">s.start()</div><div class="line">time.sleep(5)</div><div class="line">c = MyRpcServer()</div><div class="line">res = c.client.my_double(5)</div><div class="line">print id(c), res</div><div class="line">b = MyRpcServer()</div><div class="line">res = b.client.my_double(10)</div><div class="line">print id(b), res</div></pre></td></tr></table></figure>
<p>其实JSONRpc()函数返回的就是一个rpc对象，可以在线程中保存，以便获得client对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class ServiceServer(threading.Thread):</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">        self.ss.bind((&apos;localhost&apos;, 6000))</div><div class="line">        self.ss.listen(10)</div><div class="line">        self.rpc = None</div><div class="line"></div><div class="line">        threading.Thread.__init__(self)</div><div class="line"></div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            _s, _address = self.ss.accept()</div><div class="line">            self.rpc = JSONRpc(_s,</div><div class="line">                               MyRpcServer(),</div><div class="line">                               client_info=_address)</div><div class="line">            print &quot;name&quot;, _s.getsockname()</div></pre></td></tr></table></figure>
<p>然后这样获得client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s = ServiceServer()</div><div class="line">s.start()</div><div class="line">time.sleep(5)</div><div class="line">client = s.rpc.get_peer_proxy()</div><div class="line">print client.my_double(5)  # 调用客户端方法</div></pre></td></tr></table></figure>
<p>试着用循环处理多个客户端（并没有这个必要）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class ServiceServer(threading.Thread):</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">        self.ss.bind((&apos;localhost&apos;, 6000))</div><div class="line">        self.ss.listen(10)</div><div class="line">        self.rpcs = []</div><div class="line"></div><div class="line">        threading.Thread.__init__(self)</div><div class="line"></div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            _s, _address = self.ss.accept()</div><div class="line">            self.rpcs.append(JSONRpc(_s,</div><div class="line">                                     MyRpcServer(),</div><div class="line">                                     client_info=_address))</div><div class="line"></div><div class="line">s = ServiceServer()</div><div class="line">s.start()</div><div class="line">while True:</div><div class="line">    time.sleep(5)</div><div class="line">    for rpc in s.rpcs[:]:</div><div class="line">        try:</div><div class="line">            client = rpc.get_peer_proxy()</div><div class="line">            print client.my_double(5)</div><div class="line">        except BsonRpcError:</div><div class="line">            rpc.close()</div><div class="line">            s.rpcs.remove(rpc)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/rpc/" data-id="cj5c7k437004lm0u43iyw7baq" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mqtt" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/23/mqtt/" class="article-date">
  <time datetime="2017-03-23T01:18:19.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/mqtt/">mqtt</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是基于TCP/IP的传输协议</p>
<h1 id="在windows环境搭建MQTT服务器"><a href="#在windows环境搭建MQTT服务器" class="headerlink" title="在windows环境搭建MQTT服务器"></a>在windows环境搭建MQTT服务器</h1><p>参考：<a href="http://blog.csdn.net/yannanxiu/article/details/52703946" target="_blank" rel="external">链接</a></p>
<p>注意：</p>
<ul>
<li><p>要设置环境变量<code>APOLLO_HOME</code>，比如，本机设置的是<code>D:\App\mqtt\apache-apollo-1.7.1</code></p>
</li>
<li><p>还有java环境变量<code>JAVA_HOME</code>，这里是<code>D:\App\java8\java\</code></p>
</li>
</ul>
<h1 id="一个基于mqtt的聊天工具"><a href="#一个基于mqtt的聊天工具" class="headerlink" title="一个基于mqtt的聊天工具"></a>一个基于mqtt的聊天工具</h1><p>注意：<br>    如果在连接服务器后不添加延时，直接上传，会被服务器误认为是攻击，触发一个<code>Errno 10054</code>异常，</p>
<p>一个MQTT客户端类</p>
<ul>
<li><code>on_connect</code>会在连接到服务器后调用<ul>
<li><code>client</code>是传回的client参数</li>
<li><code>user_data</code>是<code>client</code>实例化或者调用<code>userdata_set()</code>设置的<code>_userdata</code>参数</li>
<li><code>flags</code>是<code>broker</code>返回的字典参数</li>
<li><code>rc</code>连接结果，0表示成功<ul>
<li>1: Connection refused - incorrect protocol version</li>
<li>2: Connection refused - invalid client identifier</li>
<li>3: Connection refused - server unavailable</li>
<li>4: Connection refused - bad username or password</li>
<li>5: Connection refused - not authorised</li>
</ul>
</li>
</ul>
</li>
<li><code>on_message</code>在收到消息后调用，消息放在<code>msg</code>字符串中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import paho.mqtt.client as mqtt</div><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">class MQTTClient(object):</div><div class="line">    &quot;&quot;&quot;一个MQTT客户端&quot;&quot;&quot;</div><div class="line">    def __init__(self):</div><div class="line">        self.client = mqtt.Client()</div><div class="line">        self.client.username_pw_set(&quot;admin&quot;, &quot;password&quot;)</div><div class="line">        self.client.on_connect = self.on_connect</div><div class="line">        self.client.on_message = self.on_message</div><div class="line">        self.client.connect(&quot;127.0.0.1&quot;, 61613, 60)</div><div class="line">        self.client.loop_start()</div><div class="line"></div><div class="line">    def on_connect(self, client, user_data, flags, rc):</div><div class="line">        del client, user_data, flags, rc</div><div class="line">        self.client.subscribe(&quot;chat&quot;)</div><div class="line"></div><div class="line">    @staticmethod</div><div class="line">    def on_message(client, user_data, msg):</div><div class="line">        del client, user_data</div><div class="line">        print(msg.topic + &quot; &quot; + str(msg.payload))</div></pre></td></tr></table></figure>
<p>实例化两个客户端互发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mc1 = MQTTClient()</div><div class="line">mc2 = MQTTClient()</div><div class="line">while 1:</div><div class="line">    time.sleep(5)</div><div class="line">    mc1.client.publish(&quot;chat&quot;, &quot;hi1&quot;)</div><div class="line">    time.sleep(5)</div><div class="line">    mc2.client.publish(&quot;chat&quot;, &quot;hi2&quot;)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/23/mqtt/" data-id="cj5c7k3a3001wm0u4kwxytnm7" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jihuang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/18/jihuang/" class="article-date">
  <time datetime="2017-03-18T15:36:24.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/jihuang/">Don&#39;t Statve</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近跟小伙伴沉迷饥荒，一起吃饭睡觉打豆豆，各种作死。在玩过基本人物之后并不过瘾，装了一堆mod，愣是把生存游戏完成了RPG。</p>
<p><img src="http://7xrooc.com1.z0.glb.clouddn.com/20170215231734_1.jpg" alt=""></p>
<p>“你怎么死了？”</p>
<p>“你怎么又死了？”</p>
<p>“我怎么也死了？”</p>
<p>“要死要死要死！”</p>
<p>“快来救我！”</p>
<p>“有吃的吗？我快饿死了？” </p>
<p> …..</p>
<p>精灵公主：“嗯，我的男宠。。和。。儿子们。。没毛病。”</p>
<p>厉害了我的精灵公主。</p>
<p><img src="http://7xrooc.com1.z0.glb.clouddn.com/20170318233130_1.jpg" alt=""></p>
<p><img src="http://7xrooc.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170319184341.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/18/jihuang/" data-id="cj5c7k39t001rm0u4sb0f890d" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acg/">acg</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-come-back" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/come-back/" class="article-date">
  <time datetime="2017-03-14T13:54:02.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/come-back/">懒癌归来</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于环境搬迁这个博客很烦，自从换了电脑之后一直没更新（其实就是懒），时隔四个月，折腾了一个小时，这次终于成功克服懒癌搬回来了^ ^.  好好学习天天向上咯~ 下面是整理的几个坑。</p>
<h1 id="Windows安装时的几个坑"><a href="#Windows安装时的几个坑" class="headerlink" title="Windows安装时的几个坑"></a>Windows安装时的几个坑</h1><p>github注册，新建仓库什么的就跳过了，然后是git的安装，在官网下载git的速度简直了，好在github有同步更新的网站。<a href="https://github.com/waylau/git-for-win" target="_blank" rel="external">网址</a>下载完成后安装，不要忘了设置环境变量。</p>
<p>然后是node.js的安装，这里到官网下载安装，没什么问题。</p>
<p>然后用npm安装hexo又不动了，需要使用淘宝的源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure>
<p>然后后面就把所有的npm命令换成cnpm，后面没什么问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cnpm install hexo-cli -g</div><div class="line">d:</div><div class="line">hexo init blog</div><div class="line">cd blog</div><div class="line">cnpm install</div></pre></td></tr></table></figure>
<p>后面就是缺什么就用<code>cnpm</code>装什么</p>
<p>是hexo初始化安装什么的还算顺利，配置deploy:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: https://github.com/HarryHEi/HarryHEi.github.io.git</div><div class="line">  branch: master</div><div class="line">  message: update</div></pre></td></tr></table></figure>
<p>在<code>hexo d</code>的时候有时候会一直没反应，用管理员运行cmd，多试几次又可以了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/come-back/" data-id="cj5c7k37y000em0u4v4izo44w" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bb/">bb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/hello-world/" class="article-date">
  <time datetime="2017-03-14T12:28:34.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/hello-world/" data-id="cj5c7ihtu0000b4u4bwk3iyzs" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/26/C3/" class="article-date">
  <time datetime="2016-11-26T10:49:04.000Z" itemprop="datePublished">2016-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/26/C3/">C++ Primer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><h2 id="拷贝赋值和销毁"><a href="#拷贝赋值和销毁" class="headerlink" title="拷贝赋值和销毁"></a>拷贝赋值和销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>13.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//注意，这里省略了 std::</div><div class="line">class HasPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    HasPtr(const string &amp;s = string()) : </div><div class="line">        ps(new string(s)), i(0) &#123;&#125;</div><div class="line">    HasPtr(const HasPtr &amp;hp);</div><div class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</div><div class="line">    void change(const string s) &#123;*ps = s;&#125;</div><div class="line">private:</div><div class="line">    string *ps;</div><div class="line">    int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</div><div class="line">    ps(new string(*hp.ps)),</div><div class="line">    i(hp.i) &#123;&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    HasPtr a(&quot;hello&quot;);</div><div class="line">    HasPtr b = a;</div><div class="line">    a.print(); //hello</div><div class="line">    b.print(); // hello</div><div class="line">    a.change(&quot;world&quot;);</div><div class="line">    a.print(); // world</div><div class="line">    b.print(); // hello</div><div class="line">    b.change(&quot;asd&quot;);</div><div class="line">    a.print(); // world</div><div class="line">    b.print(); //asd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>13.8</p>
<p>重载赋值运算符，返回类型是当前对象的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class HasPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    HasPtr(const string &amp;s = string()) : </div><div class="line">        ps(new string(s)), i(0) &#123;&#125;</div><div class="line">    HasPtr(const HasPtr &amp;hp);</div><div class="line">    HasPtr &amp;operator=(const HasPtr &amp;hp);</div><div class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</div><div class="line">    void change(const string s) &#123;*ps = s;&#125;</div><div class="line">private:</div><div class="line">    string *ps;</div><div class="line">    int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</div><div class="line">    ps(new string(*hp.ps)),</div><div class="line">    i(hp.i) &#123;&#125;</div><div class="line"></div><div class="line">//重载赋值运算符，返回类型是当前对象的引用</div><div class="line">HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)</div><div class="line">&#123;</div><div class="line">    //防止hp和ps指向同一对象</div><div class="line">    auto newp = new string(*hp.ps); //存到临时变量</div><div class="line">    delete ps; //释放旧内存</div><div class="line">    ps = newp; //拷贝到本地</div><div class="line">    i = hp.i;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    HasPtr a(&quot;hello&quot;);</div><div class="line">    HasPtr b;</div><div class="line">    b = a;</div><div class="line">    a.print(); //hello</div><div class="line">    b.print(); // hello</div><div class="line">    a.change(&quot;world&quot;);</div><div class="line">    a.print(); // world</div><div class="line">    b.print(); // hello</div><div class="line">    b.change(&quot;asd&quot;);</div><div class="line">    a.print(); // world</div><div class="line">    b.print(); //asd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>初始化对象非static成员，释放对象使用的资源，销毁非static数据成员</p>
<p>没有返回值，不接收参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">class HasPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    HasPtr(const string &amp;s = string()) : </div><div class="line">        ps(new string(s)), i(0) &#123;&#125;</div><div class="line">    ~HasPtr() &#123;delete ps;&#125; //析构函数</div><div class="line">    HasPtr(const HasPtr &amp;hp);</div><div class="line">    HasPtr &amp;operator=(const HasPtr &amp;hp);</div><div class="line">    string *val()&#123;return ps;&#125;</div><div class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</div><div class="line">    void change(const string s) &#123;*ps = s;&#125;</div><div class="line">private:</div><div class="line">    string *ps;</div><div class="line">    int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</div><div class="line">    ps(new string(*hp.ps)),</div><div class="line">    i(hp.i) &#123;&#125;</div><div class="line"></div><div class="line">HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)</div><div class="line">&#123;</div><div class="line">    auto newp = new string(*hp.ps);</div><div class="line">    delete ps;</div><div class="line">    ps = newp;</div><div class="line">    i = hp.i;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//返回一个指针，指向string</div><div class="line">string *fun()</div><div class="line">&#123;</div><div class="line">    HasPtr hp(&quot;hello&quot;);</div><div class="line">    return hp.val();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    string *p = fun(); //p指向一个已经被释放的string</div><div class="line">    cout &lt;&lt; *p &lt;&lt; endl; //报错，因为指针已经悬空</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>13.18</p>
<p>利用<code>static</code>数据成员给每个对象生成唯一的递增的数据成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Employee</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Employee(const string s) : name(s),num(count)</div><div class="line">        &#123;count = count + 1;&#125;</div><div class="line">    void print() &#123;cout &lt;&lt; num &lt;&lt; &quot; : &quot; &lt;&lt; name &lt;&lt; endl;&#125;</div><div class="line">private:</div><div class="line">    string name;</div><div class="line">    int num;</div><div class="line">    static int count; //内部声明</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//static外部定义，注意没有static关键字</div><div class="line">int Employee::count = 0;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    Employee e1(&quot;a&quot;);</div><div class="line">    Employee e2(&quot;b&quot;);</div><div class="line">    Employee e3(&quot;c&quot;);</div><div class="line">    e1.print(); // 0 : a</div><div class="line">    e2.print(); // 1 : b</div><div class="line">    e3.print(); // 2 : c</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="拷贝控制和资源管理ka"><a href="#拷贝控制和资源管理ka" class="headerlink" title="拷贝控制和资源管理ka"></a>拷贝控制和资源管理ka</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>13.27</p>
<p>计数器保存在动态内存中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">class HasPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    HasPtr(const string &amp;s = string()) : </div><div class="line">        ps(new string(s)), i(0), use(new size_t(0)) &#123;++ *use;&#125;</div><div class="line">    ~HasPtr(); </div><div class="line">    HasPtr(const HasPtr &amp;hp);</div><div class="line">    HasPtr &amp;operator=(const HasPtr &amp;hp);</div><div class="line">    string *val()&#123;return ps;&#125;</div><div class="line">    void print() &#123;cout &lt;&lt; *use &lt;&lt; &quot; &quot; &lt;&lt; *ps &lt;&lt; endl;&#125;</div><div class="line">    void change(const string s) &#123;*ps = s;&#125;</div><div class="line">private:</div><div class="line">    string *ps;</div><div class="line">    int i;</div><div class="line">    size_t *use;</div><div class="line">&#125;;</div><div class="line">//拷贝初始化，自增计数器</div><div class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</div><div class="line">    ps(new string(*hp.ps)),</div><div class="line">    i(hp.i), use(hp.use) &#123;++*use;&#125;</div><div class="line">//析构函数，自减计数器，计数器为0释放内存</div><div class="line">HasPtr::~HasPtr()</div><div class="line">&#123;</div><div class="line">    if (-- *use == 0)</div><div class="line">    &#123;</div><div class="line">        delete ps;</div><div class="line">        delete use;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//拷贝赋值运算符，右值自增，左值自减计数器</div><div class="line">HasPtr &amp;HasPtr::operator=(const HasPtr &amp;hp)</div><div class="line">&#123;</div><div class="line">    ++ *hp.use; //先自增，防止指向的是同一对象</div><div class="line">    if(-- *use == 0)</div><div class="line">    &#123;</div><div class="line">        delete ps;</div><div class="line">        delete use;</div><div class="line">    &#125;</div><div class="line">    ps = hp.ps;</div><div class="line">    i = hp.i;</div><div class="line">    use = hp.use;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line">//查看引用计数</div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    HasPtr a1(&quot;hello&quot;);</div><div class="line">    a1.print(); // 1</div><div class="line">    HasPtr a2(&quot;world&quot;);</div><div class="line">    a1.print(); // 1</div><div class="line">    a2.print(); // 1</div><div class="line">    HasPtr a3 = a1;</div><div class="line">    a1.print(); // 2</div><div class="line">    a2.print(); // 1</div><div class="line">    a3.print(); // 2</div><div class="line">    a3 = a2;</div><div class="line">    a1.print(); // 1</div><div class="line">    a2.print(); // 2</div><div class="line">    a3.print(); // 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>13.31</p>
<p>在赋值运算中调用swap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">class HasPtr</div><div class="line">&#123;</div><div class="line">friend void swap(HasPtr &amp;hp1, HasPtr &amp;hp2);</div><div class="line">public:</div><div class="line">    HasPtr(const string &amp;s = string()) : </div><div class="line">        ps(new string(s)), i(0), use(new size_t(0)) &#123;++ *use;&#125;</div><div class="line">    ~HasPtr(); </div><div class="line">    HasPtr(const HasPtr &amp;hp);</div><div class="line">    HasPtr &amp;operator=(HasPtr hp);</div><div class="line">    bool operator&lt;(const HasPtr &amp;hp) const;</div><div class="line">    string *val()&#123;return ps;&#125;</div><div class="line">    void print() &#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;</div><div class="line">    void change(const string s) &#123;*ps = s;&#125;</div><div class="line">private:</div><div class="line">    string *ps;</div><div class="line">    int i;</div><div class="line">    size_t *use;</div><div class="line">&#125;;</div><div class="line">//拷贝初始化，同上</div><div class="line">HasPtr::HasPtr(const HasPtr &amp;hp) :</div><div class="line">    ps(new string(*hp.ps)),</div><div class="line">    i(hp.i), use(hp.use) &#123;++*use;&#125;</div><div class="line">//析构函数，同上</div><div class="line">HasPtr::~HasPtr()</div><div class="line">&#123;</div><div class="line">    if (-- *use == 0)</div><div class="line">    &#123;</div><div class="line">        delete ps;</div><div class="line">        delete use;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//使用swap重写拷贝赋值操作</div><div class="line">HasPtr &amp;HasPtr::operator=(HasPtr hp)</div><div class="line">&#123;  </div><div class="line">     //副本在脱离代码块时，自动调用析构函数释放内存</div><div class="line">    swap(*this, hp); //当前对象于一个副本交换</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line">//&lt; 运算符，在调用sort时需要</div><div class="line">bool HasPtr::operator&lt;(const HasPtr &amp;hp) const</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;operator &lt; ...&quot; &lt;&lt; endl;</div><div class="line">    return *this -&gt; ps &lt; *hp.ps;</div><div class="line">&#125;</div><div class="line">//swap操作</div><div class="line">inline</div><div class="line">void swap(HasPtr &amp;hp1, HasPtr &amp;hp2)</div><div class="line">&#123;</div><div class="line">    //如果类没有自己的swap调用标准库的swap</div><div class="line">    //如果类有自己的swap，不会隐藏自己的swap</div><div class="line">    using std::swap; </div><div class="line">    swap(hp1.ps, hp2.ps);</div><div class="line">    swap(hp1.i, hp2.i);</div><div class="line">    cout &lt;&lt; &quot;swaped...&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    HasPtr a1(&quot;hello&quot;);</div><div class="line">    HasPtr a2(&quot;world&quot;);</div><div class="line">    HasPtr a3(&quot;byebye&quot;);</div><div class="line">    vector&lt;HasPtr&gt; vhp&#123;a1, a2, a3&#125;;</div><div class="line">    sort(vhp.begin(), vhp.end()); //排序</div><div class="line">    /*</div><div class="line">        输出：这里调用了三次比较，四次swap拷贝赋值</div><div class="line">        operator &lt; ...</div><div class="line">        operator &lt; ...</div><div class="line">        swaped...</div><div class="line">        operator &lt; ...</div><div class="line">        swaped...</div><div class="line">        swaped...</div><div class="line">        swaped...</div><div class="line">    */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="重载运算和类型转换"><a href="#重载运算和类型转换" class="headerlink" title="重载运算和类型转换"></a>重载运算和类型转换</h1><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>14.2</p>
<p>重载Sales_data的输入、输出、加法和复合赋值运算符<br>重载相等运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Sales_data &amp;sd);</div><div class="line">friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Sales_data &amp;sd);</div><div class="line">friend Sales_data operator+(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line">friend bool operator==(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line">friend bool operator!=(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line">//...省略...</div><div class="line">public:</div><div class="line">    Sales_data &amp;operator+=(const Sales_data&amp;);</div><div class="line">//...省略...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//成员函数</div><div class="line">inline</div><div class="line">Sales_data&amp; Sales_data::operator+=(const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    unit += sd.unit;</div><div class="line">    revenue += sd.revenue;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//非成员函数</div><div class="line">istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    double price = 0;</div><div class="line">    is &gt;&gt; sd.name &gt;&gt; sd.unit &gt;&gt; price;</div><div class="line">    if(is) //判断流是否发生错误</div><div class="line">        sd.revenue = price * sd.unit;</div><div class="line">    else //如果错误，赋值为默认状态</div><div class="line">        sd = Sales_data();</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line">ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; sd.getname() &lt;&lt; &quot; &quot; &lt;&lt; sd.unit &lt;&lt; &quot; &quot;</div><div class="line">        &lt;&lt; sd.revenue &lt;&lt; &quot; &quot; &lt;&lt; sd.avg_price() &lt;&lt; &quot; num: &quot; &lt;&lt; sd.num;</div><div class="line">    return os;</div><div class="line">&#125;</div><div class="line">Sales_data operator+(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    Sales_data sum = sd1;</div><div class="line">    sum += sd2;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">bool operator==(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    return sd1.name == sd2.name &amp;&amp;</div><div class="line">        sd1.unit == sd2.unit &amp;&amp;</div><div class="line">        sd1.revenue == sd2.revenue;</div><div class="line">&#125;</div><div class="line">bool operator!=(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    return !(sd1 == sd2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    Sales_data sd1, sd2;</div><div class="line">    cin &gt;&gt; sd1; //输入</div><div class="line">    cin &gt;&gt; sd2;</div><div class="line">    Sales_data sd3 = sd1 + sd2; //加</div><div class="line">    sd3 += sd1; //复合赋值</div><div class="line">    cout &lt;&lt; sd3 &lt;&lt; endl; //输出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>14.18</p>
<p>比较运算符根据实际情况选择是否添加<br>给StrBlob添加比较运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class StrBlob</div><div class="line">&#123;</div><div class="line">friend bool operator&lt;(const StrBlob &amp;sb1, const StrBlob &amp;sb2);</div><div class="line">//...</div><div class="line">&#125;;</div><div class="line">//非成员函数</div><div class="line">bool operator&lt;(const StrBlob &amp;sb1, const StrBlob &amp;sb2)</div><div class="line">&#123;</div><div class="line">    auto b1 = sb1.data -&gt; begin(), e1 = sb1.data -&gt; end();</div><div class="line">    auto b2 = sb2.data -&gt; begin(), e2 = sb2.data -&gt; end();</div><div class="line">    while (b1 != e1 &amp;&amp; b2 != e2)</div><div class="line">    &#123;</div><div class="line">        if (*b1 != *b2)</div><div class="line">            return *b1 &lt; *b2;</div><div class="line">        ++b1;</div><div class="line">        ++b2;</div><div class="line">    &#125;</div><div class="line">    return sb1.data -&gt; size() &lt; sb2.data -&gt; size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    StrBlob b1&#123;&quot;abc&quot;,&quot;afd&quot;&#125;;</div><div class="line">    StrBlob b2&#123;&quot;abc&quot;,&quot;afd&quot;,&quot;asd&quot;&#125;;</div><div class="line">    cout &lt;&lt; (b1 &lt; b2) &lt;&lt; endl; // 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>14.26</p>
<p>下标运算符通常定义两个版本，一个返回普通的引用，另一个是常量成员并且返回常量引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class StrBlob</div><div class="line">&#123;</div><div class="line">//...</div><div class="line">    string &amp;operator[](size_t n);</div><div class="line">    const string &amp;operator[](size_t n) const;</div><div class="line">//...</div><div class="line">&#125;;</div><div class="line">//成员函数</div><div class="line">//普通版本</div><div class="line">string &amp;StrBlob::operator[](size_t n)</div><div class="line">&#123;</div><div class="line">    return (*data)[n];</div><div class="line">&#125;</div><div class="line">//常量版本</div><div class="line">const string &amp;StrBlob::operator[](size_t n) const</div><div class="line">&#123;</div><div class="line">    return (*data)[n];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    StrBlob b&#123;&quot;abc&quot;,&quot;afd&quot;&#125;;</div><div class="line">    const StrBlob a(b);</div><div class="line">    a[1] = &quot;world&quot;; //错误，常量引用只读</div><div class="line">    b[1] = &quot;hello&quot;;</div><div class="line">    cout &lt;&lt; b[1] &lt;&lt; endl; // hello</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>14.30</p>
<p>给StrBlobPtr添加自增、自减和解引用运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">//先申明</div><div class="line">class StrBlobPtr;</div><div class="line">class StrBlob</div><div class="line">&#123;</div><div class="line">friend class StrBlobPtr; //申明为友元</div><div class="line">public:</div><div class="line">    typedef vector&lt;string&gt;::size_type size_type;</div><div class="line">    //构造函数</div><div class="line">    StrBlob():data(make_shared&lt;vector&lt;string&gt;&gt;())&#123;&#125;</div><div class="line">    StrBlob(initializer_list&lt;string&gt; ils)://多个字符串参数</div><div class="line">        data(make_shared&lt;vector&lt;string&gt;&gt;(ils)) &#123;&#125;</div><div class="line">    //成员函数</div><div class="line">    StrBlobPtr begin();</div><div class="line">    StrBlobPtr end();</div><div class="line">    size_type size() const &#123;return data -&gt; size();&#125;</div><div class="line">    bool empty() const &#123;return data -&gt; empty();&#125;</div><div class="line">    void push_back(const string &amp;t) &#123;data -&gt; push_back(t);&#125;</div><div class="line">    void pop_back() &#123;check(0, &quot;empty&quot;); data -&gt; front();&#125;</div><div class="line">    string&amp; front() &#123;check(0, &quot;empty&quot;); return data -&gt; front();&#125;</div><div class="line">    string&amp; back() &#123;check(0, &quot;empty&quot;); return data -&gt; back();&#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; data;//vec的指针</div><div class="line">    //检测异常</div><div class="line">    void check(size_type i, const string &amp;msg) const </div><div class="line">        &#123;if (i &gt;= data -&gt; size()) throw out_of_range(msg);&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class StrBlobPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    StrBlobPtr() : curr(0) &#123;&#125;</div><div class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz=0):</div><div class="line">        wptr(a.data), curr(sz) &#123;&#125; //用shared_ptr初始化弱指针</div><div class="line">    //成员函数</div><div class="line">    string &amp;operator*() const; //解引用</div><div class="line">    string *operator-&gt;() const;</div><div class="line">    StrBlobPtr &amp;operator++(); //递增</div><div class="line">    StrBlobPtr &amp;operator--(); //递增</div><div class="line">    StrBlobPtr operator++(int i); //递增</div><div class="line">    StrBlobPtr operator--(int i); //递增</div><div class="line">private:</div><div class="line">    //检查vector是否被释放，索引是否合法</div><div class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; check(size_t sz, const string &amp;msg) const;</div><div class="line">    weak_ptr&lt;vector&lt;string&gt;&gt; wptr; //一个弱指针</div><div class="line">    size_t curr; //位置</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//返回一个指向第一个元素的StrBlobPtr</div><div class="line">StrBlobPtr StrBlob::begin()</div><div class="line">&#123;</div><div class="line">    return StrBlobPtr(*this);</div><div class="line">&#125;</div><div class="line">//最后一个元素后一个位置</div><div class="line">StrBlobPtr StrBlob::end()</div><div class="line">&#123;</div><div class="line">    auto ret = StrBlobPtr(*this, data -&gt; size());</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">shared_ptr&lt;vector&lt;string&gt;&gt; </div><div class="line">StrBlobPtr::check(size_t sz, const string &amp;msg) const</div><div class="line">&#123;</div><div class="line">    auto ret = wptr.lock(); //如果不存在返回空</div><div class="line">    if (!ret)</div><div class="line">        throw runtime_error(&quot;unbond StrBlob&quot;);</div><div class="line">    if (sz &gt;= ret -&gt; size())</div><div class="line">        throw out_of_range(msg);</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//解引用</div><div class="line">string &amp;StrBlobPtr::operator*() const</div><div class="line">&#123;</div><div class="line">    auto p = check(curr, &quot;dereference past end&quot;); //检查索引</div><div class="line">    return (*p) [curr]; //取vector元素</div><div class="line">&#125;</div><div class="line">string *StrBlobPtr::operator-&gt;() const</div><div class="line">&#123;</div><div class="line">    return &amp; this -&gt; operator*(); //返回解引用结果的地址</div><div class="line">&#125;</div><div class="line"></div><div class="line">//前置版本</div><div class="line">StrBlobPtr &amp;StrBlobPtr::operator++()</div><div class="line">&#123;</div><div class="line">    check(curr, &quot;increment past end of StrBlobPtr&quot;); //检查索引</div><div class="line">    ++curr; //自增移动</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line">StrBlobPtr &amp;StrBlobPtr::operator--()</div><div class="line">&#123;</div><div class="line">    --curr;//自减移动，如果为0，产生无效下标</div><div class="line">    check(curr, &quot;increment past end of StrBlobPtr&quot;); //检查索引</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//后置版本用一个不被使用的 int 形参与前置版本区分</div><div class="line">//后置版本返回的值应该与之前的值保持一致</div><div class="line">//返回的是值，而不是引用</div><div class="line">StrBlobPtr StrBlobPtr::operator++(int i)</div><div class="line">&#123;</div><div class="line">    StrBlobPtr ret = *this;</div><div class="line">    ++*this; //自增移动</div><div class="line">    return ret; //返回原值</div><div class="line">&#125;</div><div class="line">StrBlobPtr StrBlobPtr::operator--(int i)</div><div class="line">&#123;</div><div class="line">    StrBlobPtr ret = *this;</div><div class="line">    --*this;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    StrBlob b&#123;&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;&#125;;</div><div class="line">    StrBlobPtr bp = b.begin(), be = b.end();</div><div class="line">    cout &lt;&lt; *bp++ &lt;&lt; endl; //a</div><div class="line">    cout &lt;&lt; *++bp &lt;&lt; endl;//aaa</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p>15.3</p>
<p>定义一个基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class myquote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    myquote() = default;</div><div class="line">    myquote(const std::string &amp;bookname, double source_price) :</div><div class="line">        name(bookname), price(source_price) &#123;&#125;</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    //需要派生类自己定义的函数声明为虚函数</div><div class="line">    virtual double getprice() const &#123;return price;&#125;</div><div class="line">    virtual ~myquote() = default; //基类需要定义一个虚解析函数</div><div class="line">private: //私有成员，用户和派生类都不能访问</div><div class="line">    std::string name;</div><div class="line">protected: // 受保护的成员，派生类可以访问，用户不能访问</div><div class="line">    double price;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义一个打印函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//这里的mq可以是基类或者派生类</div><div class="line">void print_total(ostream &amp;os, MyQuote &amp;mq, size_t num)</div><div class="line">&#123;</div><div class="line">    double total_price = mq.getprice() * num;</div><div class="line">    os &lt;&lt; mq.getname() &lt;&lt; &quot; : &quot; &lt;&lt; total_price &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>15.5</p>
<p>定义一个派生类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class CutQuote : public MyQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    CutQuote() = default;</div><div class="line">    CutQuote(const std::string &amp;bookname, double source_price, int cut) : </div><div class="line">        MyQuote(bookname, source_price), discount(cut) &#123;&#125;</div><div class="line">    double getprice() const override &#123;return price/discount;&#125; //重写虚函数</div><div class="line">private:</div><div class="line">    int discount; //新增数据成员表示折扣</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>15.11</p>
<p>定义一个输出成员值的debug()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class MyQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //....</div><div class="line">    virtual void debug()</div><div class="line">    &#123; //输出自己的元素</div><div class="line">        std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; std::endl </div><div class="line">            &lt;&lt; &quot;price : &quot; &lt;&lt; price &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">//...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class CutQuote : public MyQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //....</div><div class="line">    void debug()</div><div class="line">    &#123; //显式调用基类的debug函数，否则会陷入无限递归</div><div class="line">        MyQuote::debug(); </div><div class="line">        std::cout &lt;&lt; &quot;discount : &quot; &lt;&lt; discount &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">//...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>15.15</p>
<p>抽象基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class MyQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    MyQuote() = default;</div><div class="line">    MyQuote(const std::string &amp;bookname, double source_price) :</div><div class="line">        name(bookname), price(source_price) &#123;&#125;</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    virtual double getprice() const &#123;return price;&#125;</div><div class="line">    virtual ~MyQuote() = default;</div><div class="line">private: //私有成员，用户和派生类都不能访问</div><div class="line">    std::string name;</div><div class="line">protected: // 受保护的成员，派生类可以访问，用户不能访问</div><div class="line">    double price;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//继承基类的抽象基类</div><div class="line">class DiscQuote : public MyQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    DiscQuote() = default;</div><div class="line">    DiscQuote(const std::string &amp;bookname, double source_price, int cut) : </div><div class="line">        MyQuote(bookname, source_price), discount(cut) &#123;&#125;</div><div class="line">    double getprice() const = 0; //声明为纯虚函数</div><div class="line">protected:</div><div class="line">    int discount; //新增数据成员表示折扣</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//从抽象基类继承</div><div class="line">class CutQuote : public DiscQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    CutQuote() = default;</div><div class="line">    CutQuote(const std::string &amp;bookname, double source_price, int cut) :</div><div class="line">        DiscQuote(bookname, source_price, cut) &#123;&#125;</div><div class="line">    //覆盖抽象基类的getprice()函数</div><div class="line">    double getprice() const override &#123;return price/discount;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void print_total(std::ostream &amp;os, MyQuote &amp;mq, std::size_t num);</div></pre></td></tr></table></figure>
<h2 id="构造函数和派生类"><a href="#构造函数和派生类" class="headerlink" title="构造函数和派生类"></a>构造函数和派生类</h2><p>15.26</p>
<p>定义拷贝构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">class MyQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    MyQuote() = default;</div><div class="line">    MyQuote(const std::string &amp;bookname, double source_price) :</div><div class="line">        name(bookname), price(source_price) &#123;&#125;</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    MyQuote(const MyQuote &amp;mq) : name(mq.name), price(mq.price)</div><div class="line">    &#123; //输出表示调用这个拷贝构造函数</div><div class="line">        std::cout &lt;&lt; &quot;MyQuote&apos;s copy..&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    virtual double getprice() const &#123;return price;&#125;</div><div class="line">    virtual ~MyQuote() = default;</div><div class="line">private: //私有成员，用户和派生类都不能访问</div><div class="line">    std::string name;</div><div class="line">protected: // 受保护的成员，派生类可以访问，用户不能访问</div><div class="line">    double price;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class DiscQuote : public MyQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    DiscQuote() = default;</div><div class="line">    DiscQuote(const std::string &amp;bookname, double source_price, int cut) : </div><div class="line">        MyQuote(bookname, source_price), discount(cut) &#123;&#125;</div><div class="line">    //先调用基类拷贝构造，然后构造自己的成员</div><div class="line">    DiscQuote(const DiscQuote &amp;dq) : MyQuote(dq), discount(dq.discount)</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;DiscQuote&apos;s copy..&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    double getprice() const = 0; //声明为纯虚函数</div><div class="line">protected:</div><div class="line">    int discount; //新增数据成员表示折扣</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class CutQuote : public DiscQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    CutQuote() = default;</div><div class="line">    CutQuote(const std::string &amp;bookname, double source_price, int cut) :</div><div class="line">        DiscQuote(bookname, source_price, cut) &#123;&#125;</div><div class="line">    // 不用构造自己的成员，向上调用</div><div class="line">    CutQuote(const CutQuote &amp;cq) : DiscQuote(cq)</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;CutQuote&apos;s copy&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    double getprice() const override &#123;return price/discount;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void print_total(std::ostream &amp;os, MyQuote &amp;mq, std::size_t num);</div><div class="line"></div><div class="line">//在主文件调用</div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    CutQuote q1(&quot;hello world&quot;, 10, 3);</div><div class="line">    CutQuote  q2(q1);</div><div class="line">    print_total(cout, q2, 1);</div><div class="line">    /*</div><div class="line">        输出说明是自顶而下的构造</div><div class="line">        MyQuote&apos;s copy..</div><div class="line">        DiscQuote&apos;s copy..</div><div class="line">        CutQuote&apos;s copy</div><div class="line">        hello world : 3.33333</div><div class="line">    */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>15.27</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class CutQuote : public DiscQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using DiscQuote::DiscQuote; //继承DiscQuote的构造函数</div><div class="line">    double getprice() const override &#123;return price/discount;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="容器和继承"><a href="#容器和继承" class="headerlink" title="容器和继承"></a>容器和继承</h2><p>15.28</p>
<p>如果在基类类型容器放置派生类对象，派生类那部分会被切掉<br>因此，在容器中放置（智能）指针而不是对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    CutQuote q1(&quot;hello world&quot;, 10, 3);</div><div class="line">    MyQuote q2(&quot;hello world&quot;, 10);</div><div class="line">    vector&lt;shared_ptr&lt;MyQuote&gt;&gt; basket;</div><div class="line">    //派生类的智能指针隐式转化为基类智能指针</div><div class="line">    basket.push_back(make_shared&lt;CutQuote&gt;(q1));</div><div class="line">    basket.push_back(make_shared&lt;MyQuote&gt;(q2)); </div><div class="line">    for(auto i : basket)</div><div class="line">    &#123;</div><div class="line">        print_total(cout, *i, 1);</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">        输出：</div><div class="line">        hello world : 3.33333</div><div class="line">        hello world : 10</div><div class="line">    */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>15.30</p>
<p>编写一个Basket类<br>如果要改变add_item的接口，直接传入对象，让类自己判断调用什么拷贝方式<br>需要创建虚拟拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">class MyQuote</div><div class="line">&#123;</div><div class="line">//...</div><div class="line">    //虚拟拷贝，在程序运行的时候觉得调用哪个类的拷贝函数</div><div class="line">    //左值，返回基类指针</div><div class="line">    virtual MyQuote *clone() const &amp; &#123;return new MyQuote(*this);&#125; </div><div class="line">    //右值，基类指针</div><div class="line">    virtual MyQuote *clone() &amp;&amp; &#123;return new MyQuote(std::move(*this));&#125; </div><div class="line">//...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class CutQuote : public DiscQuote</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using DiscQuote::DiscQuote;</div><div class="line">    //左值，派生类指针</div><div class="line">    CutQuote *clone() const &amp; &#123;return new CutQuote(*this);&#125;</div><div class="line">    //右值，派生类指针</div><div class="line">    CutQuote *clone() &amp;&amp; &#123;return new CutQuote(std::move(*this));&#125;</div><div class="line">    double getprice() const override &#123;return price/discount;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Basket</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void add_item(const MyQuote &amp;mq)</div><div class="line">    &#123; //添加到容器内</div><div class="line">        items.push_back(std::shared_ptr&lt;MyQuote&gt;(mq.clone()));</div><div class="line">    &#125;</div><div class="line">    void add_item(MyQuote &amp;&amp;mq)</div><div class="line">    &#123; //尽管参数是右值，mq本身却是个左值，所以需要再次调用move</div><div class="line">        items.push_back(std::shared_ptr&lt;MyQuote&gt;(std::move(mq).clone()));</div><div class="line">    &#125;</div><div class="line">    double total_price()</div><div class="line">    &#123; //遍历求和</div><div class="line">        double sum(0.0);</div><div class="line">        for(auto i : items)</div><div class="line">        &#123;</div><div class="line">            sum += i -&gt; getprice();</div><div class="line">        &#125;</div><div class="line">        return sum;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    //存放指针的容器</div><div class="line">    std::vector&lt;std::shared_ptr&lt;MyQuote&gt;&gt; items;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    CutQuote q1(&quot;hello world&quot;, 10, 3);</div><div class="line">    MyQuote q2(&quot;hello world&quot;, 10);</div><div class="line">    Basket bk;</div><div class="line">    bk.add_item(q1);</div><div class="line">    bk.add_item(q2);</div><div class="line">    cout &lt;&lt; bk.total_price() &lt;&lt; endl; //13.3333</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>15.39</p>
<p>文件查询程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div></pre></td><td class="code"><pre><div class="line">#ifndef MYSEARCH_H</div><div class="line">#define MYSEARCH_H</div><div class="line"></div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line"></div><div class="line">#include &quot;mysearch.h&quot;</div><div class="line"></div><div class="line">class QueryResult;</div><div class="line">class TextQuery</div><div class="line">&#123;</div><div class="line">friend class QueryResult;</div><div class="line">public:</div><div class="line">    TextQuery(std::ifstream &amp;infile);</div><div class="line">    QueryResult query(std::string s) const;</div><div class="line">private:</div><div class="line">   std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; ifile; //指向存放每行文本的vector</div><div class="line">    std::map&lt;std::string, std::shared_ptr&lt;std::set&lt;int&gt;&gt;&gt; wm; //单词到存放行数的set的映射</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class QueryResult</div><div class="line">&#123;</div><div class="line">friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const QueryResult &amp;qr);</div><div class="line">public:</div><div class="line">    QueryResult(std::string s, std::shared_ptr&lt;std::set&lt;int&gt;&gt; lp, std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; fp) : </div><div class="line">        world(s), linep(lp), file(fp)&#123;&#125;</div><div class="line">    std::set&lt;int&gt;::iterator begin()</div><div class="line">    &#123;</div><div class="line">        return linep -&gt; begin();</div><div class="line">    &#125;</div><div class="line">    std::set&lt;int&gt;::iterator end()</div><div class="line">    &#123;</div><div class="line">        return linep -&gt; end();</div><div class="line">    &#125;</div><div class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; &amp;get_file()</div><div class="line">    &#123;</div><div class="line">        return file;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    std::string world;</div><div class="line">    std::shared_ptr&lt;std::set&lt;int&gt;&gt; linep;</div><div class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//构造函数，在构造函数里储存将单词到行号的隐射</div><div class="line">TextQuery::TextQuery(std::ifstream &amp;infile) : ifile(new std::vector&lt;std::string&gt;) //初始化infile</div><div class="line">&#123;</div><div class="line">    std::string s,world;</div><div class="line">    int num(0);</div><div class="line">    while(getline(infile, s))</div><div class="line">    &#123;</div><div class="line">        ++num;</div><div class="line">        ifile -&gt; push_back(s);</div><div class="line">        std::istringstream line(s);</div><div class="line">        while(line &gt;&gt; world)</div><div class="line">        &#123;</div><div class="line">            if(!wm[world]) //如果set还没有创建</div><div class="line">                wm[world].reset(new std::set&lt;int&gt;); //创建一个set</div><div class="line">            wm[world] -&gt; insert(num); //行号插入到set</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//查找</div><div class="line">//返回一个QueryResult类</div><div class="line">QueryResult TextQuery::query(std::string s) const</div><div class="line">&#123;</div><div class="line">    std::shared_ptr&lt;std::set&lt;int&gt;&gt; nodata(new std::set&lt;int&gt;); //一个空set</div><div class="line">    auto res = wm.find(s); //查找函数的本体，查找map对应字符串的行号set</div><div class="line">    if (res == wm.end()) //无内容返回空set</div><div class="line">        return QueryResult(s, nodata, ifile);</div><div class="line">    else //有内容返回set，访问map 的 second成员</div><div class="line">        return QueryResult(s, res -&gt; second, ifile);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//用&lt;&lt;操作符打印QueryResult的内容</div><div class="line">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const QueryResult &amp;qr)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; qr.world &lt;&lt; &quot;: \n&quot;;</div><div class="line">    for (auto num:*qr.linep) //对每个指针解引用然后遍历</div><div class="line">    &#123;</div><div class="line">        os &lt;&lt; num &lt;&lt; &quot; &quot;; //行号</div><div class="line">        os &lt;&lt; *(qr.file -&gt; begin() + num - 1) &lt;&lt; &quot;\n&quot;; //用迭代器输出vector的行文本</div><div class="line">    &#125;</div><div class="line">    return os;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//一个抽象基类，继承查询类型</div><div class="line">class Query_base</div><div class="line">&#123;</div><div class="line">friend class Query;</div><div class="line">protected:</div><div class="line">    virtual ~Query_base() = default;</div><div class="line">private:</div><div class="line">    virtual QueryResult eval(const TextQuery &amp;t) const = 0;</div><div class="line">    virtual std::string rep() const = 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Query</div><div class="line">&#123;</div><div class="line">friend Query operator~(const Query &amp;q);</div><div class="line">friend Query operator&amp;(const Query &amp;q1, const Query &amp;q2);</div><div class="line">friend Query operator|(const Query &amp;q1, const Query &amp;q2);</div><div class="line">public:</div><div class="line">    //构造一个WordQuery</div><div class="line">    Query(const std::string &amp;s);</div><div class="line">    QueryResult eval(const TextQuery &amp;t) const</div><div class="line">    &#123;</div><div class="line">        return q -&gt; eval(t); //虚调用</div><div class="line">    &#125;</div><div class="line">    std::string rep() const</div><div class="line">    &#123;</div><div class="line">        return q -&gt; rep(); //虚调用</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    Query(std::shared_ptr&lt;Query_base&gt; sq) : q(sq) &#123;&#125;</div><div class="line">    std::shared_ptr&lt;Query_base&gt; q;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"> //继承查询基类</div><div class="line">class WordQuery : public Query_base</div><div class="line">&#123;</div><div class="line">    //默认都是私有成员，由友元Query（用户借口类）访问</div><div class="line">    friend class Query;</div><div class="line">    //保存要查询的词</div><div class="line">    WordQuery(const std::string &amp;s) : query_world(s) &#123;&#125;</div><div class="line">    QueryResult eval(const TextQuery &amp;t) const override</div><div class="line">    &#123;</div><div class="line">        return t.query(query_world); </div><div class="line">    &#125;</div><div class="line">    std::string rep() const override &#123;return query_world;&#125;</div><div class="line">    std::string query_world; //查询的词</div><div class="line">&#125;;</div><div class="line"></div><div class="line">inline</div><div class="line">Query::Query(const std::string &amp;s) : q(new WordQuery(s)) &#123;&#125;</div><div class="line"></div><div class="line">class NotQuery : public Query_base</div><div class="line">&#123;</div><div class="line">    friend Query operator~(const Query  &amp;q);</div><div class="line">    NotQuery(const Query &amp;q) : query(q) &#123;&#125;;</div><div class="line">    std::string rep() const override</div><div class="line">    &#123; //输出要查询的词，附带~符号和括号</div><div class="line">        return &quot;~(&quot; + query.rep() + &quot;)&quot;; </div><div class="line">    &#125;</div><div class="line">    QueryResult eval(const TextQuery &amp;t) const override;</div><div class="line">    Query query; //保存传递的query参数</div><div class="line">&#125;;</div><div class="line"></div><div class="line">inline</div><div class="line">Query operator~(const Query &amp;q)</div><div class="line">&#123;//返回一个shared_ptr</div><div class="line">    return std::shared_ptr&lt;Query_base&gt; (new NotQuery(q));</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BinaryQuery : public Query_base</div><div class="line">&#123;</div><div class="line">protected:</div><div class="line">    BinaryQuery(const Query &amp;l, const Query &amp;r, std::string s) : </div><div class="line">        lq(l), rq(r), ops(s) &#123;&#125;</div><div class="line">    std::string rep() const override</div><div class="line">    &#123; //输出查找的词和符号</div><div class="line">        return &quot;(&quot; + lq.rep() + &quot; &quot; </div><div class="line">            + ops + &quot; &quot; </div><div class="line">            + rq.rep() + &quot;)&quot;;</div><div class="line">    &#125;</div><div class="line">    //没有覆盖eval()，仍是抽象基类</div><div class="line">    Query lq, rq; //左右操作数</div><div class="line">    std::string ops; //运算符</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//&amp;运算和|运算相似</div><div class="line">class AndQuery : public BinaryQuery</div><div class="line">&#123;</div><div class="line">    friend Query operator&amp;(const Query &amp;q1, const Query &amp;q2);</div><div class="line">    AndQuery(const Query &amp;q1, const Query &amp;a2) : </div><div class="line">        BinaryQuery(q1, a2, &quot;&amp;&quot;) &#123;&#125;</div><div class="line">    QueryResult eval(const TextQuery &amp;t) const;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">inline</div><div class="line">Query operator&amp;(const   Query &amp;q1,const Query &amp;q2)</div><div class="line">&#123;</div><div class="line">    return std::shared_ptr&lt;Query_base&gt; (new AndQuery(q1, q2));</div><div class="line">&#125;</div><div class="line"></div><div class="line">class OrQuery : public BinaryQuery</div><div class="line">&#123;</div><div class="line">    friend Query operator|(const Query &amp;q1, const Query &amp;q2);</div><div class="line">    OrQuery(const Query &amp;q1, const Query &amp;a2) : </div><div class="line">        BinaryQuery(q1, a2, &quot;|&quot;) &#123;&#125;</div><div class="line">    QueryResult eval(const TextQuery &amp;t) const;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">inline</div><div class="line">Query operator|(const   Query &amp;q1,const Query &amp;q2)</div><div class="line">&#123;</div><div class="line">    return std::shared_ptr&lt;Query_base&gt; (new OrQuery(q1, q2));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &apos;|&apos; 操作</div><div class="line">QueryResult</div><div class="line">OrQuery::eval(const TextQuery &amp;t) const</div><div class="line">&#123;</div><div class="line">    QueryResult lqr = lq.eval(t), rqr = rq.eval(t);</div><div class="line">    //左QueryResult的行号or上右QueryResult行号</div><div class="line">    auto ret_lines = std::make_shared&lt;std::set&lt;int&gt;&gt;(lqr.begin(), lqr.end());</div><div class="line">    ret_lines -&gt; insert(rqr.begin(), rqr.end());</div><div class="line">    //初始化一个新QueryResult</div><div class="line">    return QueryResult(rep(), ret_lines, lqr.get_file());</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &apos;&amp;&apos;操作</div><div class="line">QueryResult</div><div class="line">AndQuery::eval(const TextQuery &amp;t) const</div><div class="line">&#123;</div><div class="line">    QueryResult lqr = lq.eval(t), rqr = rq.eval(t);</div><div class="line">    //一个指向空set的指针</div><div class="line">    auto ret_lines = std::make_shared&lt;std::set&lt;int&gt;&gt;();</div><div class="line">    ret_lines -&gt; insert(rqr.begin(), rqr.end());</div><div class="line">    //使用标准库算法求并集</div><div class="line">    set_intersection(lqr.begin(), lqr.end(),</div><div class="line">            rqr.begin(), rqr.end(),</div><div class="line">            inserter(*ret_lines, ret_lines -&gt; begin()));</div><div class="line">    return QueryResult(rep(), ret_lines, lqr.get_file());</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &apos;~&apos;操作</div><div class="line">QueryResult</div><div class="line">NotQuery::eval(const TextQuery &amp;t) const</div><div class="line">&#123;</div><div class="line">    QueryResult qr = query.eval(t);</div><div class="line">    //一个指向空set的指针</div><div class="line">    auto ret_lines = std::make_shared&lt;std::set&lt;int&gt;&gt;();</div><div class="line">    auto qrb = qr.begin(), qre = qr.end();</div><div class="line">    auto sz = qr.get_file() -&gt; size();</div><div class="line">    for (auto n = 0; n != sz; ++n)</div><div class="line">    &#123;</div><div class="line">        if (*qrb != n + 1)</div><div class="line">            //如果行号不在查询结果里面，插入到set中</div><div class="line">            ret_lines -&gt; insert(n+1);</div><div class="line">        else if(qrb != qre)</div><div class="line">            ++qrb;</div><div class="line">    &#125;</div><div class="line">    return QueryResult(rep(), ret_lines, qr.get_file());</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line"></div><div class="line">//主函数调用</div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    ifstream infile(&quot;text.txt&quot;);</div><div class="line">    TextQuery tq(infile);</div><div class="line">    auto res = Query(&quot;harry&quot;) &amp; Query(&quot;my&quot;) | ~Query(&quot;haha&quot;);</div><div class="line">    cout &lt;&lt; res.eval(tq);</div><div class="line">/*</div><div class="line">    ((harry &amp; my) | ~(haha)): </div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    ..</div><div class="line">*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>16.19</p>
<p>输出容器内容的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">void my_print(const vector&lt;T&gt; &amp;ve)</div><div class="line">&#123;</div><div class="line">    //typename指定成员类型</div><div class="line">    typename vector&lt;T&gt;::size_type sz = ve.size(), i;</div><div class="line">    for(i=0; i != sz; ++i)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; ve[i];</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    vector&lt;int&gt; vec=&#123;1,2,3,4,5,6&#125;;</div><div class="line">    my_print(vec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>16.20</p>
<p>使用迭代器的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">void my_print(const vector&lt;T&gt; &amp;ve)</div><div class="line">&#123;</div><div class="line">    typename vector&lt;T&gt;::const_iterator bg = ve.begin(), be = ve.end();</div><div class="line">    while(bg != be)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *bg++;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    vector&lt;int&gt; vec=&#123;1,2,3,4,5,6&#125;;</div><div class="line">    my_print(vec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一个版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;</div><div class="line">ostream  &amp;my_print(ostream &amp;os, const T &amp;ve)</div><div class="line">&#123;</div><div class="line">    typename T::const_iterator bg = ve.begin(), be = ve.end();</div><div class="line">    while(bg != be)</div><div class="line">    &#123;</div><div class="line">        os &lt;&lt; *bg++;</div><div class="line">    &#125;</div><div class="line">    return os;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    vector&lt;int&gt; vec=&#123;1,2,3,4,5,6&#125;;</div><div class="line">    my_print(cout, vec) &lt;&lt; endl;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/26/C3/" data-id="cj5c7k37r0009m0u4q47el5wy" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-deploy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/05/deploy/" class="article-date">
  <time datetime="2016-11-05T11:08:13.000Z" itemprop="datePublished">2016-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/05/deploy/">flask部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="uwsgi配置"><a href="#uwsgi配置" class="headerlink" title="uwsgi配置"></a>uwsgi配置</h1><p>保存为<code>config.ini</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[uwsgi]</div><div class="line"></div><div class="line">socket = 127.0.0.1:8001</div><div class="line"></div><div class="line">chdir = /home/ubuntu/myblog</div><div class="line"></div><div class="line">wsgi-file = manage.py</div><div class="line"></div><div class="line">callable = app</div><div class="line"></div><div class="line">processes = 4</div><div class="line"></div><div class="line">threads = 2</div><div class="line"></div><div class="line">stats = 127.0.0.1:9191</div></pre></td></tr></table></figure>
<p>启动：<code>uwsgi config.ini</code></p>
<p>配置文件<code>/etc/supervisor/conf.d/myblog_supervisor.conf</code></p>
<h1 id="supervisor配置"><a href="#supervisor配置" class="headerlink" title="supervisor配置"></a>supervisor配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[program:myblog]</div><div class="line"></div><div class="line">command=uwsgi /home/ubuntu/myblog/config.ini</div><div class="line"></div><div class="line">directory=/home/ubuntu/myblog</div><div class="line"></div><div class="line">user=ubuntu</div><div class="line"></div><div class="line">autostart=true</div><div class="line">autorestart=true</div><div class="line"></div><div class="line">stdout_logfile=/home/ubuntu/myblog/logs/uwsgi_supervisor.log</div></pre></td></tr></table></figure>
<p>启动：<code>service supervisor  start</code></p>
<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><p>配置文件<code>/etc/nginx/sites-enabled/default</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line">        listen 80;</div><div class="line">        server_name xxx.xxx.xxx.xxx;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">                include uwsgi_params;</div><div class="line">                uwsgi_pass 127.0.0.1:8001;</div><div class="line">                uwsgi_param UWSGI_PYHOME /home/ubuntu/myblog/venv;</div><div class="line">                uwsgi_param UWSGI_CHDIR /home/ubuntu/myblog;</div><div class="line">                uwsgi_param UWSGI_SCRIPT manage:app;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/05/deploy/" data-id="cj5c7k389000mm0u4v33xsbrv" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask/">flask</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-basic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/23/basic/" class="article-date">
  <time datetime="2016-10-23T03:05:49.000Z" itemprop="datePublished">2016-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/23/basic/">数据结构和算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="冒泡排序（bubble-sort）"><a href="#冒泡排序（bubble-sort）" class="headerlink" title="冒泡排序（bubble sort）"></a>冒泡排序（bubble sort）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">do</div><div class="line">  swapped = false</div><div class="line">  for i = 1 to indexOfLastUnsortedElement</div><div class="line">    if leftElement &gt; rightElement</div><div class="line">      swap(leftElement, rightElement)</div><div class="line">      swapped = true; swapCounter++</div><div class="line">while swapped</div></pre></td></tr></table></figure>
<h1 id="二叉堆（binary-heap）"><a href="#二叉堆（binary-heap）" class="headerlink" title="二叉堆（binary heap）"></a>二叉堆（binary heap）</h1><p><a href="https://visualgo.net/heap" target="_blank" rel="external">演示</a></p>
<p>create，N</p>
<p>给定树，构建成二叉堆，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (i = A.length/2; i &gt;= 1; i--)</div><div class="line">  shiftDown(i)</div></pre></td></tr></table></figure>
<p>insert，logN</p>
<p>插入一个元素，循环将这个元素和父元素比较，然后上虑（percolate up）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A[A.length] = v</div><div class="line">i = A.length-1</div><div class="line">while (i &gt; 1 &amp;&amp; A[parent(i)] &lt; A[i])</div><div class="line">  swap(A[i], A[parent(i)])</div></pre></td></tr></table></figure>
<p>extract max，logN</p>
<p>弹出根元素（假设是最大值），将最后一个元素放到根位置，然后这个元素和最大的子元素比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">take out A[1]</div><div class="line">A[1] = A[A.length-1]</div><div class="line">i = 1; A.length--</div><div class="line">while (i &lt; A.length)</div><div class="line">  if A[i] &lt; (L = the larger of i&apos;s children)</div><div class="line">    swap(A[i], L)</div></pre></td></tr></table></figure>
<h1 id="查找树"><a href="#查找树" class="headerlink" title="查找树"></a>查找树</h1><p>存放树元素的结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct node</div><div class="line">&#123;</div><div class="line">    int element;</div><div class="line">    node *right;</div><div class="line">    node *left;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>插入元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">node *insert(node *tree, int val)</div><div class="line">&#123;</div><div class="line">    if(tree == nullptr)</div><div class="line">    &#123;</div><div class="line">        tree = new node;</div><div class="line">        tree -&gt; element = val;</div><div class="line">        tree -&gt; right = nullptr;</div><div class="line">        tree -&gt; left = nullptr;</div><div class="line">    &#125;</div><div class="line">    else if(val &gt; tree -&gt; element)</div><div class="line">        tree -&gt; right insert(tree -&gt; right, val);</div><div class="line">    else if(val &lt; tree -&gt; element)</div><div class="line">        tree -&gt; left insert(tree -&gt; left, val);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>搜索元素，返回节点指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">node *searchVal(node *tree, int val)</div><div class="line">&#123;</div><div class="line">    if(tree == nullptr)</div><div class="line">        return nullptr;</div><div class="line">    if(val &gt; tree -&gt; element)</div><div class="line">        return searchVal(tree -&gt; right, val);</div><div class="line">    else if(val &lt; tree -&gt; element)</div><div class="line">        return searchVal(tree -&gt; left, val);</div><div class="line">    else</div><div class="line">        return tree;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找最小值，返回节点指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">node *findMin(node *tree)</div><div class="line">&#123;</div><div class="line">    if(tree == nullptr)</div><div class="line">        return nullptr;</div><div class="line">    else if(tree -&gt; left == nullptr)</div><div class="line">        return tree;</div><div class="line">    else</div><div class="line">        return findMin(tree -&gt; left);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">node *deleteVal(node *tree, int val)</div><div class="line">&#123;</div><div class="line">    if(tree == nullptr)</div><div class="line">        return nullptr;</div><div class="line">    else if(val &gt; tree -&gt; element)</div><div class="line">        tree -&gt; right deleteVal(tree -&gt; right, val);</div><div class="line">    else if(val &lt; tree -&gt; element)</div><div class="line">        tree -&gt; left deleteVal(tree -&gt; left, val);</div><div class="line">    else if(tree -&gt; left != nullptr &amp;&amp; tree -&gt; right != nullptr)</div><div class="line">    &#123;</div><div class="line">        node *tmpnode = findMin(tree -&gt; right);</div><div class="line">        tree -&gt; element = tmpnode -&gt; element;</div><div class="line">        tree -&gt; right deleteVal(tree -&gt; right, tmpnode -&gt; element);</div><div class="line">    &#125;</div><div class="line">    else </div><div class="line">    &#123;</div><div class="line">        node *tmpnode = tree;</div><div class="line">        if(tree -&gt; left == nullptr)</div><div class="line">            tree = tree -&gt; right;</div><div class="line">        else if(tree -&gt; right == nullptr)</div><div class="line">            tree = tree -&gt; left;</div><div class="line">        delete tmpnode;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p><a href="https://visualgo.net/bst" target="_blank" rel="external">演示</a></p>
<p>AVL（Adelson-Velskill Landis）树是带有平衡条件的二叉查找树</p>
<p>findMax，logN</p>
<p>递归查找，同理，最小值就是一直往左</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if this is null return empty</div><div class="line">if right != null</div><div class="line">  go right</div><div class="line">else return this key</div></pre></td></tr></table></figure>
<p>search，logN</p>
<p>递归查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if this == null</div><div class="line">  return null</div><div class="line">else if this key == search value</div><div class="line">  return this</div><div class="line">else if this key &lt; search value</div><div class="line">  search right</div><div class="line">else search left</div></pre></td></tr></table></figure>
<p>insert，插入元素</p>
<p>插入元素之后需要检查是否平衡，如果左右子树高度相差2则不平衡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">insert v</div><div class="line">check balance factor of this and its children</div><div class="line">  case1: this.rotateRight</div><div class="line">  case2: this.left.rotateLeft, this.rotateRight</div><div class="line">  case3: this.rotateLeft</div><div class="line">  case4: this.right.rotateRight, this.rotateLeft</div><div class="line">  this is balanced</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/23/basic/" data-id="cj5c7k2rf0003m0u4c0siprp7" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/basic/">basic</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/18/C2/" class="article-date">
  <time datetime="2016-10-18T11:08:13.000Z" itemprop="datePublished">2016-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/18/C2/">C++ Primer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h1><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><ul>
<li>IO对象不可复制或赋值</li>
<li>不能储存在容器中</li>
<li>形参和返回类型不能为流类型</li>
<li>IO操作通常以引用方式传递和返回流</li>
<li>读写IO对象会改变其状态，所以不能是const引用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ofstream &amp;print(ofstream&amp;); //引用</div><div class="line">while (print(out2))&#123;..&#125;</div></pre></td></tr></table></figure>
<p>getline用于逐行读取，保留空格，不保存空格</p>
<ul>
<li><code>badbit</code> 标志着系统级故障</li>
<li><code>failbit</code> 标志者可恢复错误</li>
<li><code>eofbit</code> 遇到文件结束符</li>
</ul>
<p>如果达到文件结束位置，eofbit和failbit都会被置位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">string i;</div><div class="line">while(cin&gt;&gt;i) //每次读取一个单词，读取到文件结束符退出循环</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行clear()之后，复位所有标志位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">string i,j;</div><div class="line">while(cin &gt;&gt; j)</div><div class="line">&#123;</div><div class="line">    while(cin &gt;&gt; i) //如果这里输入文件结束符</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    cin.clear(); //复位标志位，因此不会退出循环</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>输出操作可能不直接输出到屏幕，而是先存入缓冲区</li>
<li>如果程序异常终止，缓冲区不会被刷新</li>
<li>可以手动刷新缓冲区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cout &lt;&lt; &quot;asd&quot; &lt;&lt; endl; //换行、刷新缓冲区</div><div class="line">cout &lt;&lt; &quot;sad&quot; &lt;&lt; flush; //刷新缓冲区</div><div class="line">cout &lt;&lt; &quot;dsa&quot; &lt;&lt; ends; //空格、刷新缓冲区</div><div class="line">cout &lt;&lt; unitbuf; //后面的所有操作都会立即刷新缓冲区</div><div class="line">//...</div><div class="line">cout &lt;&lt; nounitbuf; //回到正常的缓冲方式</div></pre></td></tr></table></figure>
<p>关联输入和输出流，任何读取操作都会先刷新输出流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cin.tie(nullptr); //cin绑定为空指针</div><div class="line">ostream *old_tie = cin.tie(&amp;cout); //cin绑定cout返回一个指向cout的指针</div></pre></td></tr></table></figure>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>文件流对象的创建和绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//定义文件对象</div><div class="line">ifstream infile;</div><div class="line">ofstream outfile;</div><div class="line">fstream f;</div><div class="line"></div><div class="line">//捆绑文件</div><div class="line">infile.open(&quot;in.txt&quot;);</div><div class="line">outfile.open(&quot;out.txt&quot;);</div><div class="line">f.open(&quot;text.txt&quot;)</div><div class="line"></div><div class="line">//直接初始化</div><div class="line">ifstream infile(&quot;in.txt&quot;);</div><div class="line">fstream f(&quot;text.txt&quot;)</div><div class="line"></div><div class="line">//检查文件是否成功打开</div><div class="line">if (!infile)&#123;.... return -1&#125;</div><div class="line"></div><div class="line">//重新捆绑需要先关闭文件</div><div class="line">ifstream infile(&quot;in.txt&quot;);</div><div class="line">infile.close(); //关闭文件</div><div class="line">infile.open(&quot;another.txt&quot;);</div><div class="line"></div><div class="line">//清除状态</div><div class="line">//一旦文件流发生错误，必须通过clear()方法清除状态，否则会影响后续该对象的使用</div><div class="line">infile.clear();</div><div class="line"></div><div class="line">//指定模式打开文件</div><div class="line">ofstream outfile(&quot;text.txt&quot;, ofstream::out | ofstream::trunc);</div></pre></td></tr></table></figure>
<p>确认成功读取文件之后再操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">string s;</div><div class="line">fstream f(&quot;text.txt&quot;);</div><div class="line">if (f)</div><div class="line">&#123;</div><div class="line">    while(getline(f,s))</div><div class="line">        cout &lt;&lt; s &lt;&lt; endl;</div><div class="line">    f.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><ul>
<li>只可以对ofstream或者fstream对象设置为out</li>
<li>只可以对ifstream或者fstream对象设置为in</li>
<li>只有当设置了out才能设置trunc，默认out + trunc</li>
<li>ofstream默认out，ifstream默认in，fstream默认in + out</li>
<li>ofstream默认会清空，除非制定app模式 </li>
</ul>
<h2 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h2><p>在sstream头文件中定义</p>
<p>istringstream 从string读取数据<br>ostringstream 向string写入数据<br>stringstream 读取或者写入数据</p>
<p>方法</p>
<ul>
<li><code>sstream.str()</code> 返回sstream保存的string的拷贝</li>
<li><code>sstream.str(s)</code> 将string s拷贝到sstream中</li>
</ul>
<p>使用istringstream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">string line,word;</div><div class="line">getline(cin, line); //得到一个以空格隔开的字符串</div><div class="line">istringstream s(line); //将字符串与s绑定</div><div class="line">while(s &gt;&gt; word) //逐个输出空格隔开的单词</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; word &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用ostringstream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ostringstream words;</div><div class="line">string s;</div><div class="line">while(cin &gt;&gt; s) //输入的数据空格隔开，逐个存到words字符串流</div><div class="line">&#123;</div><div class="line">    words &lt;&lt; s &lt;&lt; &quot;;&quot;;</div><div class="line">&#125;</div><div class="line">cout &lt;&lt; words.str() &lt;&lt; endl; //输出所有内容</div></pre></td></tr></table></figure>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>P292</p>
<p><code>vector</code> 可变大小数组，尾部插入速度快（push_back）<br><code>deque</code> 双端队列，头尾插入速度快（push_front、push_back）<br><code>list</code> 双向链表，任何位置插入速度都很快，占用空间大<br><code>forward_list</code> 单向链表<br><code>array</code> 固定大小数组，不能添加或者删除元素<br><code>string</code> 字符串，尾部插入速度快</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>P305</p>
<ul>
<li>同类型容器，同类型元素可以直接用于初始化</li>
<li>如果使用迭代器初始化，可以是不同容器类型，不同元素类型（如果能进行转换）</li>
<li>同容器同元素可以直接用于赋值</li>
<li>swap交换除了array以外的顺序容器速度很快，因为只交换了数据结构，元素本身不变</li>
<li>只有相同容器类型，相同元素类型可以比较大小</li>
<li>array定义时需要指定大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//初始化为：1234560000</div><div class="line">array&lt;int, 10&gt; a = &#123;1,2,3,4,5,6&#125;;</div></pre></td></tr></table></figure>
<p>assign赋值</p>
<p>赋值操作需要左右两边类型相同，顺序容器（除了array）定义了assign成员，允许不同但是相容的类型赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vector&lt;const char*&gt; vc=&#123;&quot;asdasd&quot;, &quot;asdasd&quot;&#125;;</div><div class="line">list&lt;string&gt; vs;</div><div class="line">vs.assign(vc.begin(), vc.end());</div></pre></td></tr></table></figure>
<p>insert插入元素</p>
<p>第一个参数是一个迭代器，后面可以接收更多参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; iv;</div><div class="line">iv.insert(iv.begin(),10,2); //在开头插入10个2</div><div class="line">iv.insert(iv.end(),&#123;1,2,3,4,5,6,7&#125;); //在最后插入1234567</div><div class="line">list&lt;int&gt; ls&#123;1,2,3,4,5&#125;;</div><div class="line">iv.insert(iv.end(), ls.begin(), ls.end()); //使用迭代器插入</div></pre></td></tr></table></figure>
<p>insert的返回值</p>
<p>C++11 insert返回一个迭代器<br>但是linux用的g++并不能，折腾好久，坑，好想早点换电脑装VS - -</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto tp = iv.insert(iv.begin(),100); //如果是插入一个元素，返回插入的元素的迭代器</div><div class="line">cout &lt;&lt; *tp &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>emplace将参数传递给构造函数，使用构造函数构造元素</p>
<p><code>emplace_back</code>、<code>emplace</code>、<code>emplace_front</code><br>对应<br><code>push_back</code>、<code>insert</code>、<code>push_front</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vector&lt;Sales_data&gt; vsd;</div><div class="line">vsd.emplace_back(&quot;hello&quot;, 2, 1);</div></pre></td></tr></table></figure>
<p><code>front</code>和<code>back</code>（除了forward_list）成员函数，返回第一个和最后一个元素值</p>
<p>at（string、vector、deque和array）使用下标返回元素的引用，越界抛出out_of_range异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;Sales_data&gt; vsd;</div><div class="line">vsd.emplace_back(&quot;hello&quot;, 2, 1);</div><div class="line">auto s = vsd.at(0); //第一个元素的引用</div><div class="line">auto &amp;s = vsd.front(); //和上面的等价</div></pre></td></tr></table></figure>
<p>删除元素<br><code>pop_back</code>、<code>erase</code>（返回被删除元素之后的元素的迭代器）、<code>pop_front</code><br>对应<br><code>push_back</code>、<code>insert</code>、<code>push_front</code></p>
<ul>
<li>删除deque中的首尾外的元素，会使所有迭代器、引用、指针失效</li>
<li>指向vector、string中删除点之后的位置的迭代器、引用、指针失效</li>
<li>vector不支持push_front</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vector&lt;Sales_data&gt; vsd;</div><div class="line">vsd.insert(vsd.begin(), 10, Sales_data(&quot;world&quot;,3,2)); //插入是个元素</div><div class="line"> //删除一半元素，p指向被删除的最后一个元素的下一个元素</div><div class="line">auto p = vsd.erase(vsd.begin(),vsd.begin() + vsd.size()/2);</div><div class="line">//删除所有元素，下面两个等价</div><div class="line">vsd.erase(vsd.begin(),vsd.end());</div><div class="line">vsd.clear()</div></pre></td></tr></table></figure>
<p>forward_list拥有特殊的访问操作（操作实现方式不同），没有insert、emplace、erase操作（P313）</p>
<ul>
<li><code>before_begin()</code>、<code>cbefore_begin()</code> 首元素前一个位置的迭代器</li>
<li><code>insert_after</code> 在某迭代器后插入</li>
<li><code>emplace_after</code> 在某迭代器后插入，使用构造函数构造</li>
<li><code>erase_after</code> 删除某迭代器后元素</li>
</ul>
<p>删除<code>forward_list&lt;int&gt;</code>里面的奇数元素 ，关键在于保存要删除元素的前一项的迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">forward_list&lt;int&gt; fvi&#123;1,2,3,4,5,6,7,1,2,4&#125;;</div><div class="line">auto fp = fvi.begin(); //第一个元素</div><div class="line">auto pre = fvi.before_begin(); //第一个元素的前一个元素</div><div class="line">while(fp != fvi.end())</div><div class="line">&#123;</div><div class="line">    if (*fp%2 != 0)</div><div class="line">    &#123;</div><div class="line">        fp = fvi.erase_after(pre); /删除值为奇数的元素，fp为下个元素的迭代器</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        //两个迭代器都向后移动</div><div class="line">        ++fp; </div><div class="line">        ++pre;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>resize用于改变容器大小（array除外）</p>
<p><code>c.resize(n)</code> 调整大小为n<br><code>c.resize(n, t)</code> 调整大小为n，如果需要添加元素，则添加t</p>
<h2 id="容器对象实现"><a href="#容器对象实现" class="headerlink" title="容器对象实现"></a>容器对象实现</h2><ul>
<li>vector将元素连续存储，每个元素紧挨着前一个元素存储</li>
<li>当需要获取新的内存空间时，vector和string的实现通常会分配比新的空间需求大的空间</li>
<li><code>c.capacity()</code>不重新分配内存空间的话，可以容纳的元素数量</li>
<li><code>c.reserve(n)</code>分配至少容纳n个元素的空间</li>
</ul>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>除了通用的构造方式外，string还支持下标方式构造函数</p>
<ul>
<li><code>string s(cp, n)</code> 数组cp的前n个元素（其实就是字符，下同）</li>
<li><code>string s(s2, p)</code> string s2 下标p开始的元素</li>
<li><code>string s(s2, p, n)</code> string s2 下标p开始的n个元素</li>
</ul>
<p>substr 返回一个string（类似切片）</p>
<ul>
<li>如果只有一个参数，获取整个字符串</li>
<li>如果有两个参数，第一个参数是开始位置，第二个参数是拷贝的字符数</li>
<li>如果第一个参数超过范围，会抛出out_of_range异常</li>
<li>如果第二个参数超过范围，substr会调整数值，只拷贝到string末尾</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">string s(&quot;hello world!&quot;);</div><div class="line">cout &lt;&lt; s.substr(0, 5) &lt;&lt; endl; //输出hello</div><div class="line">cout &lt;&lt; s.substr(0, 1) &lt;&lt; endl; //输出h</div><div class="line">cout &lt;&lt; s.substr(0, s.size()) &lt;&lt; endl; //输出整个字符串</div><div class="line">cout &lt;&lt; s.substr(0) &lt;&lt; endl; //输出整个字符串</div></pre></td></tr></table></figure>
<p><code>insert</code> 和 <code>erase</code> 可以用下标代替迭代器（P323）</p>
<p><code>append</code> 在末尾插入元素（可以不止一个字符）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.append(&quot;welcome!&quot;);</div></pre></td></tr></table></figure>
<p><code>replace</code> 是调用erase和insert的一种简写形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string s(&quot;hello world!&quot;);</div><div class="line">s.replace(6, 6, &quot;harry!&quot;); //从第6个开始，删除6个元素，插入&quot;harry!&quot;</div><div class="line">cout &lt;&lt; s &lt;&lt; endl; //输出 hello harry!</div></pre></td></tr></table></figure>
<p>使用<code>substr</code>和<code>replace</code>实现字符串的替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void fun(string &amp;s, const string &amp;oldstr, const string &amp;newstr)</div><div class="line">&#123;</div><div class="line">    string::size_type n = 0;</div><div class="line">    while(n != s.size())</div><div class="line">    &#123;</div><div class="line">        if (s.substr(n, oldstr.size()) == oldstr)</div><div class="line">        &#123;</div><div class="line">            s.replace(n, oldstr.size(), newstr);</div><div class="line">            n += oldstr.size();</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            ++n;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    string s(&quot;hello world!&quot;);</div><div class="line">    fun(s, &quot;world&quot;, &quot;harryx&quot;);</div><div class="line">    cout &lt;&lt; s &lt;&lt; endl; 输出：hello harryx!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>string 搜索操作</p>
<ul>
<li>搜索成功返回一个<code>string:size_type</code>的下标</li>
<li>搜索失败返回<code>string:npos</code>，（无符号类型-1，相当于非常大）</li>
<li>区分大小写</li>
<li>除了一个字符或者字符串或者指针参数，还可以添加一个位置参数，表示搜索开始的位置，默认0</li>
<li>或者添加两个参数<code>(cp, pos, n)</code>，从字符串中位置pos开始，查找指针cp指向的数组的前n个字符</li>
<li><code>rfind</code>逆向搜索</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">string s(&quot;hello world!&quot;);</div><div class="line">auto p1 = s.find(&quot;o&quot;); //p1等于4</div><div class="line">auto p2 = s.find_first_of(&quot;abcde&quot;); //p2等于1</div><div class="line">auto p3 = s.find_last_of(&quot;abcde&quot;); //p3等于10</div><div class="line">auto p4 = s.find_first_not_of(&quot;abcde&quot;); //p4等于0</div><div class="line">auto p5 = s.find_last_not_of(&quot;abcde&quot;); //p5等于11</div><div class="line">cout &lt;&lt; p &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p><code>compare</code>比较</p>
<ul>
<li><code>s.compare(s2)</code> s和s2比较</li>
<li><code>s.compare(pos, n, s2)</code> s中的pos开始的n个字符和s2比较</li>
<li><code>s.compare(pos1, n1, s2, pos2, n2)</code> s中pos1开始的n1个字符和s2中pos2开始的n2个字符比较</li>
<li><code>s.compare(cp)</code> s和cp指向的c风格字符串比较</li>
<li><code>s.compare(pos, n, cp)</code></li>
<li><code>s.compare(pos1, n1, cp, n2)</code></li>
</ul>
<p>数值转换</p>
<p>to_string(val) 数值转换为字符串<br><code>stoi(s, p, b)</code> 字符串转换为各种类型，b为基数，默认10<br><code>stol(s, p, b)</code> p是指针，保存s中第一个非数值字符下标，默认0<br><code>stoul(s, p, b)</code><br><code>stoll(s, p, b)</code><br><code>stoull(s, p, b)</code><br><code>stof(s, p)</code><br><code>stod(s, p)</code><br><code>stold(s, p)</code></p>
<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>P367</p>
<ul>
<li>大多数泛型算法都定义在头文件 <code>algorithm</code> 中</li>
<li>迭代器使得算法不依赖于容器</li>
<li>泛型算法不会直接改变容器大小</li>
<li>向目的位置迭代器写入数据的泛型算法假定目标容量足够大，否则结果是未定义的</li>
<li><code>fill_n</code>需要目标容器具有足够大的元素空间<code>resize</code>，不仅仅是空间<code>reserve</code></li>
</ul>
<h2 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h2><p><code>find</code>算法，前两个参数是迭代器或者指针，第三个参数是一个值<br>类似的还有<code>count</code>算法，计算某个元素出现次数<br><code>fill(v.begin(), v.end(), 0)</code>写入元素，要注意容器的容量大小<br><code>fill_n(v.begin(), 10, 1)</code> 写入多个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//查找vector中的某个元素，返回一个迭代器</div><div class="line">vector&lt;int&gt; vi&#123;1,2,3,4,5&#125;;</div><div class="line">auto res = find(vi.begin(), vi.end(), 3);</div><div class="line">cout &lt;&lt; *res &lt;&lt; endl;</div><div class="line"></div><div class="line">//查找数组中的某个元素，返回一个指针</div><div class="line">int ia[] = &#123;1,2,3,4,5,6,7,7&#125;;</div><div class="line">auto res = find(begin(ia), end(ia), 4);</div><div class="line">cout &lt;&lt; *res &lt;&lt; endl;</div></pre></td></tr></table></figure>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p><code>back_inserter</code> 插入迭代器，定义在<code>iterator</code>头文件，<br>接收一个指向容器的引用，返回一个绑定的插入迭代器<br>插入元素，并且不会出现容器不够大的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; vi; //空的容器</div><div class="line">auto it = back_inserter(vi); //绑定插入迭代器</div><div class="line">*it = 20; //插入一个 20</div></pre></td></tr></table></figure>
<p>将插入迭代器<code>back_inserter</code>和<code>fill_n</code>结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; vi;</div><div class="line">fill_n(back_inserter(vi), 10, 2 ); //添加 10 个 2</div></pre></td></tr></table></figure>
<p>copy 拷贝容器的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a[] = &#123;1,2,3,4,5&#125;;</div><div class="line">//获取数组大小然后定义一个同样大小的空数组</div><div class="line">int b[sizeof(a)/sizeof(*a)];</div><div class="line">auto ret = copy(begin(a), end(a), b); //拷贝，ret指向b的end()</div></pre></td></tr></table></figure>
<p>将插入迭代器<code>back_inserter</code>和<code>copy</code>结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list&lt;int&gt; ii&#123;1,2,3,4,5&#125;;</div><div class="line">vector&lt;int&gt; vi;</div><div class="line">copy(ii.begin(), ii.end(), back_inserter(vi));</div></pre></td></tr></table></figure>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>可以向泛型算法传递函数参数，使用指定方式操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sort(v.begin(), v.end(), isShorter);使用制定函数isShorter进行排序</div></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda 表达式形式</p>
<p>捕获列表是lambda所在函数中定义的局部变量的列表，通常为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123;函数体&#125;</div></pre></td></tr></table></figure>
<p>如果忽略返回类型，lambda根据代码推断出返回类型<br>但是必须有捕获列表和函数体<br>忽略参数列表和返回类型的lambda表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto f = [] &#123;return 10;&#125;;</div><div class="line">cout &lt;&lt; f() &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto f = [](int i, int j) &#123;return i + j;&#125;;</div><div class="line">cout &lt;&lt; f(1, 2) &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>捕获参数</p>
<ul>
<li>如果需要使用函数中的变量，lambda必须在捕获列表中指明</li>
<li>捕获列表只能用于局部非static变量</li>
<li>lambda可以直接使用局部static变量和所在函数外声明的名字</li>
<li>捕获的值在捕获时拷贝</li>
<li>可以捕获引用，必须确保在lambda执行时，引用变量是存在的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 100, b = 200;</div><div class="line">//捕获a和b</div><div class="line">auto f = [a, b](int i, int j) &#123;return i + j + a + b;&#125;;</div></pre></td></tr></table></figure>
<p>隐式捕获</p>
<p>在捕获列表中可以只写一个&amp;或者=，代表引用或者值捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 100, b = 200;</div><div class="line">//使用一个=符号，表示值捕获</div><div class="line">auto f = [=](int i, int j) &#123;return i + j + a + b;&#125;;</div></pre></td></tr></table></figure>
<p>混合捕获</p>
<ul>
<li>使用混合捕获时，第一个捕获的变量必须是&amp;或者=</li>
<li>显示捕获的变量必须使用与隐式捕获不同的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a = 100, &amp;b = a;</div><div class="line">auto f = [=, &amp;b](int i, int j) &#123;return i + j + a + b;&#125;;</div></pre></td></tr></table></figure>
<p>可变lambda</p>
<p>如果希望改变捕获的变量的值，需要加一个关键字mutable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a = 100;</div><div class="line">//如果没有mutable关键字会报错，原捕获的变量是只读的</div><div class="line">auto f = [a]() mutable &#123;return ++a;&#125;;</div><div class="line">a = 0;</div><div class="line">auto res = f(); //res=101，a=0，值在创建时拷贝，且不会改变原值</div></pre></td></tr></table></figure>
<p>指定返回类型</p>
<p>如果有多个return语句，需要指定返回类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto f = [](int a) -&gt; int </div><div class="line">    &#123;if(a%2==0) return a;else return 0;&#125;;</div><div class="line">auto j = f(2);</div></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><ul>
<li><code>bind</code>函数可以绑定函数的参数，在头文件<code>functional</code>中</li>
<li>占位符<code>_n</code>在<code>std::placeholders</code>命名空间中，n表示第一个参数</li>
<li>不能拷贝ostream或者其他引用参数，只能使用<code>ref</code>传递<code>bind(fun, ref(os), _1, 100)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int addnum(int i, int j)</div><div class="line">&#123;</div><div class="line">    return i+j;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    //_1是一个占位符，给定参数1，生成新的可调用对象addone</div><div class="line">    auto addone = bind(addnum, placeholders::_1, 1);</div><div class="line">    cout &lt;&lt; addone(1) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>在头文件<code>iterator</code>中定义了额外的几个迭代器</p>
<ul>
<li>插入迭代器（insert），绑定到一个容器，执行插入操作</li>
<li>流迭代器（stream），绑定到输入输出流，可以遍历所有IO流</li>
<li>反向迭代器（reverse），向前移动的迭代器</li>
<li>移动迭代器（move），不拷贝元素，而是移动</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>接受一个容器，生成一个迭代器，能实现向给定容器添加元素</p>
<p><code>it = t</code> 在 it 制定的当前位置插入值 t，根据选择的迭代器的不同调用方法<br><code>*it, ++it, it++</code> 这些操作虽然存在，不会做任何事，每个操作都返回 It</p>
<ul>
<li><code>back_inserter</code>创建一个使用<code>push_back</code>的迭代器</li>
<li><code>front_inserter</code>创建一个使用<code>push_front</code>的迭代器</li>
<li><code>inserter</code> 创建一个使用insert的迭代器，此函数接受第二个参数，是一个指向给定容器的迭代器，元素被插入到给定迭代器之前</li>
</ul>
<p>只有在容器支持某个操作时才能使用对应迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; vec;</div><div class="line">auto it = inserter(vec, vec.end());</div><div class="line">*it = 10; //在尾部插入一个10</div></pre></td></tr></table></figure>
<p>使用front_inserter倒过来拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list&lt;int&gt; a&#123;1,2,3,4&#125;;</div><div class="line">list&lt;int&gt; b;</div><div class="line">//b为4,3,2,1</div><div class="line">copy(a.begin(), a.end(), front_inserter(b));</div></pre></td></tr></table></figure>
<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><ul>
<li><code>istream_iterator</code>读取输入流</li>
<li><code>ostream_iterator</code>向输出流写数据</li>
</ul>
<h4 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a>istream_iterator操作</h4><ul>
<li><code>istream_iterator</code>可以绑定一个输入流，可以是cin或者一个文件流</li>
<li><code>*in, ++in, in++</code>读取值、读取下一个值和读取并移动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//绑定cin，接受整数输入，如果接受到错误输入，迭代器和尾后迭代器相等</div><div class="line">istream_iterator&lt;int&gt; int_it(cin), eof;</div><div class="line">//eof为空迭代器，作为尾后迭代器</div><div class="line">//使用输入的数字初始化vec</div><div class="line">vector&lt;int&gt; vec(int_it, eof);</div><div class="line"></div><div class="line">//同理，使用文件流</div><div class="line">ifstream f(&quot;text.txt&quot;);</div><div class="line">istream_iterator&lt;string&gt; str_it(f), eof;</div><div class="line">vector&lt;string&gt; vec(str_it, eof);</div></pre></td></tr></table></figure>
<h4 id="ostream-iterator操作"><a href="#ostream-iterator操作" class="headerlink" title="ostream_iterator操作"></a>ostream_iterator操作</h4><ul>
<li><code>ostream_iterator</code>可以提供第二个参数，一个C风格字符串，每个元素后都会打印这个字符串</li>
<li>只要对象有<code>&lt;&lt;</code>操作，都可以绑定ostream_iterator</li>
<li><code>out = val</code>使用<code>&lt;&lt;</code>操作，将val写入到out</li>
<li><code>out++,++out,*out</code>操作存在，但是不做任何事</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; vec&#123;1,2,3,4,5&#125;;</div><div class="line">ostream_iterator&lt;int&gt; out_it(cout, &quot;\n&quot;);</div><div class="line">//通过copy输出元素</div><div class="line">copy(vec.begin(), vec.end(), out_it);//输出12345</div></pre></td></tr></table></figure>
<p>将一个文件里面的数字按照奇偶性分别写到两个文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//打开文件</div><div class="line">fstream in(&quot;text.txt&quot;);</div><div class="line">fstream out1(&quot;out1.txt&quot;, ofstream::out);</div><div class="line">fstream out2(&quot;out2.txt&quot;, ofstream::out);</div><div class="line">//绑定流</div><div class="line">istream_iterator&lt;int&gt; in_it(in), eof;</div><div class="line">ostream_iterator&lt;int&gt; out_it1(out1, &quot; &quot;);</div><div class="line">ostream_iterator&lt;int&gt; out_it2(out2, &quot; &quot;);</div><div class="line">//逐个写入</div><div class="line">while(in_it != eof)</div><div class="line">&#123;</div><div class="line">    if ((*in_it) % 2 == 0)</div><div class="line">        out_it1 = *in_it++;</div><div class="line">    else</div><div class="line">        out_it2 = *in_it++;</div><div class="line">&#125;</div><div class="line">//关闭文件</div><div class="line">in.close();</div><div class="line">out1.close();</div><div class="line">out2.close();</div></pre></td></tr></table></figure>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>P364</p>
<ul>
<li>除了forward_list，其他容器都支持反向迭代器<code>reverse_iterator</code></li>
<li><code>v.rbegin()</code>是最后一个元素，<code>v.rend()</code>是第一个元素的前一个位置</li>
</ul>
<p>反向打印vector的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vector&lt;string&gt; vec&#123;&quot;hello&quot;,&quot;world&quot;,&quot;byebye&quot;&#125;;</div><div class="line">ostream_iterator&lt;string&gt; out_it(cout, &quot;,&quot;);</div><div class="line">copy(vec.rbegin(),vec.rend(), out_it);//输出：byebye,world,hello</div></pre></td></tr></table></figure>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>map（保存键-值对）和multimap（关键字可重复出现的map）定义在头文件map中<br>set（保存关键字）和multiset（关键字可重复出现的set）定义在头文件set中<br>无序容器定义在头文件unordered_map和unordered_set中</p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><ul>
<li>关联容器不支持顺序容器中位置相关的操作，比如push_front、push_back</li>
<li>初始化map必须提供关键字和值的类型</li>
<li>map和set关键字必须唯一，multimap和multiset没有此限制</li>
</ul>
<p>范围for从map中提取的元素是个pair类型对象<br>pair是个模板类型，保存first、second公有数据成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">map&lt;string, size_t&gt; word_count;</div><div class="line">++word_count[&quot;harryx&quot;];</div><div class="line">cout &lt;&lt; word_count[&quot;harryx&quot;] &lt;&lt; endl; //输出1</div><div class="line">for (auto w:word_count)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; w.first &lt;&lt; w.second &lt;&lt; endl;//输出harryx1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>set用于检测某个值是否存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set&lt;string&gt; extr&#123;&quot;fuck&quot;, &quot;shit&quot;&#125;;</div><div class="line">string word;</div><div class="line">while(cin &gt;&gt; word)</div><div class="line">&#123;</div><div class="line">    if(extr.find(word) == extr.end())</div><div class="line">        cout &lt;&lt; word &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键字类型的要求</p>
<ul>
<li>有序容器（map、set、multimap、multiset）的关键字必须定义元素的比较方法</li>
<li>可以指定自定义的比较方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//自定义比较函数</div><div class="line">bool compareSD(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    return sd1.avg_price() &lt; sd2.avg_price();</div><div class="line">&#125;</div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    //两个自定义类型的实例</div><div class="line">    Sales_data sd1&#123;&quot;hello&quot;,2,2&#125;,sd2&#123;&quot;asd&quot;,3,3&#125;;</div><div class="line">    //第一个关键字是类类型，如果是map，第二个关键字是值，第三个是函数指针</div><div class="line">    //第二个关键字是个函数指针（用decltype获取函数类型，加上*号制定为指针）</div><div class="line">    //  函数指针相当于bool (*)(const Sales_data &amp;, const Sales_data &amp;)</div><div class="line">    //用compareSD初始化bookstore对象，添加元素时用compareSD排序</div><div class="line">    set&lt;Sales_data, decltype(compareSD)*&gt; bookstore(compareSD);</div><div class="line">    //赋值</div><div class="line">    bookstore = &#123;sd1,sd2&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h2><ul>
<li>定义在头文件<code>utility</code>中</li>
<li>保存两个数据成员，类似容器，是一个用来生成特定类型的模板</li>
<li>两个数据成员可以是不同类型</li>
<li>pair的数据称原是public的，分别命名为first和second</li>
</ul>
<p><code>pair&lt;string, size_t&gt; asam{&quot;harryx&quot;, 20};</code></p>
<p>操作</p>
<ul>
<li><code>make_pair(v1, v2)</code> 返回一个用v1和v2初始化的pair，自动推导类型</li>
<li>同类型比较大小，先比较first再比较second</li>
</ul>
<p>构造一个pair的函数</p>
<ul>
<li>返回vec的最后一个元素作为first，大小作为second</li>
<li>如果vec为空，返回一个默认构造值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">pair&lt;string, int&gt;</div><div class="line">process(vector&lt;string&gt; &amp;vec)</div><div class="line">&#123;</div><div class="line">    if(!vec.empty())</div><div class="line">        //较早版本需要显式构造值</div><div class="line">        //return pair&lt;string, int&gt;(vec.back(), vec.size());</div><div class="line">        return &#123;vec.back(), vec.size()&#125;;</div><div class="line">    else</div><div class="line">        return pair&lt;string, int&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    vector&lt;string&gt; vec&#123;&quot;asd&quot;,&quot;dsa&quot;,&quot;sad&quot;&#125;;</div><div class="line">    pair&lt;string, int&gt; p;</div><div class="line">    p = process(vec);</div><div class="line">    cout &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second &lt;&lt; endl;//输出：sad 3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读取string和int 的序列，作为pair保存在vector中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    vector&lt;pair&lt;string, int&gt;&gt; vec;</div><div class="line">    istringstream ist;</div><div class="line">    string line, word;</div><div class="line">    int num;</div><div class="line">    //读取空格相隔的string 和int 流</div><div class="line">    while(getline(cin, line))</div><div class="line">    &#123;</div><div class="line">        //字符串流绑定</div><div class="line">        ist.str(line);</div><div class="line">        //先读取一个字符</div><div class="line">        while(ist &gt;&gt; word)</div><div class="line">        &#123;</div><div class="line">            //尝试读取后面的数字，如果出错就提醒</div><div class="line">            if(ist &gt;&gt; num)</div><div class="line">            &#123;</div><div class="line">                vec.push_back(pair&lt;string, int&gt;(word, num));</div><div class="line">                cout &lt;&lt; &quot;Ok!Now store &quot; &lt;&lt; word &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl;</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">                &#123;</div><div class="line">                    cout &lt;&lt; word &lt;&lt; &quot; bad input&quot; &lt;&lt; endl;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        //清除错误标记</div><div class="line">        ist.clear();</div><div class="line">    &#125;</div><div class="line">    //输出</div><div class="line">    for (auto p:vec)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second &lt;&lt;  endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>除了一般的容器操作，关联容器定义了额外的类型别名</p>
<ul>
<li><code>key_type</code> 容器的关键字的类型</li>
<li><code>mapped_type</code> 只适用与map，每个关键字所关联的类型</li>
<li><code>value_type</code> 对于set，与key_type相同，对于map，为pair<const key_type,="" mapped_type=""></const></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">set&lt;string&gt;::key_type v1;//v1是string 类型</div><div class="line">set&lt;string&gt;::value_type v2;//v2同样是string类型</div><div class="line">map&lt;string, int&gt;::key_type v3;//v3是string类型</div><div class="line">map&lt;string, int&gt;::mapped_type v4;//v4是int类型</div><div class="line">map&lt;string, int&gt;::value_type v5;//v5是pair&lt;const string, int&gt;类型</div></pre></td></tr></table></figure>
<h3 id="关联容器的迭代器"><a href="#关联容器的迭代器" class="headerlink" title="关联容器的迭代器"></a>关联容器的迭代器</h3><ul>
<li>map和set类型都支持begin和end操作，可以通过迭代器遍历容器</li>
<li>解引用关联容器的迭代器，会得到一个类型为容器的<code>value_type</code>的值的引用</li>
<li>可以通过迭代器改变容器的second的值，但不能改变first的值</li>
<li>set的迭代器是只读的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map&lt;string, int&gt; m(&#123;&quot;a&quot;, 1&#125;, &#123;&quot;b&quot;, 2&#125;, &#123;&quot;c&quot;, 3&#125;);</div><div class="line">auto mp = m.begin();</div><div class="line">//mp 是pair&lt;const string, int&gt;的引用</div><div class="line">cout &lt;&lt; mp -&gt; first;</div><div class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; mp -&gt; second;</div></pre></td></tr></table></figure>
<ul>
<li>关联容器一般不使用泛型算法</li>
<li>如果对关联容器使用算法，一般作为源序列或者目的位置</li>
<li>关联容器没有push_back()操作，所以不能使用back_inserter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; vec&#123;1,2,3,4,5,6,7,8,9&#125;;</div><div class="line">multiset&lt;int&gt; mus&#123;1,2,3&#125;;</div><div class="line">//把vec的元素插入到mus中</div><div class="line">copy(vec.begin(), vec.end(), inserter(mus, mus.end()));</div><div class="line">//因为是顺序搜索，输出1,1,2,2,3,3,4,5,6,7,8,9</div><div class="line">for(auto s:mus)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ul>
<li>关联容器的<code>insert</code>成员向容器中添加元素，类似的还有<code>emplace</code></li>
<li>向map和set插入已经存在的元素对容器没有影响</li>
<li>map的元素类型是pair</li>
</ul>
<p>向set添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; vec&#123;1,2,3&#125;;</div><div class="line">set&lt;int&gt; se&#123;1,2&#125;;</div><div class="line">se.insert(vec.begin(), vec.end());//1,2,3</div><div class="line">se.insert(&#123;4,5,6&#125;);//1,2,3,4,5,6</div></pre></td></tr></table></figure>
<p>向map添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map&lt;string, int&gt; m;</div><div class="line">m.insert(&#123;&quot;asd&quot;, 1&#125;);</div><div class="line">m.insert(make_pair(&quot;sdf&quot;, 2));</div><div class="line">m.insert(pair&lt;string, int&gt;(&quot;dfg&quot;, 3));</div><div class="line">m.insert(map&lt;string, int&gt;::value_type(&quot;gfh&quot;, 4));</div></pre></td></tr></table></figure>
<ul>
<li>添加单一元素的insert返回一个pair</li>
<li>如果插入成功，first是指向容器中关键字的迭代器，second是一个bool值，如果关键词存在，bool为false</li>
<li>如果是允许重复的关联容器，first指向的是新元素的迭代器</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li>erase删除一个元素，返回删除的元素的数量，元素不重复的容器返回0或1</li>
<li><p>关联容器的元素按照比较顺序存储</p>
</li>
<li><p>c.erase(k) 删除关键字k</p>
</li>
<li>c.erase(p) 删除迭代器p指定的元素</li>
<li>c.erase(b, e) 删除迭代器b，e范围的元素</li>
</ul>
<h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><ul>
<li><code>set</code>类型不支持下标，因为元素就是关键字</li>
<li><code>map</code>和<code>unordered_map</code>可以使用下标</li>
<li><code>multimap</code>和<code>unordered_multimap</code>不支持下标，因为可能有多个值对应一个元素</li>
<li>使用一个不存在的元素作为下标，会添加一个元素到容器中</li>
<li>对一个<code>map</code>进行下标操作会返回一个<code>mapped_type</code>对象，而解引用<code>map</code>迭代器会获得<code>value_type</code>对象</li>
</ul>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><ul>
<li><code>c.find(k)</code> 如果存在元素k，返回一个迭代器指向k，否则返回一个迭代器指向c.end()</li>
<li><code>c.count(k)</code> 如果存在，返回元素的个数，否则返回0</li>
<li><code>c.lower_bound(k)</code> 返回一个迭代器，指向第一个关键字不小于k的元素</li>
<li><code>c.upper_bound(k)</code> 返回一个迭代器，指向第一个关键字大于k的元素</li>
<li><code>c.equal_range(k)</code> 返回一个迭代器pair，表示关键字等于k的元素的范围，若不存在，pair两个成员都为c.end()</li>
<li><code>lower_bound</code>和<code>upper_bound</code>都不适用于无序容器</li>
<li>因为是顺序存储，<code>lower_bound</code>和<code>upper_bound</code>可以用于访问可重复关联容器的某个元素</li>
</ul>
<p>使用equal_range访问可重复关联容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">multimap&lt;string, int&gt; s(&#123;&quot;asd&quot;, 1&#125;, &#123;&quot;qwe&quot;, 2&#125;, &#123;&quot;asd&quot;, 2&#125;);</div><div class="line">for (auto pos = s.equal_range(&quot;asd&quot;); pos.first != pos.second; ++pos.first)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; pos.first -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; pos.first -&gt; second &lt;&lt; endl;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>P395</p>
<ul>
<li>无序容器不是使用比较运算符来组织元素，而是使用哈希函数（hash function）和关键字类型的==运算符</li>
<li>提供了与有序容器相同的操作（find，insert等），遍历的顺序也是无序的</li>
<li>无序容器在存储上组织为一组桶</li>
</ul>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p><code>new</code> 分配内存 <code>delete</code> 释放内存</p>
<p>使用动态内存的原因：</p>
<ul>
<li>程序不知道需要多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>C++11标准提供了两种智能指针来管理动态对象，外加一个伴随类，定义在头文件<code>memory</code>中：</p>
<ul>
<li><code>shared_ptr</code>允许多个指针指向同一对象</li>
<li><code>unique_ptr</code>“独占”所指对象</li>
<li><code>weak_ptr</code>弱引用，指向shared_ptr所管理的对象</li>
</ul>
<p>P401</p>
<p><code>shared_ptr</code>和<code>unique_ptr</code></p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>如果不初始化一个智能指针，会被初始化为一个空指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shared_ptr&lt;string&gt; p;//一个空指针</div></pre></td></tr></table></figure>
<p>操作<br>P401</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p.get(); //返回一个普通指针</div><div class="line">p.unique();//是否唯一</div><div class="line">p.reset(); //如果p是唯一指向其对象的指针，释放</div><div class="line">p.reset(q); //q是内置指针，令p指向q，否则将p置空</div><div class="line">p.reset(q, d); //调用自定义方法d释放q</div></pre></td></tr></table></figure>
<p>初始化后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    shared_ptr&lt;string&gt; p = make_shared&lt;string&gt;();//使用make_shared初始化智能指针，指向空string</div><div class="line">    if (p &amp;&amp; p -&gt; empty()) //如果指针不为空，并且指向一个空string</div><div class="line">    &#123;</div><div class="line">        *p = &quot;hello&quot;; //解引用赋值</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; *p &lt;&lt; endl; //输出hello</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>make_shared</code>在动态内存中分配一个对象并初始化它<br>初始化方式类似<code>emplace</code>，传入参数用于初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shared_ptr&lt;string&gt; p = make_shared&lt;string&gt;(&quot;hello&quot;);</div></pre></td></tr></table></figure>
<p>使用<code>auto</code>简化定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto p = make_shared&lt;string&gt;(&quot;asd&quot;);</div></pre></td></tr></table></figure>
<p>结合使用shared_ptr和new</p>
<p>用于初始化智能指针的指针必须是动态内存，因为智能指针默认使用delete释放对象</p>
<p>如果使用自定义其他类型指针上，需要自定义释放操作</p>
<p>一旦用指向动态内存的指针初始化智能指针，之前的指针就被释放为空悬指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shared_ptr&lt;string&gt; p(new string(&quot;hello&quot;));//初始化完，默认调用delete释放动态分配的内存</div></pre></td></tr></table></figure>
<ul>
<li><code>shared_ptr</code>使用拷贝方式或者初始化方式赋值，都会使引用计数数递增</li>
<li>赋值新值或是被销毁会使引用计数递减，一旦计数器变为0，自动释放管理的对象</li>
<li><code>shared_ptr</code>通过<strong>析构函数</strong>完成销毁工作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = q;</div><div class="line">auto p(q);</div></pre></td></tr></table></figure>
<p>自定义释放操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void fun(dest &amp;d)</div><div class="line">&#123;</div><div class="line">    connection c = connect(d);</div><div class="line">    //自定义释放操作end_connection</div><div class="line">    shared_ptr&lt;connection&gt; p(c, end_connection);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他操作</p>
<p>shared_ptr通过reset更新对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.reset(new string(&quot;a new string&quot;));</div></pre></td></tr></table></figure>
<p>配合unique操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!p.unique()) //如果不是唯一用户</div><div class="line">    p.reset(new string(*p)); //分配新的拷贝</div><div class="line">*p += newval; //改变对象值</div></pre></td></tr></table></figure>
<p>共享底层数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class StrBlob</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    typedef vector&lt;string&gt;::size_type size_type;</div><div class="line">    //构造函数</div><div class="line">    StrBlob():data(make_shared&lt;vector&lt;string&gt;&gt;())&#123;&#125;</div><div class="line">    StrBlob(initializer_list&lt;string&gt; ils)://多个字符串参数</div><div class="line">        data(make_shared&lt;vector&lt;string&gt;&gt;(ils)) &#123;&#125;</div><div class="line">    //成员函数</div><div class="line">    size_type size() const &#123;return data -&gt; size();&#125;</div><div class="line">    bool empty() const &#123;return data -&gt; empty();&#125;</div><div class="line">    void push_back(const string &amp;t) &#123;data -&gt; push_back(t);&#125;</div><div class="line">    void pop_back() &#123;check(0, &quot;empty&quot;); data -&gt; front();&#125;</div><div class="line">    string&amp; front() &#123;check(0, &quot;empty&quot;); return data -&gt; front();&#125;</div><div class="line">    string&amp; back() &#123;check(0, &quot;empty&quot;); return data -&gt; back();&#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; data;//vec的指针</div><div class="line">    //检测异常</div><div class="line">    void check(size_type i, const string &amp;msg) const </div><div class="line">        &#123;if (i &gt;= data -&gt; size()) throw out_of_range(msg);&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    StrBlob b1&#123;&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;&#125;;</div><div class="line">    StrBlob b2;</div><div class="line">    b2 = b1;</div><div class="line">    cout &lt;&lt; b1.size() &lt;&lt; endl; //3</div><div class="line">    cout &lt;&lt; b2.size() &lt;&lt; endl;//3</div><div class="line">    b1.push_back(&quot;ssss&quot;);</div><div class="line">    cout &lt;&lt; b1.size() &lt;&lt; endl;//4</div><div class="line">    cout &lt;&lt; b2.size() &lt;&lt; endl;//4</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>初始化<code>unique_ptr</code>需要使用直接初始化的方式<br><code>unique_ptr</code>不支持不同的赋值和拷贝<br>但是可以拷贝或赋值一个将要被销毁的<code>unique_ptr</code><br>P418</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">unique_ptr&lt;string&gt; p(new string);//直接初始化</div><div class="line"></div><div class="line">p = q;//不支持赋值</div><div class="line">unique_ptr&lt;string&gt; p(q);//不支持拷贝</div><div class="line"></div><div class="line">p = nullptr ; //释放对象，p置空</div><div class="line">p.release(); //p放弃对指针的控制权，返回指针，p置空</div><div class="line">p.reset(); //释放p</div><div class="line">p.reset(q); //如果提供了内置指针（动态内存）q，p指向q，否则释放p</div><div class="line">p.reset(nullptr);</div><div class="line"></div><div class="line">unique_ptr&lt;string&gt; p(q.release()); //q控制权转为p</div><div class="line"></div><div class="line">q.release(); //错误做法，并不会释放q，而且丢失了指针</div><div class="line">auto q = p.release();//必须手动释放内存：delete(q)</div></pre></td></tr></table></figure>
<p>传递unique_ptr参数和返回unique_ptr</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//返回一个unique_ptr</div><div class="line">unique_ptr&lt;int&gt; fun(int p)</div><div class="line">&#123;</div><div class="line">    return unique_ptr&lt;int&gt; (new int(p));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>unique_ptr管理删除器的方式与shared_ptr不同<br>所以必须在尖括号中指定函数类型的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void f(dest &amp;d)</div><div class="line">&#123;</div><div class="line">    connection c = connect(d);</div><div class="line">    unique_ptr&lt;connection, decltype(end_connection) *&gt;</div><div class="line">        p (c, end_connection);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>指向shared_ptr管理的对象，不会改变share_ptr的引用计数<br>用shared_ptr初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">weak_ptr&lt;T&gt; w(sp); //sp是shared_ptr</div><div class="line">w = p; //p可以是一个shared_ptr或者一个wek_ptr</div><div class="line">w.reset(); //w置空</div><div class="line">w.use_count(); //与w共享的shared_ptr的数量</div><div class="line">w.expired(); //如果use_count()为0返回true</div><div class="line">w.lock(); //如果use_count()为true，返回空shared_ptr，否则返回一个指向w对象的shared_ptr</div></pre></td></tr></table></figure>
<p>安全地访问weak_ptr对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//如果不为空，条件成立</div><div class="line">if (shared_ptr&lt;int&gt; p = w.lock())</div><div class="line">&#123;</div><div class="line">    //pass</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义一个StrBlob的伴随指针类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">//先申明</div><div class="line">class StrBlobPtr;</div><div class="line">class StrBlob</div><div class="line">&#123;</div><div class="line">friend class StrBlobPtr; //申明为友元</div><div class="line">//...</div><div class="line">    StrBlobPtr begin();</div><div class="line">    StrBlobPtr end();</div><div class="line">    //其他和之前一样</div><div class="line">    //...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class StrBlobPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    StrBlobPtr() : curr(0) &#123;&#125;</div><div class="line">    StrBlobPtr(StrBlob &amp;a, size_t sz=0):</div><div class="line">        wptr(a.data), curr(sz) &#123;&#125; //用shared_ptr初始化弱指针</div><div class="line">    //成员函数</div><div class="line">    string &amp;deref() const; //解引用</div><div class="line">    StrBlobPtr &amp;incr(); //递增</div><div class="line">    bool equal( StrBlobPtr b) const //检查索引值</div><div class="line">        &#123;return this -&gt; curr == b.curr;&#125;</div><div class="line">private:</div><div class="line">    //检查vector是否被释放，索引是否合法</div><div class="line">    shared_ptr&lt;vector&lt;string&gt;&gt; check(size_t sz, const string &amp;msg) const;</div><div class="line">    weak_ptr&lt;vector&lt;string&gt;&gt; wptr; //一个弱指针</div><div class="line">    size_t curr; //位置</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//返回一个指向第一个元素的StrBlobPtr</div><div class="line">StrBlobPtr StrBlob::begin()</div><div class="line">&#123;</div><div class="line">    return StrBlobPtr(*this);</div><div class="line">&#125;</div><div class="line">//最后一个元素后一个位置</div><div class="line">StrBlobPtr StrBlob::end()</div><div class="line">&#123;</div><div class="line">    auto ret = StrBlobPtr(*this, data -&gt; size());</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">shared_ptr&lt;vector&lt;string&gt;&gt; </div><div class="line">StrBlobPtr::check(size_t sz, const string &amp;msg) const</div><div class="line">&#123;</div><div class="line">    auto ret = wptr.lock(); //如果不存在返回空</div><div class="line">    if (!ret)</div><div class="line">        throw runtime_error(&quot;unbond StrBlob&quot;);</div><div class="line">    if (sz &gt;= ret -&gt; size())</div><div class="line">        throw out_of_range(msg);</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">string &amp;StrBlobPtr::deref() const</div><div class="line">&#123;</div><div class="line">    auto p = check(curr, &quot;dereference past end&quot;); //检查索引</div><div class="line">    return (*p) [curr]; //取vector元素</div><div class="line">&#125;</div><div class="line"></div><div class="line">StrBlobPtr &amp;StrBlobPtr::incr()</div><div class="line">&#123;</div><div class="line">    check(curr, &quot;increment past end of StrBlobPtr&quot;); //检查索引</div><div class="line">    ++curr; //自增移动</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    StrBlob b&#123;&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;&#125;;</div><div class="line">    StrBlobPtr bp = b.begin(), be = b.end();</div><div class="line">    while(!bp.equal(be))</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; bp.deref() &lt;&lt; endl; //a aa aaa</div><div class="line">        bp.incr();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2><p>可以使用auto从初始化器推断类型<br>因为编译器要从初始化器推断类型，只有当括号中仅有单一初始化器才能用auto</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto *p1 = new auto(obj); //p1指向与obj类型相同的对象，用obj初始化</div><div class="line">auto *p2 = new auto&#123;a, b, c&#125;; //错误，只能有单个初始化器</div></pre></td></tr></table></figure>
<p>可以动态分配const对象，必须初始化，或者隐式初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const int *p1 = new const int(100); //分配并初始化const int</div><div class="line">const int *p2 = new const string; //分配并默认初始化为空串</div></pre></td></tr></table></figure></p>
<p>如果内存耗尽，new表达式会失败，抛出一个类型为<code>bad_alloc</code>的异常<br>可以改变用new的方式，阻止抛出异常<br>这种形式的new被成为定位new<br><code>bad_alloc</code>和<code>nothow</code>都定义在头文件new中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int *p1 = new int; //如果分配失败，抛出std::bad_alloc</div><div class="line">int *p2 = new (nothow) int; //如果分配失败，返回空指针</div></pre></td></tr></table></figure>
<p><code>delete</code>表达式必须指向动态分配的内存，或是一个空指针<br>释放一块非new分配的内存，或者相同指针释放多次，行为是未定义的<br>虽然const对象的值不能改变，但是本身是可以被销毁的<br>直到被释放，动态对象一直存在</p>
<p>动态分配vector、添加元素、打印、删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//动态分配一个vector</div><div class="line">vector&lt;int&gt; *fun1()</div><div class="line">&#123;</div><div class="line">    return new vector&lt;int&gt;;</div><div class="line">&#125;</div><div class="line">//添加元素</div><div class="line">void fun2(vector&lt;int&gt; *p)</div><div class="line">&#123;</div><div class="line">    int temp;</div><div class="line">    while(cin&gt;&gt;temp)</div><div class="line">    &#123;</div><div class="line">        p -&gt; push_back(temp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//打印</div><div class="line">void fun3(vector&lt;int&gt; *p)</div><div class="line">&#123;</div><div class="line">    for(auto i:*p)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    auto *p = fun1();</div><div class="line">    fun2(p);</div><div class="line">    fun3(p);</div><div class="line">    delete p;//释放空间</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用智能指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//返回一个指向vector的智能指针</div><div class="line">shared_ptr&lt;vector&lt;int&gt;&gt; fun1()</div><div class="line">&#123;</div><div class="line">    return make_shared&lt;vector&lt;int&gt;&gt;();</div><div class="line">&#125;</div><div class="line">//添加元素</div><div class="line">void fun2(shared_ptr&lt;vector&lt;int&gt;&gt; p)</div><div class="line">&#123;</div><div class="line">    int temp;</div><div class="line">    while(cin&gt;&gt;temp)</div><div class="line">    &#123;</div><div class="line">        p -&gt; push_back(temp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//打印</div><div class="line">void fun3(shared_ptr&lt;vector&lt;int&gt;&gt; p)</div><div class="line">&#123;</div><div class="line">    for(auto i:*p)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    auto p = fun1();</div><div class="line">    fun2(p);</div><div class="line">    fun3(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>分配数组会得到一个元素类型的指针，不是数组类型<br>不能使用begin()和end()操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p = new int[get_size()];</div><div class="line"></div><div class="line">int *p = new int[10]; //没有初始化的int</div><div class="line">int *p = new int[10](); //10个初始值为0的int</div><div class="line">int *p = new int[10]&#123;0,1,2,3,4,5,6,7,8,9&#125;;</div></pre></td></tr></table></figure>
<p>释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete [] p;</div></pre></td></tr></table></figure>
<h3 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h3><p>标准库提供了可以管理new 分配的数组的unique_ptr版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unique_ptr&lt;int []&gt; up (new int[10]);</div><div class="line">up.release(); //自动调用delete[]销毁指针</div></pre></td></tr></table></figure>
<p>不支持成员访问运算符（点和箭头）<br>使用下标操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(size_t i = 0; i != 10; ++i)</div><div class="line">    up[i] = i;</div><div class="line">for(size_t i = 0; i != 10; ++i)</div><div class="line">    cout &lt;&lt; up[i] &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>shared_ptr不支持管理动态数组，除非自定义删除器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//使用lambda表达式自定义删除器</div><div class="line">shared_ptr&lt;int&gt; sp(new int[10], [](int *p) &#123; delete [] p;&#125;);</div><div class="line">sp.reset(); //调用删除器释放数组</div></pre></td></tr></table></figure>
<p>操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">shared_ptr&lt;int&gt; sp(new int[10], [](int *p) &#123; delete [] p;&#125;);</div><div class="line">for(size_t i = 0; i != 10; ++i)</div><div class="line">    *(sp.get() + i) = i;</div><div class="line">for(size_t i = 0; i != 10; ++i)</div><div class="line">    cout &lt;&lt; *(sp.get() + i)  &lt;&lt; endl;</div><div class="line">sp.reset();</div></pre></td></tr></table></figure>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>定义在头文件<code>memory</code>中</p>
<p>指定对象类型，定义allocator对象，然后根据对象类型确定大小<br>P428</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">allocator&lt;string&gt; alloc; //定义一个allocator对象</div><div class="line">auto const p = alloc.allocate(10); //分配10个未初始化的string</div><div class="line">alloc.construct(p, args); // args传递给构造函数，构造对象</div><div class="line">alloc.destroy(p); //调用析构函数，p必须是一个类型为string*的指针</div><div class="line">alloc.deallocate(p, 10); //释放p开始的10个string的内存，在调用前需要先调用destroy</div></pre></td></tr></table></figure>
<h2 id="文本查询程序"><a href="#文本查询程序" class="headerlink" title="文本查询程序"></a>文本查询程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">class QueryResult;</div><div class="line">class TextQuery</div><div class="line">&#123;</div><div class="line">friend class QueryResult;</div><div class="line">public:</div><div class="line">    TextQuery(std::ifstream &amp;infile);</div><div class="line">    QueryResult query(std::string s) const;</div><div class="line">private:</div><div class="line">   std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; ifile; //指向存放每行文本的vector</div><div class="line">   //这里用int表示行号，实际上应该用非负类型</div><div class="line">    std::map&lt;std::string, std::shared_ptr&lt;std::set&lt;int&gt;&gt;&gt; wm; //单词到存放行数的set的映射</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class QueryResult</div><div class="line">&#123;</div><div class="line">friend std::ostream &amp;print(std::ostream &amp;os, const QueryResult &amp;qr);</div><div class="line">public:</div><div class="line">    QueryResult(std::string s, std::shared_ptr&lt;std::set&lt;int&gt;&gt; lp, std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; fp) : </div><div class="line">        world(s), linep(lp), file(fp)&#123;&#125;</div><div class="line">private:</div><div class="line">    std::string world;</div><div class="line">    std::shared_ptr&lt;std::set&lt;int&gt;&gt; linep;</div><div class="line">    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//构造函数，在构造函数里储存将单词到行号的隐射</div><div class="line">TextQuery::TextQuery(std::ifstream &amp;infile) : ifile(new std::vector&lt;std::string&gt;) //初始化infile</div><div class="line">&#123;</div><div class="line">    std::string s,world;</div><div class="line">    int num(0);</div><div class="line">    while(getline(infile, s))</div><div class="line">    &#123;</div><div class="line">        ++num;</div><div class="line">        ifile -&gt; push_back(s);</div><div class="line">        std::istringstream line(s);</div><div class="line">        while(line &gt;&gt; world)</div><div class="line">        &#123;</div><div class="line">            if(!wm[world]) //如果set还没有创建</div><div class="line">                wm[world].reset(new std::set&lt;int&gt;); //创建一个set</div><div class="line">            wm[world] -&gt; insert(num); //行号插入到set</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//查找</div><div class="line">//返回一个QueryResult类</div><div class="line">QueryResult TextQuery::query(std::string s) const</div><div class="line">&#123;</div><div class="line">    std::shared_ptr&lt;std::set&lt;int&gt;&gt; nodata(new std::set&lt;int&gt;); //一个空set</div><div class="line">    auto res = wm.find(s); //查找函数的本体，查找map对应字符串的行号set</div><div class="line">    if (res == wm.end()) //无内容返回空set</div><div class="line">        return QueryResult(s, nodata, ifile);</div><div class="line">    else //有内容返回set，访问map 的 second成员</div><div class="line">        return QueryResult(s, res -&gt; second, ifile);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//打印存放在QueryResult内的内容</div><div class="line">std::ostream &amp;print(std::ostream &amp;os, const QueryResult &amp;qr)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; qr.world &lt;&lt; &quot;: \n&quot;;</div><div class="line">    for (auto num:*qr.linep) //对每个指针解引用然后遍历</div><div class="line">    &#123;</div><div class="line">        os &lt;&lt; num &lt;&lt; &quot; &quot;; //行号</div><div class="line">        os &lt;&lt; *(qr.file -&gt; begin() + num - 1) &lt;&lt; std::endl; //用迭代器输出vector的行文本</div><div class="line">    &#125;</div><div class="line">    return os;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    ifstream infile(&quot;text.txt&quot;);</div><div class="line">    TextQuery tq(infile);</div><div class="line">    print(cout, tq.query(&quot;harry&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/18/C2/" data-id="cj5c7k37o0006m0u4bd7zmgwe" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scrapy-harry" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/02/scrapy-harry/" class="article-date">
  <time datetime="2016-10-02T06:51:32.000Z" itemprop="datePublished">2016-10-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/02/scrapy-harry/">scrapy_harry</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h1><p>需要创建一个项目，创建一个名为project的项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject project</div></pre></td></tr></table></figure></p>
<p>创建的项目结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">tree project -L 3</div><div class="line"></div><div class="line">project/  </div><div class="line">├── project/ #项目的Python模块，在此加入代码 </div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── items.py</div><div class="line">│   ├── pipelines.py</div><div class="line">│   ├── settings.py #项目的设置文件，headers等等都在里面配置</div><div class="line">│   └── spiders/ #放置spider代码的目录</div><div class="line">│       └── __init__.py</div><div class="line">└── scrapy.cfg  #配置文件</div></pre></td></tr></table></figure></p>
<h1 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h1><p>继承<code>scrapy.Item</code>类</p>
<p><code>Item.py</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import scrapy</div><div class="line"></div><div class="line">class FirstItem(scrapy.Item):</div><div class="line">    title = scrapy.Field()</div><div class="line">    link = scrapy.Field()</div><div class="line">    des = scrapy.Field()</div></pre></td></tr></table></figure></p>
<h1 id="编写第一个爬虫"><a href="#编写第一个爬虫" class="headerlink" title="编写第一个爬虫"></a>编写第一个爬虫</h1><p>继承<code>scrapy.Spider</code>类</p>
<ul>
<li><code>name</code>是爬虫的名字</li>
<li><code>start_urls</code>爬虫爬取的URLS</li>
<li><code>parse()</code>爬取方法，每个初始URL完成下载后生成，<code>Response</code>对象作为唯一参数传递给该函数，该方法负责解析数据，提取数据，生成<code>item</code>和进一步要处理的URL的<code>Request</code></li>
</ul>
<p><code>spiders/first_spider.py</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import scrapy</div><div class="line"></div><div class="line">class FirstSpider(scrapy.Spider):</div><div class="line">    name = &quot;first&quot;</div><div class="line">    base_domain = &quot;harryhei.github.io&quot;</div><div class="line">    start_urls = [</div><div class="line">        &quot;http://harryhei.github.io/tags/flask/&quot;,</div><div class="line">        &quot;http://harryhei.github.io/tags/django/&quot;</div><div class="line">    ]</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        f = response.url.split(&quot;/&quot;)[-2]</div><div class="line">        with open(f, &quot;wb&quot;) as f:</div><div class="line">            f.write(response.body)</div></pre></td></tr></table></figure></p>
<p>制定headers和cookies参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Request(url, method=&apos;GET&apos;, headers=headers, cookies=cookies)</div></pre></td></tr></table></figure>
<h1 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h1><p>在根目录project下使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scrapy list #列出了所有spider</div><div class="line">scrapy crawl first #启动了名为first的爬虫</div></pre></td></tr></table></figure></p>
<p>爬完之后在根目录下多了两个文件：<code>django</code>和<code>flask</code></p>
<p>Scrapy为每个URL创建了 <code>scrapy.Request</code> 对象，并将 <code>parse</code> 方法作为回调函数(callback)赋值给了<code>Request</code>。</p>
<p><code>Request</code>对象经过调度，执行生成 <code>scrapy.http.Response</code> 对象并送回给 <code>parse()</code> 方法。</p>
<h1 id="提取Item"><a href="#提取Item" class="headerlink" title="提取Item"></a>提取Item</h1><p>selectors选择器：基于XPath和CSS<br><a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/selectors.html#scrapy.selector.Selector.xpath" target="_blank" rel="external">选择器</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from scrapy.selector import Selector</div><div class="line">from scrapy.http import HtmlResponse</div><div class="line"></div><div class="line">body = &apos;...&apos;</div><div class="line">Selector(text=body).xpath(&apos;//span/text()&apos;).extract()</div></pre></td></tr></table></figure>
<p>XPath举例</p>
<ul>
<li><code>/html/head/title</code> ：选择HTML文档中<code>&lt;head&gt;</code>标签内的<code>&lt;title&gt;</code>元素</li>
<li><code>/html/head/title/text()</code>：选择<code>&lt;title&gt;</code>元素的文字</li>
<li><code>//td</code>：所有<code>&lt;td&gt;</code>元素</li>
<li><code>//div[@class=&quot;mine&quot;]</code>：所有具有<code>class=&quot;mine&quot;</code>属性的<code>div</code>元素</li>
</ul>
<p><a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="external">xpath语法</a></p>
<p>Selector基本方法</p>
<ul>
<li><code>xpath()</code>：传入xpath表达式，返回selector list</li>
<li><code>css()</code>：传入CSS表达式，返回selector list</li>
<li><code>extract()</code>：返回unicode list</li>
<li><code>re()</code>：传入正则表达式，返回unicode list</li>
</ul>
<p>Scrapy shell</p>
<p>浏览器配合分析元素，抓取内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">scrapy shell &quot;http://harryhei.github.io&quot; //获得一个response对象</div><div class="line"></div><div class="line">response.xpath(&quot;//p[@class=&apos;article-more-link&apos;]/a/@href&quot;) //所有链接</div><div class="line">response.xpath(&quot;//a[@class=&apos;article-title&apos;]/text()&quot;).extract() //所有标题</div></pre></td></tr></table></figure></p>
<p>写到项目文件中</p>
<p>输出爬到的标题、链接和描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import scrapy</div><div class="line"></div><div class="line">class FirstSpider(scrapy.Spider):</div><div class="line">    name = &quot;first&quot;</div><div class="line">    base_domain = &quot;harryhei.github.io&quot;</div><div class="line">    start_urls = [</div><div class="line">        &quot;http://harryhei.github.io&quot;</div><div class="line">    ]</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        for sel in response.xpath(&quot;//div[@class=&apos;body-wrap&apos;]/article&quot;):</div><div class="line">            title = sel.xpath(&quot;div[@class=&apos;article-inner&apos;]//a/text()&quot;).extract()</div><div class="line">            link = sel.xpath(&quot;div[@class=&apos;article-meta&apos;]//a/@href&quot;).extract()</div><div class="line">            des = sel.xpath(&quot;div[@class=&apos;article-inner&apos;]//ul/li/a/text()&quot;).extract()</div><div class="line">            print title[0],link[0]</div><div class="line">            for l in des:</div><div class="line">                print &quot;&gt;&quot;,l</div></pre></td></tr></table></figure></p>
<p>使用item</p>
<p><code>response.urljoin()</code>用于构造绝对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import scrapy</div><div class="line"></div><div class="line">from project.items import FirstItem</div><div class="line"></div><div class="line">class FirstSpider(scrapy.Spider):</div><div class="line">    name = &quot;first&quot;</div><div class="line">    base_domain = &quot;harryhei.github.io&quot;</div><div class="line">    start_urls = [</div><div class="line">        &quot;http://harryhei.github.io&quot;</div><div class="line">    ]</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        for sel in response.xpath(&quot;//div[@class=&apos;body-wrap&apos;]/article&quot;):</div><div class="line">            item = FirstItem()</div><div class="line">            title = sel.xpath(&quot;div[@class=&apos;article-inner&apos;]//a/text()&quot;).extract()</div><div class="line">            link = sel.xpath(&quot;div[@class=&apos;article-meta&apos;]//a/@href&quot;).extract()</div><div class="line">            des = sel.xpath(&quot;div[@class=&apos;article-inner&apos;]//ul/li/a/text()&quot;).extract()</div><div class="line">            item[&quot;title&quot;] = title[0]</div><div class="line">            item[&quot;link&quot;] = response.urljoin(link[0]) #构造绝对路径</div><div class="line">            item[&quot;des&quot;] = &quot; &quot;.join(des)</div><div class="line">            yield item</div></pre></td></tr></table></figure></p>
<p>追踪链接</p>
<p>使用parse找寻链接，然后调用回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import scrapy</div><div class="line"></div><div class="line">from project.items import FirstItem</div><div class="line"></div><div class="line">class FirstSpider(scrapy.Spider):</div><div class="line">    name = &quot;first&quot;</div><div class="line">    base_domain = &quot;harryhei.github.io&quot;</div><div class="line">    start_urls = [</div><div class="line">        &quot;http://harryhei.github.io&quot;</div><div class="line">    ]</div><div class="line"></div><div class="line">    def parse(self, response):</div><div class="line">        for i in range(10):</div><div class="line">            url = response.urljoin(&quot;/page/%s&quot;%(i+1))</div><div class="line">            yield scrapy.Request(url, callback=self.parse_dir_contents)</div><div class="line"></div><div class="line">    def parse_dir_contents(self, response):</div><div class="line">        for sel in response.xpath(&quot;//div[@class=&apos;body-wrap&apos;]/article&quot;):</div><div class="line">            item = FirstItem()</div><div class="line">            title = sel.xpath(&quot;div[@class=&apos;article-inner&apos;]//a/text()&quot;).extract()</div><div class="line">            link = sel.xpath(&quot;div[@class=&apos;article-meta&apos;]//a/@href&quot;).extract()</div><div class="line">            des = sel.xpath(&quot;div[@class=&apos;article-inner&apos;]//ul/li/a/text()&quot;).extract()</div><div class="line">            item[&quot;title&quot;] = title[0]</div><div class="line">            item[&quot;link&quot;] = response.urljoin(link[0])</div><div class="line">            item[&quot;des&quot;] = &quot; &quot;.join(des)</div><div class="line">            yield item</div></pre></td></tr></table></figure></p>
<h1 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h1><p>保存为json数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy crawl first -o items.json</div></pre></td></tr></table></figure></p>
<p>Python 读取json数据然后输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import json</div><div class="line"></div><div class="line">f = open(&quot;items.json&quot;)</div><div class="line">j = json.loads(f.read())</div><div class="line">for l in j:</div><div class="line">    print l[&quot;title&quot;], l[&quot;link&quot;]</div><div class="line">    print l[&quot;des&quot;]</div><div class="line">    </div><div class="line">f.close()</div></pre></td></tr></table></figure></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html" target="_blank" rel="external">中文文档</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/02/scrapy-harry/" data-id="cj5c7k433004hm0u4o7fo4zmc" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spider/">spider</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mywx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/29/mywx/" class="article-date">
  <time datetime="2016-09-29T08:29:47.000Z" itemprop="datePublished">2016-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/29/mywx/">wxBot微信机器人框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>wxBot 是用Python包装Web微信协议实现的微信机器人框架</p>
</blockquote>
<p><a href="https://github.com/liuwons/wxBot" target="_blank" rel="external">wxBot</a>项目地址</p>
<p>新建一个虚拟环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mkdir mywxbot</div><div class="line">$ cd mywxbot/</div><div class="line">$ virtualenv venv</div><div class="line">$ source venv/bin/activate</div></pre></td></tr></table></figure></p>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pip install requests</div><div class="line">pip install pyqrcode</div><div class="line">pip install pypng</div><div class="line">pip install Pillow</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>自动回复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># coding: utf-8</div><div class="line"></div><div class="line">import time</div><div class="line">from wxbot import *</div><div class="line"></div><div class="line">class MyWXBot(WXBot):</div><div class="line">    def handle_msg_all(self, msg):</div><div class="line">        if msg[&apos;msg_type_id&apos;] == 4 and msg[&apos;content&apos;][&apos;type&apos;] == 0:</div><div class="line">            self.send_msg_by_uid(u&apos;hi&apos;, msg[&apos;user&apos;][&apos;id&apos;]) //这里自动回复消息hi</div><div class="line">            //还有很多方式，在github中有写</div><div class="line"></div><div class="line">def main():</div><div class="line">    bot = MyWXBot()</div><div class="line">    bot.DEBUG = True</div><div class="line">    bot.run()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h1 id="爬虫加微信接口"><a href="#爬虫加微信接口" class="headerlink" title="爬虫加微信接口"></a>爬虫加微信接口</h1><ul>
<li><p>功能是微信收到消息之后，request爬百度对应的图片，然后回过去</p>
</li>
<li><p>项目地址<a href="https://github.com/HarryHEi/mywxbot" target="_blank" rel="external">mywxbot</a></p>
</li>
<li><p>发送图片的时候如果设置为中文名称就会出错</p>
</li>
<li><p>首先用微信接受字符串，注意要把unicode编码转成str</p>
</li>
<li><p>百度的图片资源可能会403</p>
</li>
<li><p>图片名是用的随机字符串，也可以用名称的md5值，不过会出现图片重复，这样可以避免重复下载</p>
</li>
<li><p>下载图片用的是request文档的推荐，也可以用wget，不过之前试的时候经常403</p>
</li>
<li><p>爬到的图片不是高清的</p>
</li>
<li><p>总之，也算基本完成预期吧</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># coding: utf-8</div><div class="line"></div><div class="line">import time</div><div class="line">from wxbot import *</div><div class="line">import requests</div><div class="line">import os,re,string,sys,time</div><div class="line">import cookielib</div><div class="line">import random</div><div class="line">import md5</div><div class="line"></div><div class="line">&quot;百度爬图的微信接口&quot;</div><div class="line"></div><div class="line">url = &quot;http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=&quot;</div><div class="line"></div><div class="line">#获得页面所有图片的链接</div><div class="line">def get_pic_links(url):</div><div class="line">    req = requests.get(url)</div><div class="line">    html = req.text</div><div class="line">    links = re.findall(r&apos;&quot;thumbURL&quot;:&quot;(.*?.jpg)&quot;&apos;, html) #小图</div><div class="line">    sourcelinks = re.findall(r&apos;&quot;objURL&quot;:&quot;(.*?)&quot;&apos;, html) #原图</div><div class="line">    return links, sourcelinks</div><div class="line"></div><div class="line">#使用wget下载</div><div class="line">def wget_pic(u, name):</div><div class="line">    referer = re.findall(r&apos;//(.*?)/&apos;,u)[0]</div><div class="line">    command = &apos;wget --referer=&quot;%s&quot; -O &quot;%s&quot;  &quot;%s&quot;&apos;%(referer, name, u)</div><div class="line">    print &quot;Command is: %s&quot;%(command)</div><div class="line">    os.system(command)</div><div class="line"></div><div class="line">class MyWXBot(WXBot):</div><div class="line">    def handle_msg_all(self, msg):</div><div class="line">        if msg[&apos;msg_type_id&apos;] == 4 and msg[&apos;content&apos;][&apos;type&apos;] == 0:</div><div class="line">            user_input = msg[&quot;content&quot;][&quot;data&quot;]</div><div class="line">            user_input = user_input.encode(&quot;utf-8&quot;) #Unicode =&gt; str</div><div class="line">            #m = md5.new()</div><div class="line">            #m.update(user_input)</div><div class="line">            #md5name =  m.hexdigest()</div><div class="line">            md5name = random_str(10)</div><div class="line">            name = &apos;&apos;.join([md5name, &apos;.jpg&apos;])</div><div class="line">            #name = name.encode(&quot;utf-8&quot;) #Unicode =&gt; str</div><div class="line">            urls, sourceurls = get_pic_links(url+ user_input)</div><div class="line">            if len(urls)&lt;1:</div><div class="line">                self.send_msg_by_uid(u&apos;并没有搜到啥&apos;, msg[&apos;user&apos;][&apos;id&apos;])</div><div class="line">                return 0</div><div class="line">            else:</div><div class="line">                self.send_msg_by_uid(u&apos;请稍等&apos;, msg[&apos;user&apos;][&apos;id&apos;])</div><div class="line">                i = 0</div><div class="line">                while i &lt; 20:</div><div class="line">                    i = i + 1;</div><div class="line">                    if not os.path.exists(name):</div><div class="line">                        num = random.randint(1,len(urls)-1)</div><div class="line">                        #下载图片，命名为name</div><div class="line">                        try:</div><div class="line">                            headers = &#123;</div><div class="line">                                &quot;User-Agent&quot;:&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0&quot;,</div><div class="line">                                &quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</div><div class="line">                            &#125;</div><div class="line">                            referer = re.findall(r&apos;//(.*?)/&apos;,urls[num])[0]</div><div class="line">                            headers[&quot;referer&quot;] = referer</div><div class="line">                            r = requests.get(urls[num], headers = headers)</div><div class="line">                            if str(r.status_code)[0] == &quot;4&quot;:</div><div class="line">                                print(&quot;未下载成功：&quot;, urls[num])</div><div class="line">                                continue</div><div class="line">                            with open(name, &apos;wb&apos;) as fd:</div><div class="line">                                for chunk in r.iter_content():</div><div class="line">                                    fd.write(chunk)</div><div class="line">                        except:</div><div class="line">                            print &quot;图片下载错误&quot;</div><div class="line">                            continue</div><div class="line">                    #发送图片</div><div class="line">                    try:</div><div class="line">                        self.send_img_msg_by_uid(name, msg[&apos;user&apos;][&apos;id&apos;])</div><div class="line">                        self.send_msg_by_uid(u&apos;原图链接&apos;, msg[&apos;user&apos;][&apos;id&apos;])</div><div class="line">                        self.send_msg_by_uid(sourceurls[num], msg[&apos;user&apos;][&apos;id&apos;])</div><div class="line">                        break</div><div class="line">                    except:</div><div class="line">                        self.send_msg_by_uid(u&apos;并没有搜到啥&apos;, msg[&apos;user&apos;][&apos;id&apos;])</div><div class="line">                        continue</div><div class="line"></div><div class="line">def random_str(randomlength=8):</div><div class="line">    str = &apos;&apos;</div><div class="line">    chars = &apos;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789&apos;</div><div class="line">    length = len(chars) - 1</div><div class="line">    r = random.Random()</div><div class="line">    for i in range(randomlength):</div><div class="line">        str+=chars[r.randint(0, length)]</div><div class="line">    return str</div><div class="line"></div><div class="line">def main():</div><div class="line">    bot = MyWXBot()</div><div class="line">    bot.DEBUG = True</div><div class="line">    bot.SCHEDULE_INTV = 20</div><div class="line">    bot.conf[&apos;qr&apos;] = &apos;tty&apos;</div><div class="line">    bot.run()</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.just4fun.site/pi-wechat.html" target="_blank" rel="external">微信树莓派</a></p>
<p>使用<code>flask</code>提供<code>api</code>，当接收到微信消息时，使用<code>requests.get(url)</code>访问<code>api</code>，好像挺有意思</p>
<p>可以做一个类似弹幕的东西，用微信发送文本信息，然后实时更新到网页上</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/29/mywx/" data-id="cj5c7k42g0040m0u4w078gxxr" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/31/C1/" class="article-date">
  <time datetime="2016-08-31T13:20:27.000Z" itemprop="datePublished">2016-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/31/C1/">C++ Primer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p><code>Linux</code>下使用<code>GCC</code>编译器对<code>C++</code>程序进行编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g++ hello.cc -o hello</div><div class="line">g++ hello.cc students.cc -o hello //编译多个文件</div><div class="line"></div><div class="line">g++ -std=c++11 hello.cc -o hello // c++11 标准</div></pre></td></tr></table></figure></p>
<p><code>makefile</code>的编写</p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>使用sublime编辑器，ctrl+B可以直接编译</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="输入输出（iostream库）"><a href="#输入输出（iostream库）" class="headerlink" title="输入输出（iostream库）"></a>输入输出（iostream库）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int v1,v2;</div><div class="line">    std::cout &lt;&lt; &quot;Enter two numbers&quot; &lt;&lt; std::endl;</div><div class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</div><div class="line">    std::cout &lt;&lt;  &quot;the sum is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面两种流操作是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">std::cout &lt;&lt; &quot;Enter two numbers&quot; &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::cout &lt;&lt; &quot;Enter two numbers&quot;;</div><div class="line">std::cout &lt;&lt; std::endl;</div></pre></td></tr></table></figure></p>
<p><code>std::</code>表示命名空间<code>std</code>，<code>::</code>是作用域操作符（scope operator）<br>或者使用using声明命名空间，<code>using std::string</code></p>
<h2 id="变量、基本类型"><a href="#变量、基本类型" class="headerlink" title="变量、基本类型"></a>变量、基本类型</h2><p>c++11 标准支持使用花括号初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int val&#123;0&#125;;</div></pre></td></tr></table></figure></p>
<p>变量声明和定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern int a; //声明，不定义</div></pre></td></tr></table></figure></p>
<p>类类型通过<strong>构造函数</strong>（constructor）初始化</p>
<p><code>const</code>定义的变量值不会被意外修改，如果定义为全局变量，不能被其他文件访问</p>
<p><code>const</code>必须初始化，一旦创建，值无法修改</p>
<p>多个文件共享const变量，需要添加<code>extern</code>关键字</p>
<p>在<code>****.cc</code>文件中定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern const int aaa=10;</div></pre></td></tr></table></figure></p>
<p>在<code>****.h</code>头文件中声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern const int aaa;</div></pre></td></tr></table></figure></p>
<p><code>&amp;</code>引用是对象（变量）的别名，这里的<code>i</code>是变量（对象），<code>ii</code>是引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char i=&apos;a&apos;;</div><div class="line">char &amp;ii = i;</div></pre></td></tr></table></figure></p>
<ul>
<li>引用不是对象，没有实际地址</li>
<li>引用一旦定义，无法再赋值</li>
</ul>
<p><code>const</code>引用可以绑定到相关类型对象或右值（字面值等）上，称为常量引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int &amp;a = 1; //错误，不能为非const引用绑定常量（字面值）</div><div class="line">const int &amp;a = 1; //正确，可以用const引用绑定常量</div><div class="line">double i=2.1;	//i =&gt; 2.1</div><div class="line">int &amp;ii = i; //错误，不能使用非const绑定临时量</div><div class="line">const int &amp;ii = i;	//ii =&gt; 2 这里的  2 只是一个临时量，所以必须使用const</div><div class="line">i++;	//i =&gt; 3.1 , ii =&gt; 2</div></pre></td></tr></table></figure></p>
<p>可以通过其他途径修改原变量的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int i = 42;</div><div class="line">int &amp;r1 = i;</div><div class="line">const int &amp;r2 = i;  //这里绑定了 i ，不过不能通过r2修改 i 的值</div><div class="line">r1 = 0; //通过 r1 修改了值</div><div class="line">cout &lt;&lt; &quot;r1: &quot; &lt;&lt; r1 &lt;&lt; &quot; r2: &quot; &lt;&lt; r2 &lt;&lt; endl; //输出: r1: 0 r2: 0</div></pre></td></tr></table></figure></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>定义一个指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string s(&quot;hello world&quot;);</div><div class="line">string *sp = &amp;s;</div></pre></td></tr></table></figure></p>
<p>定义一个空指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int  *p = 0;</div><div class="line">int *p = nullptr; //C++11标准</div></pre></td></tr></table></figure></p>
<p><code>void*</code>指针可以存放任意对象地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int i = 20;</div><div class="line">void *p = &amp;i;</div></pre></td></tr></table></figure></p>
<ul>
<li>迭代器用于访问容器内元素，指针指向单个对象，保存另一个对象地址</li>
<li>指向const的指针才能指向const对象，也可以指向非const对象，但是不能修改对象值，指针本身的值可以修改</li>
<li>const指针指针值不能修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const int s = 1;</div><div class="line">const int *sp = &amp;s;//指向const类型的指针，指针值可以修改（重新指向一个const int 变量</div><div class="line">                                        //但是不能修改原变量（不管原变量是不是const）</div><div class="line">int *const csp = &amp;s;//错误，const指针应该指向非const int</div><div class="line">const int *const  pa = &amp;a;//指向const int 的 const 指针</div></pre></td></tr></table></figure>
<ul>
<li>顶层<code>const</code>：指针本身是常量</li>
<li>底层<code>const</code>：指针所指对象是常量</li>
</ul>
<p>常量表达式<code>constexpr</code></p>
<p>常量表达式可以定义为<code>constexpr</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">constexpr int i = 20;</div><div class="line">constexpr int a = i + 2;</div><div class="line">constexpr int *ip = nullptr;//指向整数的常量指针</div></pre></td></tr></table></figure></p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>使用typedef定义类型别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef double wow, *p; //wow 等同于 double ，p等同于 double *</div><div class="line">wow val = 1.1; //double val = 1.1;</div><div class="line">p p1 = &amp;val; // double *p1 = &amp;val;</div></pre></td></tr></table></figure></p>
<p>C++11使用别名声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">using wow = double;</div><div class="line">wow val = 1.1;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong><br><code>pstring</code>是指向<code>char</code>的指针，数据类型是指针<br><code>const</code>修饰之后，<code>const pstring</code>是指向<code>char</code>的<code>const</code>指针（常数指针）<br><code>const pstring cstr</code>相当于<code>char *const cstr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef char *pstring; //pstring 相当于 char*</div><div class="line">char a=&apos;0&apos;,b=&apos;1&apos;; </div><div class="line">const pstring cstr = &amp;a; //这并不等于const char *cstr ，这样修饰类型变成char</div><div class="line">    //cstr是一个指向char的const指针，char *const cstr</div><div class="line">cstr = &amp;b; //错误，因为cstr是const指针，不能重新赋值</div></pre></td></tr></table></figure>
<p><code>auto</code>让编译器推算变量类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a&#123;1&#125;,b&#123;2&#125;;</div><div class="line">auto c = a + b, d = a * b; //如果有多个语句所有变量基本数据必须同一类型</div><div class="line">                                                //（编译器会适当改变结果）</div></pre></td></tr></table></figure>
<p>编译器会适当修改结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = 1, &amp;r = a;</div><div class="line">auto b = r; //b是一个int 类型，并不是引用</div><div class="line">a += 1;</div><div class="line">cout &lt;&lt; a &lt;&lt; r &lt;&lt; b &lt;&lt; endl;//a r都是2，b为1</div></pre></td></tr></table></figure>
<p><code>auto</code>会忽略顶层<code>const</code>，留下底层<code>const</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">const int i = 1;</div><div class="line">auto j = i; // j 为int类型</div><div class="line">j += 1; //合法</div><div class="line">i += 1; //不合法，i 为const int 类型</div><div class="line">auto k = &amp;a; // k是 int 类型指针</div><div class="line">auto m = &amp;i; //m 是 const int 类型指针对const 的取址是底层const</div></pre></td></tr></table></figure>
<p>明确指出<code>const auto</code>，修饰为顶层<code>const</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const int i = 1; //是不是cosnt 都一样</div><div class="line">const auto j = i; //j 为 const auto类型</div></pre></td></tr></table></figure>
<p>如果给const 变量绑定引用，初始值顶层const保留，保留的const就是底层const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const int ci = 1; //const int 类型</div><div class="line">auto &amp;a = ci; //a为 const int 类型 的引用</div><div class="line">a += 1; //非法</div><div class="line"></div><div class="line">int i = 1; //int类型</div><div class="line">const int ci = i; //const int 类型</div><div class="line">auto &amp;j = i,*p = &amp;ci ; //非法，j 为 int 类型引用，p为const int 类型指针，不一致</div><div class="line">const auto &amp;j = i,*p = &amp;ci ; //合法，均为const int 类型</div></pre></td></tr></table></figure>
<p><code>decltype</code>返回操作数的数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int fun(int i)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;</div><div class="line">    return i+1;</div><div class="line">&#125;</div><div class="line">int main () </div><div class="line">&#123;</div><div class="line">    decltype(fun(1)) i = 10; //编译器并不会真的调用fun()函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>decltype</code>如果表达式是变量，会返回包括顶层const的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const int a=0;</div><div class="line">decltype(a) i = 10; //const int类型</div><div class="line">decltype(a) &amp;j = a; //const int 引用</div><div class="line">const int &amp;b = a; </div><div class="line">decltype(b) i = a; //const int 引用</div></pre></td></tr></table></figure>
<p><code>decltype</code>如果表达式不是变量：</p>
<ul>
<li>如果是表达式，为结果的类型</li>
<li>如果是解引用，为引用类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 0, *p = &amp;a, &amp;r = a;</div><div class="line">decltype(r + 0) b = 1; //b 是int类型</div><div class="line">decltype(*p) c = a; // c是int引用（int&amp;）</div></pre></td></tr></table></figure>
<p>注意：<br>变量加上括号就会被理解为表达式，变量作为表达式是赋值，会得到引用类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 0;</div><div class="line">decltype(a) c = a; //c是int类型</div><div class="line">decltype((a)) d = a; //d是int引用(int&amp;)</div></pre></td></tr></table></figure>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a><code>string</code>对象</h3><p>在头文件<code>string</code>中</p>
<p><strong>注意：string对象和字符串字面值不是一回事</strong></p>
<p>初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string s1&#123;&quot;hello,world&quot;&#125;;</div><div class="line">string s2 = &quot;hello world&quot;;</div><div class="line">string s3 = s2;</div><div class="line">string s4 = (10, &apos;h&apos;); // &quot;hhhhhhhhhhh&quot;</div></pre></td></tr></table></figure></p>
<p>string对象操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getline(cin,s)</code></td>
<td>读取一行内容给<code>s</code>直到换行符（不包括换行符）</td>
</tr>
<tr>
<td><code>s.empty()</code></td>
<td>如果s为空返回true</td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>返回长度，<code>string::size_type</code><strong>（一个无符号整型）</strong></td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>返回字符，下标为<code>string::size_type</code>类型，但可以使用任何整型</td>
</tr>
<tr>
<td><code>s1 + s2</code></td>
<td>拼接，至少有一个是string对象(左结合)</td>
</tr>
<tr>
<td><code>s1 = s2</code></td>
<td>替换<code>s1</code>内容</td>
</tr>
<tr>
<td><code>s1 == s2</code></td>
<td>判断相等 (&gt; &lt; &gt;= &lt;= !=大小写敏感)</td>
</tr>
</tbody>
</table>
<p>string对象中字符判断（cctype头文件中），一般返回int非0值或0</p>
<p><code>isalnum</code>        字母或数字<br><code>isalpha</code>        字母<br><code>isdigit</code>        数字<br><code>isgraph</code>        不是空格，可以打印<br>等</p>
<p>读取字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (cin &gt;&gt; s)&#123; \*   ...   *\ &#125; //每次读取一个单词（不包括空格）</div><div class="line">                //然后进入循环体，读取到结束符（ctrl D）退出循环</div><div class="line">getline(cin, s); //读取一行直到换行符（读取但是不保存换行符）</div></pre></td></tr></table></figure>
<p>比较大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">string a&#123;&quot;abc&quot;&#125;;</div><div class="line">string b&#123;&quot;aac&quot;&#125;;</div><div class="line">string c&#123;&quot;ab&quot;&#125;;</div><div class="line">//a &gt; b &gt; c</div></pre></td></tr></table></figure>
<p>使用下标遍历修改字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">string s&#123;&quot;hello,world!&quot;&#125;;</div><div class="line">for (decltype(s.size()) index = 0; index != s.size(); ++index) //decltype 获取类型</div><div class="line">    if (isalpha(s[index]))</div><div class="line">        s[index] = toupper(s[index])s</div><div class="line">cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>C++11 提供新的语句：范围for语句，遍历一个序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (元素:序列)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>使用范围for遍历一个string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string s&#123;&quot;hello world&quot;&#125;;</div><div class="line">for (auto c: s) //使用auto让编译器自己决定变量类型</div><div class="line">    cout &lt;&lt; c &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>使用引用遍历并修改字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">string s&#123;&quot;hello,world!&quot;&#125;;</div><div class="line">for (auto &amp;c: s) //定义原字符的引用</div><div class="line">    if (isalpha(c))</div><div class="line">        c = toupper(c); //改为大写</div><div class="line">cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure>
<h3 id="vector对象"><a href="#vector对象" class="headerlink" title="vector对象"></a><code>vector</code>对象</h3><p><code>vector</code>对象在<code>vector</code>头文件中，一个容器只能保存同一种对象（类型），甚至可以是vector对象</p>
<p>定义时指定类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">std::vector&lt;int&gt; ivec&#123;1,2,3,4&#125;;</div><div class="line">std::vector&lt;int&gt; ivec = &#123;1,2,3,4&#125;;</div><div class="line">std::vector&lt;int&gt; ivec = (10);//10个元素，初始化为0</div><div class="line">std::vector&lt;int&gt; ivec(10, -1);//&#123;-1, -1,-1, -1, -1, -1, -1, -1, -1, -1&#125;;</div><div class="line">std::vector&lt;int&gt; iven(1,2,3,4);//错误</div><div class="line"></div><div class="line">std::vector&lt;string&gt; sven&#123;10&#125;;//因为10并不能赋值给string所以，编译器尝试默认初始化</div><div class="line">        //为10个默认初始化元素</div></pre></td></tr></table></figure>
<p>使用push_back添加元素，不能使用下标添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt; ivec;</div><div class="line">for (int i = 0;i &lt; 100; ++i)</div><div class="line">&#123;</div><div class="line">    ivec.push_back(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>范围for循环访问，<strong>不能在范围for循环添加元素</strong>，因为范围for语句预存了end()的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (string s: svec)</div><div class="line">    cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p><code>vector</code>对象操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v.empty()</code></td>
<td>如果为空返回true</td>
</tr>
<tr>
<td><code>v.size()</code></td>
<td>返回长度，<code>vector&lt;...&gt;::size_type</code>类型，<strong>不能省略<code>&lt;...&gt;</code></strong></td>
</tr>
<tr>
<td><code>v.push_back(t)</code></td>
<td>在v尾部添加元素t</td>
</tr>
<tr>
<td><code>v[n]</code></td>
<td>返回元素</td>
</tr>
<tr>
<td><code>v1 = v2</code></td>
<td>v1元素替换</td>
</tr>
<tr>
<td><code>v1 == v2</code></td>
<td>相等返回true(&gt; &lt; &gt;= &lt;= !=)以字典顺序比较</td>
</tr>
</tbody>
</table>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>所有标准库容器都可以使用迭代器</p>
<p>string也可以使用迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">string s(&quot;hello world&quot;);</div><div class="line">auto si = s.begin(), se = s.end();</div><div class="line">while(si != se)</div><div class="line">&#123;</div><div class="line">    if (isalpha(*si))</div><div class="line">        *si = toupper(*si);</div><div class="line">    ++si;</div><div class="line">&#125;</div><div class="line">cout &lt;&lt; s &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<p>迭代器有<code>iterator</code>和<code>const_iterator</code>（只读）类型</p>
<p>可以使用auto让编译器自己判断类型</p>
<p><code>iterator</code>类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vector&lt;int&gt;::iterator iter = v.begin(); //初始化为起始位置</div><div class="line"></div><div class="line">auto b = v.begin(), e = v.end(); //起始元素位置和最后一个元素后一个位置（尾迭代器）</div><div class="line"></div><div class="line">++iter; //迭代器自增移动</div><div class="line">--iter;//自减移动</div><div class="line"></div><div class="line">std::cout &lt;&lt; *iter; //使用解引用操作符（`*`操作符）访问元素</div></pre></td></tr></table></figure>
<p>循环迭代到最后一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(vector&lt;int&gt;::iterator iter = v.begin();iter != v.end();++iter)</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; *iter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>const_iterator</code>类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const vector&lt;int&gt; iv&#123;1,2,3,4,5&#125;;//当定义为常量容器时</div><div class="line">auto v = iv.begin(), ve = iv.end();//下面两句等价</div><div class="line">vector&lt;int&gt;:: const_iterator v = iv.begin(), ve = iv.end();</div></pre></td></tr></table></figure>
<p><code>cbigin</code>和<code>cend</code>获取<code>const_iterator</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto v = iv.begin(), ve = iv.end();</div></pre></td></tr></table></figure>
<p>元素访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vector&lt;string&gt; iv&#123;&quot;hello&quot;,&quot;world&quot;,&quot;&quot;,&quot;ok&quot;&#125;;</div><div class="line">auto v = iv.begin(), ve = iv.end();</div><div class="line">(*v).empty();使用字符串的empty方法检查是否为空</div><div class="line">v -&gt; empty();和上面等价</div></pre></td></tr></table></figure>
<h3 id="bitset对象"><a href="#bitset对象" class="headerlink" title="bitset对象"></a><code>bitset</code>对象</h3><p><code>bitset</code>对象在头文件<code>bitset</code>中</p>
<p>定义<code>bitset</code>对象时指定长度： <code>bitset&lt;32&gt; b;</code></p>
<p><code>bitset</code>对象操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b.any</code></td>
<td>是否存在1</td>
</tr>
<tr>
<td><code>b.none</code></td>
<td>不存在1</td>
</tr>
<tr>
<td><code>b.count</code></td>
<td>1的个数，size_t类型（cstddef头文件中）</td>
</tr>
<tr>
<td><code>b.size</code></td>
<td>二进制位个数</td>
</tr>
<tr>
<td><code>b[pos]</code></td>
<td>pos位的二进制数</td>
</tr>
<tr>
<td><code>b.test(pos)</code></td>
<td>pos位是否为1</td>
</tr>
<tr>
<td><code>b.set</code></td>
<td>所有位置1</td>
</tr>
<tr>
<td><code>b.set(pos)</code></td>
<td>pos位置1</td>
</tr>
<tr>
<td><code>b.reset</code></td>
<td>所有位置0</td>
</tr>
<tr>
<td><code>b.reset(pos)</code></td>
<td>pos位置0</td>
</tr>
<tr>
<td><code>b.flip</code></td>
<td>取反</td>
</tr>
<tr>
<td><code>b.flip(pos)</code></td>
<td>pos位取反</td>
</tr>
<tr>
<td><code>b.to_ulong()</code></td>
<td>返回一个unsigned long 值</td>
</tr>
<tr>
<td><code>os &lt;&lt; b</code></td>
<td>输出到流</td>
</tr>
</tbody>
</table>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组定义和初始化"><a href="#数组定义和初始化" class="headerlink" title="数组定义和初始化"></a>数组定义和初始化</h2><ul>
<li>非const变量以及只有在运行后才能知道值的const变量不能用于定义数组维度</li>
<li>使用字符串初始化数组，默认在最后添加一个空字符 <code>&#39;\0&#39;</code>（C风格字符串）</li>
<li>如果数组元素类型为类，自动调用类默认构造函数初始化</li>
<li>定义数组必须指定数组类型，不能使用auto由初始值推导，数组元素为对象，所以不存在引用的数组</li>
<li>数组的索引是<code>size_t</code>类型</li>
<li>指针（指向数组元素）相减是<code>ptrdiff_t</code>类型（带符号）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p[10];//指针数组</div><div class="line">int (*p)[10];//数组指针</div><div class="line">int &amp;p[10];//错误，没有引用的数组</div><div class="line">int (&amp;p)[10];//数组的引用</div><div class="line">int *(&amp;p)[10];//指针数组的引用</div></pre></td></tr></table></figure>
<p>支持范围for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;</div><div class="line">for (int i: a)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++11标准引入begin和end函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;</div><div class="line">int *p = begin(a);</div><div class="line">int *pe = end(a);</div><div class="line">while(p != pe)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; *p &lt;&lt; endl;</div><div class="line">    ++p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以使用数组初始化<code>vector</code>，反过来不行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a[] = &#123;1,2,3,4,5&#125;</div><div class="line">vector&lt;int&gt; iv(begin(a), end(a))</div></pre></td></tr></table></figure>
<h2 id="C风格字符串标准库函数"><a href="#C风格字符串标准库函数" class="headerlink" title="C风格字符串标准库函数"></a>C风格字符串标准库函数</h2><p><code>cstring</code>是<code>string.h</code>头文件的C++版本</p>
<p>可以使用C风格字符串来初始化string对象，反过来不行</p>
<p>可以使用string的<code>c_string()</code>方法来初始化，不能保证一直有效，最好拷贝一份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string as(&quot;hello world&quot;);</div><div class="line">const char *str = as.c_str();//指针类型是const char*</div><div class="line">cout &lt;&lt; strlen(str) &lt;&lt; endl;</div></pre></td></tr></table></figure>
<p>C风格字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    const char *a = &quot;hello&quot;;</div><div class="line">    char b[] = &quot;world&quot;;</div><div class="line">    char d[40]; //要足够大，否则会出错</div><div class="line">    strcpy(d, b); //b拷贝给d</div><div class="line">    strcat(d,b); //b附加到d后面</div><div class="line">    std::cout  &lt;&lt;  strlen(a) &lt;&lt; std::endl;</div><div class="line">    std::cout  &lt;&lt;  strlen(b) &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C中使用<code>malloc</code>和<code>free</code>分配储存空间<br>C++中使用<code>new</code>和<code>delete</code></p>
<p><code>new</code>表达式返回指向新分配数组的第一个元素的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *pia = new int[10];</div></pre></td></tr></table></figure></p>
<p>如果数组元素具有类类型，使用默认构造函数进行初始化，或者使用括号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string *psa = new string[10];</div><div class="line">int *pib = new int[10]();</div></pre></td></tr></table></figure></p>
<p>数组长度可以在程序运行时动态决定，并且，长度0也是合法的</p>
<p>使用<code>delete</code>释放内存，<strong>注意</strong>方括号不能缺少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete [] pia;</div></pre></td></tr></table></figure></p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p><code>sizeof()</code></p>
<ul>
<li>返回类型所占字节数</li>
<li>返回指针本身所占空间大小</li>
<li>返回解引用指针所指对象大小，指针不需有效</li>
<li>返回整个数组所占空间大小</li>
<li>不会返回string和vector的元素所占空间，返回类型固定部分大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a[] = &#123;1,2,3,4,5,6,7&#125;;</div><div class="line">int *p = a;</div><div class="line">sizeof(a);//4*7=28</div><div class="line">sizeof(p);//28</div><div class="line">sizeof(*p);//4</div></pre></td></tr></table></figure>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>从左往右计算，丢弃左值，保留最右侧表达式的值</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>强制类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cast-name&lt;type&gt;(expression);</div></pre></td></tr></table></figure>
<p><code>cast-name</code>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种</p>
<p><code>static_cast</code><br>只要不包含底层<code>const</code>，就可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int i&#123;10&#125;, j&#123;19&#125;;</div><div class="line">double slope = static_cast&lt;double&gt;(j) / i;</div><div class="line">cout &lt;&lt; slope &lt;&lt; endl;//输出1.9</div><div class="line"></div><div class="line">//用于找回存在与void*指针中的值</div><div class="line">double d = 10;</div><div class="line">void *p = &amp;d;</div><div class="line">double *dp = static_cast&lt;double *&gt;(p);</div><div class="line">cout &lt;&lt; *dp &lt;&lt; endl;//输出10</div></pre></td></tr></table></figure>
<p><code>const_cast</code>只能改变对象的底层const</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const int ci = 1;</div><div class="line">const int *cp = &amp;ci;</div><div class="line">int *p = const_cast&lt;int *&gt;(cp);</div><div class="line">*p += 1;</div><div class="line">cout &lt;&lt; ci &lt;&lt; *cp &lt;&lt; *p &lt;&lt; endl;//输出：1 2 2</div></pre></td></tr></table></figure>
<p><code>reinterpret_cast</code>为运算对象的位模式提供较低层次上的重新解释</p>
<p>使用<code>reinterpret_cast</code>非常危险，本质上依赖机器</p>
<h1 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h1><p><code>throw</code> 语句用于抛出异常，可以使用<code>try</code>捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    try  </div><div class="line">    &#123;  </div><div class="line">        if (1)</div><div class="line">            throw 1;</div><div class="line">    &#125;  </div><div class="line">    catch(int i)  </div><div class="line">    &#123;  </div><div class="line">        cout &lt;&lt; i  &lt;&lt; endl;  </div><div class="line">    &#125;  </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用标准异常类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;exception&gt;  </div><div class="line">using namespace std;</div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    try  </div><div class="line">    &#123;  </div><div class="line">        int *myarray = new int[10000000000];</div><div class="line">    &#125;  </div><div class="line">    catch(exception&amp; e)  </div><div class="line">    &#123;  </div><div class="line">        cout &lt;&lt; e.what() &lt;&lt; endl;   //输出 std::bad_alloc</div><div class="line">    &#125;  </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>stdexcept</code>头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;stdexcept&gt;</div><div class="line">using namespace std;</div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int val(10);</div><div class="line">    if (val == 10)</div><div class="line">    &#123;</div><div class="line">        throw runtime_error(&quot;test err&quot;);//中断程序运行</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用try catch捕获</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int val(10);</div><div class="line">    try</div><div class="line">    &#123;</div><div class="line">        if (val == 10)</div><div class="line">        &#123;</div><div class="line">            throw runtime_error(&quot;test err&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;catch (runtime_error err)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; err.what();</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl; //后面继续运行</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h3><p>引用形参，相当于将形参与实参绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void swap(int &amp;v1,int &amp;v2)</div><div class="line">&#123;</div><div class="line">    int temp = v2;</div><div class="line">    v2 = v1;</div><div class="line">    v1 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a(1),b(2);</div><div class="line">    swap(a,b);</div><div class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用const引用可以避免复制，提高效率</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bool longer(const string &amp;s1,const string &amp;s2)</div><div class="line">&#123;</div><div class="line">    return s1.size() &lt; s2.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不用修改参数，就把形参定义为const，否则传入const参数会出现编译错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt; </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool longer(string &amp;v1,string &amp;v2) //非const</div><div class="line">&#123;</div><div class="line">    return v1.size() &lt; v2.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    if(longer(&quot;asdasd&quot;,&quot;asdasda&quot;)) //编译出错</div><div class="line">    &#123;</div><div class="line">        //</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>指针引用</strong></p>
<p><code>int *&amp;v1</code>是指针引用形参，&amp;v1理解为指针，所以需要在前面添加<code>*</code>符号</p>
<p>从右往左读符号，最靠近变量名的有最直接影响</p>
<p>下例只交换了两个指针的地址，而a、b的内容并没有交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void swap(int *&amp;v1,int *&amp;v2)</div><div class="line">&#123;</div><div class="line">    int *temp = v2;</div><div class="line">    v2 = v1;</div><div class="line">    v1 = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a(1),b(2);</div><div class="line">    int *pa = &amp;a;</div><div class="line">    int *pb = &amp;b;</div><div class="line">    cout &lt;&lt; *pa &lt;&lt; *pb &lt;&lt; endl; //1 2</div><div class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; //1 2</div><div class="line">    swap(pa,pb);</div><div class="line">    cout &lt;&lt; *pa &lt;&lt; *pb &lt;&lt; endl; // 2 1</div><div class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl; // 1 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器形参"><a href="#迭代器形参" class="headerlink" title="迭代器形参"></a>迭代器形参</h3><p>vector等容器把迭代器作为参数传递，下例输出6个8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void print(</div><div class="line">    vector&lt;int&gt;::const_iterator beg,</div><div class="line">    vector&lt;int&gt;::const_iterator end</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    while (beg != end)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *beg++ &lt;&lt; &apos; &apos;; //++符具有更高优先级，== *(beg++)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    vector&lt;int&gt; v(6,8);</div><div class="line">    print(v.begin(),v.end());</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用标准库规范"><a href="#使用标准库规范" class="headerlink" title="使用标准库规范"></a>使用标准库规范</h3><p>传递指向数组首元素和尾后元素的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void print(const int *begin, const int *end)</div><div class="line">&#123;</div><div class="line">    while(begin != end)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *begin++ &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</div><div class="line">    print (begin(a), end(a));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>除了传递数组指针外，还可以使用引用传递数组<code>int (&amp;array)[]</code><br>引用后，array和a地址相同，即为同一个东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void print(int (&amp;array)[10])</div><div class="line">&#123;</div><div class="line">    for (auto i: array)</div><div class="line">        cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int a[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</div><div class="line">    print (a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注：</strong><br>    <code>int *array[10]</code> 是十个指针组成的数组 :指针数组<br>    <code>int (*array)[10]</code> 是十个元素的数组的指针:数组指针</p>
<h3 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h3><p>传递多维数组时需要传递两个维度的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//这两个是等价的</div><div class="line">void print(int (*array)[10], int rowsize)&#123; ... &#125;</div><div class="line">void print(int array[][10], int rowsize)&#123; ... &#125;</div></pre></td></tr></table></figure>
<h3 id="main函数传递参数"><a href="#main函数传递参数" class="headerlink" title="main函数传递参数"></a>main函数传递参数</h3><p><code>argv</code>是一个数组，0是文件名，往后是输入的参数，<code>argc</code>表示数组中字符串的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123;  </div><div class="line">    string s1, s2;</div><div class="line"></div><div class="line">    s1 = argv[1];</div><div class="line">    s2 = argv[2];</div><div class="line"></div><div class="line">    cout &lt;&lt; s1 + s2 &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./hello hello world</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloworld</div></pre></td></tr></table></figure></p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>如果所有参数类型相同，可以使用<code>initializer_list</code>标准库类型，在同名头文件中  (198页)</p>
<p>和vector不一样的是，该对象中的元素永远是常量值，无法改变元素值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void err_message(initializer_list&lt;string&gt; il)</div><div class="line">&#123;</div><div class="line">    for (auto beg = il.begin(); beg != il.end(); ++beg)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    err_message(&#123;&quot;test&quot;, &quot;err&quot;&#125;); //放在一对花括号内</div><div class="line">    err_message(&#123;&quot;func&quot;, &quot;test&quot;, &quot;ok&quot;&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数不能返回局部变量的引用或者指针，因为临时对象的空间已经释放<br>函数可以返回一个引用作为左值，注意函数返回类型是引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">char &amp;get_val(string &amp;str,string::size_type ix)</div><div class="line">&#123;</div><div class="line">    return str[ix];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    string s(&quot;asdasd&quot;);</div><div class="line">    get_val(s,0) = &apos;-&apos;;</div><div class="line">    cout &lt;&lt; s &lt;&lt; endl;//输出：-sdasd</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>C++11新标准规定，函数可以返回花括号包围的值的列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vector&lt;string&gt; process()</div><div class="line">&#123;</div><div class="line">    return &#123;&quot;test&quot;, &quot;return&quot;, &quot;vector&quot;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    vector&lt;string&gt; sv = process();</div><div class="line">    for (auto s: sv)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; s &lt;&lt; endl; //输出：test return vector</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>注意 <code>char*</code>类型到<code>int</code>类型的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int fun(int val)</div><div class="line">&#123;</div><div class="line">    if (val != 1)</div><div class="line">    &#123;</div><div class="line">        return fun(val - 1) * val;</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main (int argc, char *argv[]) </div><div class="line">&#123;  </div><div class="line">    int num = atoi(argv[1]); //类型转换</div><div class="line">    cout &lt;&lt; fun(num) &lt;&lt; endl; //输入：./hello 4 输出：24</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回数组的指针"><a href="#返回数组的指针" class="headerlink" title="返回数组的指针"></a>返回数组的指针</h3><p>声明一个数组指针函数 (205页)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int array[10];//含有10个元素的数组</div><div class="line">int (*p)[10] = &amp;array ;//数组的指针</div><div class="line">int (*func(int i))[10]; //返回数组指针的函数</div></pre></td></tr></table></figure>
<ul>
<li><code>func(int i)</code>函数接受一个整数实参</li>
<li><code>(*func(int i))</code>可以对函数调用结果进行解引用</li>
<li><code>(*func(int i))[10]</code>解引用后得到的是大小为10的数组</li>
<li><code>int (*func(int i))[10]</code>数组的元素类型为<code>int</code></li>
</ul>
<p>举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int array[10];</div><div class="line"></div><div class="line">int (*func(int i))[10] //接受一个参数，将数组的元素全部赋值为该值</div><div class="line">&#123;</div><div class="line">    int (*p)[10] = &amp;array;</div><div class="line">    for (auto &amp;elem: array)</div><div class="line">    &#123;</div><div class="line">        elem = i;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int (*pp)[10] = func(2); //接受参数2，返回一个数组的指针</div><div class="line">    for (auto elem: *pp)</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; elem &lt;&lt; endl;//输出10个2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用尾置返回类型方式<br>C++11新标准使用<strong>尾置返回类型</strong>简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//func接受一个int类型实参，返回一个指针，这个指针指向含有10个整数元素的数组</div><div class="line">auto func(int i) -&gt; int(*)[10];</div></pre></td></tr></table></figure>
<p>函数改成这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">auto func(int i) -&gt; int(*)[10]</div><div class="line">&#123;</div><div class="line">    int (*p)[10] = &amp;array;</div><div class="line">    for (auto &amp;elem: array)</div><div class="line">    &#123;</div><div class="line">        elem = i;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果已经知道具体的数组，使用<code>decltype</code>获取类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int array[10];</div><div class="line"></div><div class="line">decltype(array) *func(int i) //decltype返回的是个数组，所以还需要添加*符号</div><div class="line">&#123;</div><div class="line">    int (*p)[10] = &amp;array;</div><div class="line">    for (auto &amp;elem: array)</div><div class="line">    &#123;</div><div class="line">        elem = i;</div><div class="line">    &#125;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h2><p>重载函数是相同的函数名不同参数的函数，（main函数不能重载）<br>重载函数在参数数量或者参数类型上有所不同<br>不允许 “除了返回类型其他都相同” 的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void hi(const int i) //const int 参数</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int hi(const string str)//const string 参数</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; str &lt;&lt; endl;</div><div class="line">    return str.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    hi(hi(&quot;hello world&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h3><p>顶层<code>const</code>不影响传入函数的对象<br>引用和指针通过判断是否是常量区分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lookup(Phone);</div><div class="line">lookup(Phone const);//错误，重复声明了lookup(Phone)</div><div class="line"></div><div class="line">lookup(Phone *);</div><div class="line">lookup(Phone *const);//错误，重复声明了lookup(Phone *)</div><div class="line"></div><div class="line">lookup(Phone &amp;);//Phone的引用</div><div class="line">lookup(const Phone &amp;);//正确，常量引用</div><div class="line"></div><div class="line">lookup(Phone *);//指向Phone的指针</div><div class="line">lookup(const Phone *);//正确，指向常量的指针</div></pre></td></tr></table></figure>
<p><code>const_cast</code>在重载函数的情景中最有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const string &amp;shortstring(const string &amp;s1, const string &amp;s2) //接收常量</div><div class="line">&#123;</div><div class="line">    return s1.size() &lt;= s2.size() ? s1: s2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//重载</div><div class="line">string &amp;shortstring(string &amp;s1, string &amp;s2) //接受string引用</div><div class="line">&#123;</div><div class="line">    auto &amp;r = shortstring(const_cast&lt;const string&amp;&gt;(s1),  </div><div class="line">        const_cast&lt;const string&amp;&gt;(s2)); //使用const_cast强制转换为常量</div><div class="line">    return const_cast&lt;string&amp;&gt;(r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    string s1&#123;&quot;hello&quot;&#125;;</div><div class="line">    string s2&#123;&quot;world!&quot;&#125;;</div><div class="line">    cout &lt;&lt; shortstring(s1,s2) &lt;&lt; endl;//传入string引用</div><div class="line">    cout &lt;&lt; shortstring(&quot;justfor&quot;,&quot;test&quot;) &lt;&lt; endl;//传入常量</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数可以避免函数调用的开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用inline关键词定义</div><div class="line">inline </div><div class="line">const string &amp;shortstring(const string &amp;s1, const string &amp;s2) </div><div class="line">&#123;</div><div class="line">    return s1.size() &lt;= s2.size() ? s1: s2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    cout &lt;&lt; shortstring(&quot;justfor&quot;,&quot;test&quot;) &lt;&lt; endl;//传入常量</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cout &lt;&lt;  s1.size() &lt;= s2.size() ? s1: s2 &lt;&lt; endl;</div></pre></td></tr></table></figure>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a><code>constexpr</code>函数</h3><p><code>constexpr</code>是指能用于常量表达式的函数，遵守以下规定：</p>
<ul>
<li>函数的返回类型和形参必须是字面值，或者可以是但不一定是另一个常量表达式函数</li>
<li>有且只有一个return语句</li>
<li>常量表达式函数和内联函数一般定义在头文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">constexpr int new_sz() &#123;return 2;&#125;</div><div class="line">constexpr int scale(int t) &#123;return new_sz() * t;&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int array[scale(2)]; //相当于int array[4]</div><div class="line">    cout &lt;&lt; scale(2) &lt;&lt; endl;//输出4</div><div class="line">    int i  = 2;</div><div class="line">    int a2[scale(i)] = &#123;1,2,3,4&#125;;//错误，scale(i)不是常量表达式</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><code>assert</code>预处理宏，定义在<code>cassert</code>头文件中<br>如果<code>expr</code>为假，输出信息，终止程序执行，如果<code>expr</code>为真，什么也不做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(expr)</div></pre></td></tr></table></figure>
<p>预处理宏由预处理器管理，无需使用<code>std::</code>和<code>using</code>声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int i = 0;</div><div class="line">    cin &gt;&gt; i;</div><div class="line">    assert(i &gt; 5);//如果输入3，输出：Assertion `i &gt; 5&apos; failed</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>assert</code>依赖于<code>NDEBUG</code>预处理变量的状态，如果定义了<code>NDEBUG</code>，<code>assert</code>什么也不做<br>编译器提供命令选项定义这个预处理变量，相当于在文件一开始写<code>#define NDEBUG</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ hello.cc -o hello -D NDEBUG</div></pre></td></tr></table></figure>
<p>也可以自己写调试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    int i = 0;</div><div class="line">    cin &gt;&gt; i;</div><div class="line">    #ifndef NDEBUG</div><div class="line">        cout &lt;&lt; &quot;i is: &quot; &lt;&lt; i &lt;&lt; endl;</div><div class="line">    #endif</div><div class="line">    cout &lt;&lt; i &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>C++</code>编译器定义了一些局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__func__ 当前函数名，是const char的一个静态数组</div><div class="line">__FILE__ 存放文件名的字符串字面值</div><div class="line">__LINE__ 存放当前行号的整型字面值</div><div class="line">__TIME__ 存放文件编译时间的字符串字面值</div><div class="line">__DATE__ 存放文件编译日期的字符串字面值</div></pre></td></tr></table></figure>
<h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><p>精准匹配（相同、数组-&gt;指针、函数-&gt;指针、删除或添加顶层const） &gt; const转换 &gt; 类型提升 &gt; 标准转换（算术转换、指针转换） &gt; 类类型转换（219）</p>
<p>指针值（const char<em>）可以隐式转换为bool类型，为标准转换<br>指针值（const char</em>）到sting为类类型转换<br>所以第二个匹配度更高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void find(const string &amp;s1, const string &amp;s2, bool b = &quot;true&quot;)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;1&quot;  &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">void find(const string &amp;s, bool b = &quot;true&quot;)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    find(&quot;hello&quot;,&quot;world&quot;);//输出：2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数的类型由返回类型和形参类型共同决定，声明一个指向函数的指针，需要指定返回类型和形参类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bool (*pf) (const string &amp;, const string &amp;);//没有初始化的函数指针</div><div class="line">bool shortstring(const string &amp;, const string &amp;);//一个函数</div><div class="line">pf = shortstring;//pf指向shortstring函数</div><div class="line">pf = &amp;shortstring;//取址符是可选的</div><div class="line">pf(&quot;hello&quot;, &quot;world&quot;);//调用</div><div class="line">(*pf)(&quot;hello&quot;, &quot;world&quot;);//等价的</div></pre></td></tr></table></figure>
<p>和数组类型相似<br>虽然不能定义函数类型的形参，但是可以定义指向函数的指针的形参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//第三个参数是形参类型，自动转换成函数指针（精准匹配）</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;))</div><div class="line">//第三个参数是个函数指针，等价</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;))</div><div class="line">//函数作为参数，自动转换</div><div class="line">whichshort(s1, s2, shortstring)</div></pre></td></tr></table></figure>
<p>使用decltype简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef decltype(shortstring) Fun;//函数类型</div><div class="line">typedef decltype(shortstring) *FunP;//函数指针</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, Fun);//下面俩和之前等价</div><div class="line">void whichshort(const string &amp;s1, const string &amp;s2, FunP);</div></pre></td></tr></table></figure>
<p>虽然不能返回函数，但是可以返回函数指针，然而要写出返回类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//使用类型别名</div><div class="line">using F = int(int*, int);//函数类型</div><div class="line">using PF = int (*)(int*, int);//函数指针</div><div class="line">//定义</div><div class="line">PF f1(int);//返回函数指针的函数</div><div class="line">F *f1(int);//等价的</div><div class="line">//相当于</div><div class="line">//返回一个接受int* 和int参数返回int的函数的指针，接受一个int参数的函数</div><div class="line">int (*f1(int)) (int*, int);</div></pre></td></tr></table></figure></p>
<p>使用尾置返回类型的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto f1(int) -&gt; int(*)(int*, int);</div></pre></td></tr></table></figure>
<p>和返回数组指针类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auto func(int i) -&gt; int(*)[10];</div></pre></td></tr></table></figure>
<p>使用decltype，注意<code>*</code>符号不能少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">decltype(fun) *f1(int);</div></pre></td></tr></table></figure></p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><p>定义一个自定义数据类型<code>Sales_data</code>，这并不是抽象数据类型，需要编写操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h3><ul>
<li>成员函数必须声明在内部，定义可以在外部或者内部，定义在内部的函数是隐式的（inline）</li>
<li>非成员函数必须定义和声明在外部</li>
<li>即使数据成员定义在成员函数之后，也可以使用数据，编译器首先编译成员的声明，然后才是成员函数体</li>
<li>外部定义的成员函数除了与声明必须匹配外，必须包含类名</li>
<li><code>combine()</code>函数类似于<code>+=</code>，返回的是<code>this</code>对象，即调用这个函数的对象，像这样调用<code>some.combine(another);</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    //成员函数</div><div class="line">    string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">    //数据成员</div><div class="line">    string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//非成员函数</div><div class="line">Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</div><div class="line">ostream &amp;print(ostream&amp;, const Sales_data);</div><div class="line">istream &amp;read(istream&amp;, const Sales_data);</div><div class="line">//外部定义成员函数</div><div class="line">Sales_data&amp; Sales_data::combine(const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    unit += sd.unit; //将 sd 的成员加到 this 的对象上</div><div class="line">    revenue += sd.revenue;</div><div class="line">    return *this; //返回调用这个函数的对象</div><div class="line">&#125;</div><div class="line">double Sales_data::avg_price() const</div><div class="line">&#123;</div><div class="line">    if (unit)</div><div class="line">        return revenue/unit;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>some.getname()</code>就相当于<code>getname(&amp;some)</code></li>
<li>成员函数通过一个隐式的<code>this</code>参数来访问对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string getname() const &#123;return name;&#125;</div><div class="line">//上面这句也可以这么定义，但一般不这么做</div><div class="line">string getname() const &#123;return this -&gt; name;&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>getname()</code>函数后有一个<code>const</code>关键字，作用是修改隐式<code>this</code>指针的类型</li>
<li>默认情况下，<code>this</code>的类型是指向类类型的常量指针<code>Sales_data *const</code></li>
<li><code>getname()</code>函数不会修改<code>this</code>所指对象，因此应该把this设置为指向常量指针</li>
<li>即<code>const Sales_data *const</code></li>
<li><code>const</code>关键字位置是紧跟在参数列表后</li>
</ul>
<h3 id="定义非成员函数"><a href="#定义非成员函数" class="headerlink" title="定义非成员函数"></a>定义非成员函数</h3><ul>
<li>一般把一些辅助函数，比如add、read和print等定义为非成员函数</li>
<li>定义非成员函数也和其他函数一样，通常把函数的声明和定义分开</li>
<li>因为IO类型不能被复制，所以用引用作为参数</li>
<li><code>print()</code>不负责换行，一般来说，执行输出的函数应该尽量减少对格式的控制，由用户决定</li>
<li>调用方式：<code>read(cin, some)</code>、<code>print(cout, some) &lt;&lt; endl</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">istream &amp;read(istream &amp;is, Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    double price = 0;</div><div class="line">    is &gt;&gt; sd.name &gt;&gt; sd.unit &gt;&gt; price;</div><div class="line">    sd.revenue = price * sd.unit;</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ostream &amp;print(ostream &amp;os, const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; sd.getname() &lt;&lt; &quot; &quot; &lt;&lt; sd.unit &lt;&lt; &quot; &quot;</div><div class="line">        &lt;&lt; sd.revenue &lt;&lt; &quot; &quot; &lt;&lt; sd.avg_price();</div><div class="line">    return os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>add()</code>函数中，使用<code>sd1</code>来初始化<code>sum</code></li>
<li>然后调用<code>combine()</code>函数把<code>sd2</code>数据成员加到<code>sum</code>中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    Sales_data sum = sd1; //把sd1的数据成员拷贝给sum</div><div class="line">    sum.combine(sd2); //相当于 +=</div><div class="line">    return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>构造函数的任务是初始化类对象的数据成员，类创建时执行</li>
<li>构造函数的名字和类名相同，没有返回类型，不能声明为<code>const</code></li>
<li>如果类定义没有提供初始值，编译器隐式定义一个默认构造函数<ul>
<li>如果类内成员有初始值，使用其初始化</li>
<li>否则，默认初始化该成员</li>
</ul>
</li>
<li>如果一个构造函数为所有形参提供了默认参数，也相当于是个默认构造函数</li>
<li>构造函数类似重载函数，类可以包含多个构造函数<ul>
<li><code>= default</code>是C++新标准，表示要求编译器生成默认构造函数</li>
<li>如果定义了其他构造函数而不指明<code>=default</code>，使用默认构造函数将出错</li>
<li>括号内为参数（可能为空），花括号内是函数体（可能为空）</li>
<li>之间的是构造函数初始值列表</li>
</ul>
</li>
<li>如果是const、引用或未提供默认构造函数的类类型，必须通过构造函数初始化列表而非赋值提供初值</li>
<li>在构造函数前加关键字<code>explicit</code>可以阻止隐式转换</li>
<li>函数前加<code>~</code>是析构函数，对象删除时自动调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">    //数据成员</div><div class="line">    string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//外部定义构造函数，初始值列表为空，函数体进行初始化</div><div class="line">Sales_data::Sales_data(istream &amp;is)</div><div class="line">&#123;</div><div class="line">    read(is, *this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用构造函数初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data sd1; //默认构造函数，初始化为：&apos;&apos; 0 0</div><div class="line">Sales_data sd2(&quot;hello&quot;); //初始化为：&apos;hello&apos; 0 0</div><div class="line">Sales_data sd3(&quot;hello&quot;, 2, 2); //初始化为：&apos;hello&apos; 2 4</div><div class="line">Sales_data sd4(cin); //根据输入初始化</div><div class="line"></div><div class="line">print(cout, sd3) &lt;&lt; endl; //输出：hello 2 4 2ll</div></pre></td></tr></table></figure></p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//非委托构造函数</div><div class="line">Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">    name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">//委托构造函数</div><div class="line">Sales_data() : Sales_data(&quot;&quot;, 0, 0) &#123;&#125;</div><div class="line">Sales_data(std::string s) : Sales_data(s, 0, 0) &#123;&#125;</div><div class="line">Sales_data (std::istream &amp;is) : Sales_data() &#123;read(is, *this);&#125;</div></pre></td></tr></table></figure>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul>
<li>类结构体定义和非成员函数声明放在<code>sales_data.h</code>中</li>
<li>注意，不要在头文件中使用<code>using namespace std;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#ifndef SALES_DATA_H</div><div class="line">#define SALES_DATA_H </div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"></div><div class="line">struct Sales_data</div><div class="line">&#123;</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const std::string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (std::istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">    //数据成员</div><div class="line">    std::string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//非成员函数声明</div><div class="line">std::istream &amp;read(std::istream &amp;is, Sales_data &amp;sd);</div><div class="line">std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;sd);</div><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<ul>
<li>外部定义的成员函数和非成员函数放在<code>sales_data.cc</code>中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &quot;sales_data.h&quot;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">//外部定义成员函数</div><div class="line">Sales_data&amp; Sales_data::combine(const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    unit += sd.unit;</div><div class="line">    revenue += sd.revenue;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line">double Sales_data::avg_price() const</div><div class="line">&#123;</div><div class="line">    if (unit)</div><div class="line">        return revenue/unit;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义非成员函数</div><div class="line">istream &amp;read(istream &amp;is, Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    double price = 0;</div><div class="line">    is &gt;&gt; sd.name &gt;&gt; sd.unit &gt;&gt; price;</div><div class="line">    sd.revenue = price * sd.unit;</div><div class="line">    return is;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ostream &amp;print(ostream &amp;os, const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; sd.getname() &lt;&lt; &quot; &quot; &lt;&lt; sd.unit &lt;&lt; &quot; &quot;</div><div class="line">        &lt;&lt; sd.revenue &lt;&lt; &quot; &quot; &lt;&lt; sd.avg_price();</div><div class="line">    return os;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2)</div><div class="line">&#123;</div><div class="line">    Sales_data sum = sd1;</div><div class="line">    sum.combine(sd2);</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//外部定义构造函数</div><div class="line">Sales_data::Sales_data(istream &amp;is)</div><div class="line">&#123;</div><div class="line">    read(is, *this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在主文件使用include导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &quot;sales_data.h&quot;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main () </div><div class="line">&#123;  </div><div class="line">    Sales_data sd(cin);</div><div class="line">    print(cout, sd) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="访问控制和封装"><a href="#访问控制和封装" class="headerlink" title="访问控制和封装"></a>访问控制和封装</h2><ul>
<li>自定义数据类型没有强制要求使用接口，仍可访问对象内部</li>
<li>使用访问说明符加强类的封装性<ul>
<li>定义在<code>public</code>说明符后的成员可以在整个程序内被访问</li>
<li>定义在<code>private</code>说明符后的成员只能被类的成员函数访问，即隐藏了类的实现细节</li>
</ul>
</li>
</ul>
<p>当使用<code>class</code>关键字，并且添加了<code>private</code>说明符之后，部分函数（非成员函数）不能正常编译了<br><code>class</code>和<code>struct</code>关键字唯一区别是默认访问权限变化了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const std::string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (std::istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    std::string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>类类型</p>
<ul>
<li>类可以在定义之前声明，比如：<code>class Salse_data;</code></li>
<li>不过注意在声明之后、定义之前，编译器并不清楚类的具体内容（不完全类型），期间不能使用其成员</li>
<li>成员函数体在整个类成员可见之后才被处理</li>
<li>类型名的定义通常出现在类的开始处，确保使用该类型的成员都出现在类型名定义之后</li>
</ul>
<p>友元</p>
<ul>
<li>类也可以让其他类或者函数访问它的非公有成员，可以把函数声明为友元</li>
<li>声明为友元，需要添加一条以关键字<code>friend</code>开头的函数声明</li>
<li>友元声明可以出现在类内的任意位置，但最好在类定义开头或者结尾集中声明</li>
<li>友元的声明仅仅指定了访问权限，所以还需要再次声明以供用户调用</li>
<li>指定一个类作为友元，那么那个类就可以访问此类的所有成员</li>
<li><code>All_date</code>就是<code>Sales_data</code>的友元，<code>All_data</code>内成员函数可以调用<code>Sales_data</code>所有成员</li>
<li>注意友元没有传递性，<code>Salses_data</code>的友元的友元并不能访问其内部成员</li>
<li>如果只将某个类的某个成员函数声明为友元，需要注意步骤<ul>
<li>先定义<code>All_data</code>类，声明但不定义<code>clear()</code>函数，如果用到<code>Sales_data</code>类，需要先申明<code>class Salse_data</code></li>
<li>然后定义<code>Salse_data</code>类，声明<code>clear()</code>友元，注意在定义之前不能访问类内成员</li>
<li>最后再定义<code>clear()</code>函数<br>-如果将重载函数声明为友元，需要将每个函数依次声明</li>
</ul>
</li>
</ul>
<p>正常的声明友元<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">//非成员函数友元声明</div><div class="line">friend std::istream &amp;read(std::istream &amp;is, Sales_data &amp;sd);</div><div class="line">friend std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;sd);</div><div class="line">friend Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line">friend class All_data;//友元类</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    Sales_data() = default; //C++11标准，表示要求编译器生成默认构造函数</div><div class="line">    Sales_data(const std::string &amp;s) : name(s) &#123;&#125; //使用构造函数初始值列表</div><div class="line">    Sales_data(const std::string &amp;s, unsigned n, double p) :</div><div class="line">        name(s), unit(n), revenue(p*n) &#123;&#125;</div><div class="line">    Sales_data (std::istream &amp;); //内部声明，外部定义</div><div class="line">    //成员函数</div><div class="line">    std::string getname() const &#123;return name;&#125;</div><div class="line">    Sales_data&amp; combine(const Sales_data&amp;);</div><div class="line">    double avg_price() const;</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    std::string  name;</div><div class="line">    unsigned unit = 0;</div><div class="line">    double revenue  = 0.0;</div><div class="line">&#125;;</div><div class="line">//非成员函数声明</div><div class="line">std::istream &amp;read(std::istream &amp;is, Sales_data &amp;sd);</div><div class="line">std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;sd);</div><div class="line">Sales_data add(const Sales_data &amp;sd1, const Sales_data &amp;sd2);</div><div class="line"></div><div class="line">class All_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using SaleIndex = std::vector&lt;Sales_data&gt;::size_type; //容器index类型</div><div class="line">    void clear(SaleIndex i);</div><div class="line">private:</div><div class="line">    std::vector&lt;Sales_data&gt; sales_datas&#123;Sales_data(&quot;hello&quot;,2,2)&#125;; //存放Salse_data的容器</div><div class="line">&#125;;</div><div class="line"></div><div class="line">inline</div><div class="line">void All_data::clear(SaleIndex i) //清空容器内某个Salse_date类型的内容</div><div class="line">&#123;</div><div class="line">    Sales_data &amp;sd = sales_datas[i];</div><div class="line">    sd.name = std::string(&quot;&quot;);</div><div class="line">    sd.unit = 0;</div><div class="line">    sd.revenue = 0;</div><div class="line">    sd.num = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只将类的某个成员函数声明为友元<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Sales_data; //因为用到`Sales_data`，需要先声明</div><div class="line"></div><div class="line">class All_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using SaleIndex = std::vector&lt;Sales_data&gt;::size_type;</div><div class="line">    void clear(SaleIndex i); //声明 clear 函数</div><div class="line">    Sales_data &amp; getSale(SaleIndex i) &#123;Sales_data &amp;sd = sales_datas[i]; return sd;&#125;</div><div class="line">private:</div><div class="line">    std::vector&lt;Sales_data&gt; sales_datas; //因为`Sales_data`还没有定义，并不能初始化</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Sales_data //定义 Sales_data 类</div><div class="line">&#123;</div><div class="line">friend class All_data;</div><div class="line">/* ... */</div><div class="line">&#125;;</div><div class="line">/* ... */</div><div class="line"></div><div class="line">inline</div><div class="line">void All_data::clear(SaleIndex i) //定义 clear 函数</div><div class="line">&#123;</div><div class="line">    /* ... */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>定义在内部的成员函数默认为内联函数（inline），也可以指定外部定义的成员函数为（inline）</li>
<li>注意外部定义的inline成员函数应该与类定义放在同一个文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">inline</div><div class="line">Sales_data&amp; Sales_data::combine(const Sales_data &amp;sd)</div><div class="line">&#123;</div><div class="line">    unit += sd.unit;</div><div class="line">    revenue += sd.revenue;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line">inline</div><div class="line">double Sales_data::avg_price() const</div><div class="line">&#123;</div><div class="line">    if (unit)</div><div class="line">        return revenue/unit;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>成员函数可以被重载，这里重载了<code>numadd()</code>函数</li>
<li>即使是const成员函数，也可以修改数据成员，只要加上<code>mutable</code>关键字（mutable data member 可变数据成员）</li>
<li>当调用<code>sd.numadd()</code>时，数据成员<code>num</code>自增 1，同样的<code>sd.numadd(3)</code>自增3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    /* ... */</div><div class="line">    //成员函数</div><div class="line">    void numadd() const &#123;++num;&#125;</div><div class="line">    void numadd(int i) const &#123;num += i;&#125;</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    /* ... */</div><div class="line">    mutable int num = 0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>返回<code>*this</code>的成员函数可以实现链式调用：比如<code>myScreen.move(4,0).set(&#39;*&#39;)</code></li>
<li>如果其中有一个成员设置了<code>const</code>关键字，链式调用时会报错，因为返回的是常量引用，后续不能进行写入操作</li>
<li>通过重载可以解决这种问题</li>
<li><code>do_display()</code>函数无论是不是常量引用，都隐式转换成常量引用，然后输出</li>
<li>使用<code>do_dispay()</code>避免多处重复同样的代码，功能明显，方便调试，隐式被声明为内联函数，运行时没有额外开销</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">/* ... */</div><div class="line">public:</div><div class="line">    //构造函数</div><div class="line">    /* ... */</div><div class="line">    Sales_data &amp;addnum() &#123;++num; return *this;&#125;</div><div class="line">    Sales_data &amp;addnum(int i) &#123;num += i; return *this;&#125;</div><div class="line">    Sales_data &amp;display(std::ostream &amp;os)&#123;do_display(os); return *this;&#125; //返回一个非常量引用</div><div class="line">    const Sales_data &amp;display(std::ostream &amp;os) const &#123;do_display(os); return *this;&#125; //返回一个常量引用</div><div class="line">private:</div><div class="line">    //数据成员</div><div class="line">    /* ... */</div><div class="line">    void do_display(std::ostream &amp;os) const &#123;os &lt;&lt; name &lt;&lt; &quot; num &quot; &lt;&lt; num;&#125; //提供给内部成员函数调用</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>链式调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Sales_data sd(&quot;hello&quot;, 2, 2);</div><div class="line">sd.display(cout).addnum(10).display(cout); //这里是非常量引用</div></pre></td></tr></table></figure></p>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><ul>
<li>静态成员可以是<code>public</code>或者<code>private</code>的</li>
<li>静态成员函数不包含<code>this</code>指针，不能声明成<code>const</code></li>
<li>静态成员不与任何对象绑定在一起，使用域运算符直接访问<code>Sales_data::count</code></li>
<li>可以在类的内部或者外部定义静态成员函数</li>
<li>外部定义静态成员时，不能重复<code>static</code>关键字，该关键字只能出现在内部声明语句中</li>
<li>静态数据成员不由类的构造函数初始化，必须在类的外部定义和初始化每个静态成员，<code>int Sales_data::count = 0;</code></li>
<li>静态数据成员的定义最好和非内联函数放在一个文件中，<code>sales_data.cc</code></li>
<li>通常情况下，类的静态成员不应该在类内初始化，如果是字面值常量类型的<code>constexpr</code>，可以提供<code>const</code>初始值</li>
<li>例如：<code>static constexpr int period = 30</code>，用于类内定义维度<code>double array[period]</code></li>
</ul>
<p>静态成员的声明和定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Sales_data</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    static int getcount() &#123;return count;&#125; //没有const关键字</div><div class="line">    static void addcount() &#123;count += 1;&#125;</div><div class="line">private:</div><div class="line">    static int count; //内部声明，外部定义</div><div class="line">    static constexpr int period = 20; //字面值常量类型的constexpr，内部定义并初始化</div><div class="line">    double array[period]; //使用静态成员作为维度</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>外部定义静态成员，文件<code>Salse_data.cc</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &quot;sales_data.h&quot;</div><div class="line"></div><div class="line">int Sales_data::count = 0;</div><div class="line"></div><div class="line">//定义非成员函数</div><div class="line">/* ... */</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/31/C1/" data-id="cj5c7k2r40000m0u4t0rp84ia" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-deco" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/11/deco/" class="article-date">
  <time datetime="2016-07-11T09:11:14.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/deco/">装饰器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>从语法角度讲，装饰器就是闭包的语法糖</p>
<p>dec接受一个函数参数，返回一个加工过的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">#-*-coding:utf-8-*-</div><div class="line"></div><div class="line">def dec(func):</div><div class="line">    def in_dec(*arg):</div><div class="line">        if len(arg) == 0:</div><div class="line">            return 0</div><div class="line">        return func(*arg)</div><div class="line">    return in_dec</div><div class="line"></div><div class="line">def my_sum(*arg):</div><div class="line">    return sum(arg)</div><div class="line"></div><div class="line">my_sum = dec(my_sum)</div><div class="line"></div><div class="line"></div><div class="line">@dec</div><div class="line">def add(a,b):</div><div class="line">    return a+b</div><div class="line"></div><div class="line">print my_sum(1,2)</div><div class="line">print add(1,2)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3</div><div class="line">3</div></pre></td></tr></table></figure>
<p>这样有个副作用，</p>
<p>使用了装饰器之后，函数发生了改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print add.func_name</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">in_dec</div></pre></td></tr></table></figure>
<p>functools提供一个装饰器wraps消除这种副作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def dec(func):</div><div class="line">    @wraps(func)</div><div class="line">    def in_dec(*arg):</div><div class="line">        if len(arg) == 0:</div><div class="line">            return 0</div><div class="line">        return func(*arg)</div><div class="line">    return in_dec</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add</div></pre></td></tr></table></figure>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP是Aspect Oriented Programming（面向切面编程）的缩写，实现业务逻辑的各个部分分离。</p>
<p>比如说一些简单的打印函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def say_hi(msg):</div><div class="line">    print msg</div></pre></td></tr></table></figure>
<p>目前函数功能是打印一个消息，后来需要添加一个功能，对消息进行过滤和谐。</p>
<p>可以直接修改函数本身，但是当类似这样的函数接口比较多或者函数比较复杂时，不易于维护。</p>
<p>这时候我们可以创建一个装饰器函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def check(func):</div><div class="line">    def wrapper(msg):</div><div class="line">        if &apos;fuck&apos; in msg:</div><div class="line">            msg = msg.replace(&apos;fuck&apos;, &apos;*&apos;)</div><div class="line">            func(msg)</div><div class="line">    return wrapper</div></pre></td></tr></table></figure>
<p>这个装饰器函数的功能是接受一个函数作为参数，返回一个新的函数，该函数能过滤消息内容，并且调用原本的函数。</p>
<p>添加装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@check</div><div class="line">def say_hi(msg):</div><div class="line">    print msg</div><div class="line"></div><div class="line">say_hi(&quot;fuck you&quot;)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* you</div></pre></td></tr></table></figure>
<p>这样就在不修改原本函数的情况下实现了业务功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/11/deco/" data-id="cj5c7k382000im0u4id7n3rvt" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Haskell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/24/Haskell/" class="article-date">
  <time datetime="2016-05-24T02:19:01.000Z" itemprop="datePublished">2016-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/24/Haskell/">Haskell 函数式编程 (一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Haskell 是一种函数式编程语言</p>
<p>参考:<br><a href="http://fleurer-lee.com/lyah/" target="_blank" rel="external">Haskell 趣学指南</a><br><a href="http://cnhaskell.com/" target="_blank" rel="external">Real World Haskell</a><br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">阮一峰的网络日志</a></p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程主要思想是把运算过程尽量写成一系列嵌套的函数调用</p>
<ol>
<li><p><strong>函数是第一公民</strong><br>函数和其他数据类型相同，可以赋值或者作为参数</p>
</li>
<li><p><strong>只用表达式，不用语句</strong><br>每一步都是远算，并且都有返回值，避免不必要的读写(I/O)</p>
</li>
<li><p><strong>没有副作用</strong><br>函数只会返回一个值，不会改变其他外部变量</p>
</li>
<li><p><strong>不修改状态</strong><br>不修改变量，使用参数保存状态</p>
</li>
<li><p><strong>引用透明</strong><br>函数的运行不依赖外部变量，只依赖于输入参数</p>
</li>
</ol>
<h1 id="Haskell环境"><a href="#Haskell环境" class="headerlink" title="Haskell环境"></a>Haskell环境</h1><p>Haskell 使用的编译器是ghc，命令行输入ghci 进入交互界面</p>
<p>自定义提示符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :set prompt &quot;gchi&gt; &quot;</div><div class="line">gchi&gt;</div></pre></td></tr></table></figure></p>
<p>使用<code>:l</code>从外部导入一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gchi&gt;  :l test.hs</div></pre></td></tr></table></figure></p>
<p>使用<code>:m</code>从外部导入一个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :m +Data.Ratio</div><div class="line">Prelude Data.Ratio&gt;</div></pre></td></tr></table></figure></p>
<p>设置每次返回结果类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :set +t</div><div class="line">Prelude&gt; 2</div><div class="line">2</div><div class="line">it :: Integer</div></pre></td></tr></table></figure></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h3><p>Haskell 使用空格调用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gchi&gt; succ 1</div><div class="line">2</div></pre></td></tr></table></figure></p>
<p>在交互界面使用let和脚本中定义是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gchi&gt; let add x y = x+y</div><div class="line">gchi&gt; add 1 2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>字符串或者数组的拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gchi&gt; let a=[1,2,3,4,5]</div><div class="line">gchi&gt; a++a</div><div class="line">[1,2,3,4,5,1,2,3,4,5]</div><div class="line">gchi&gt; 1:a</div><div class="line">[1,1,2,3,4,5]</div><div class="line">gchi&gt; null a</div><div class="line">False</div><div class="line">gchi&gt; null []</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>字符串转义<br>putStrLn用于打印一个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; putStrLn&quot;lalala\n\tlalala&quot;</div><div class="line">lalala</div><div class="line">	lalala</div></pre></td></tr></table></figure></p>
<p>长度，比较符是比较长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gchi&gt; length a</div><div class="line">5</div><div class="line">gchi&gt; a &gt; [1,3]</div><div class="line">False</div></pre></td></tr></table></figure></p>
<p>读取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">gchi&gt; a</div><div class="line">[1,2,3,4,5]</div><div class="line">gchi&gt; head a</div><div class="line">1</div><div class="line">gchi&gt; tail a</div><div class="line">[2,3,4,5]</div><div class="line">gchi&gt; last a</div><div class="line">5</div><div class="line">gchi&gt; init a</div><div class="line">[1,2,3,4]</div><div class="line">gchi&gt; take 3 a</div><div class="line">[1,2,3]</div><div class="line">ghci&gt;drop 2 a</div><div class="line">[3,4,5]</div><div class="line">gchi&gt; maximum a</div><div class="line">5</div><div class="line">gchi&gt; minimum a</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>其他操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gchi&gt; a</div><div class="line">[1,2,3,4,5]</div><div class="line">gchi&gt; reverse a</div><div class="line">[5,4,3,2,1]</div><div class="line">gchi&gt; sum a</div><div class="line">15</div></pre></td></tr></table></figure></p>
<p>建立数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gchi&gt; [1..10]</div><div class="line">[1,2,3,4,5,6,7,8,9,10]</div><div class="line">gchi&gt; [1,3..10]</div><div class="line">[1,3,5,7,9]</div><div class="line">gchi&gt; cycle[1,2,3]</div><div class="line">1,2,3死循环</div><div class="line">gchi&gt; repeat 10</div><div class="line">10 死循环</div></pre></td></tr></table></figure></p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>可以添加任意多个限制条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">gchi&gt; [x*2 | x &lt;- [1..10]]</div><div class="line">[2,4,6,8,10,12,14,16,18,20]</div><div class="line"></div><div class="line">gchi&gt; [x*2 | x &lt;- [1..10],x*2&gt;10]</div><div class="line">[12,14,16,18,20]</div><div class="line"></div><div class="line">Prelude&gt; [x | x &lt;- [50..100], x `elem` [60..70]]</div><div class="line">[60,61,62,63,64,65,66,67,68,69,70]</div><div class="line"></div><div class="line">Prelude&gt; [x | x &lt;- [50..100], x `mod` 10 ==0]</div><div class="line">[50,60,70,80,90,100]</div><div class="line"></div><div class="line">Prelude&gt; [x | x &lt;- [50..60], odd x]</div><div class="line">[51,53,55,57,59]</div><div class="line"></div><div class="line">Prelude&gt; [x*y | x &lt;- [1..5],y &lt;- [3..7]]</div><div class="line">[3,4,5,6,7,6,8,10,12,14,9,12,15,18,21,12,16,20,24,28,15,20,25,30,35]</div></pre></td></tr></table></figure></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组(tuple)内容可以是不同类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; (1,&apos;a&apos;,&quot;asd&quot;,[1,2])</div><div class="line">(1,&apos;a&apos;,&quot;asd&quot;,[1,2])</div></pre></td></tr></table></figure></p>
<h4 id="序对"><a href="#序对" class="headerlink" title="序对"></a>序对</h4><p>序对就是有两个元素的元组</p>
<p>使用fst和snd获得序对元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; fst (1,&quot;dfgh&quot;)</div><div class="line">1</div><div class="line">Prelude&gt; snd (1,&quot;dfgh&quot;)</div><div class="line">&quot;dfgh&quot;</div></pre></td></tr></table></figure></p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>打包两个list，来生成一组序对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; zip [1,2,3,4] [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]</div><div class="line">[(1,&apos;a&apos;),(2,&apos;b&apos;),(3,&apos;c&apos;),(4,&apos;d&apos;)]</div></pre></td></tr></table></figure></p>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>数值类型首字母大写，变量首字母小写<br>整数：Integer<br>分数：Ratio Integer<br>分数使用操作符 % 构建</p>
<h3 id="Haskell类型特点"><a href="#Haskell类型特点" class="headerlink" title="Haskell类型特点"></a>Haskell类型特点</h3><h4 id="强类型"><a href="#强类型" class="headerlink" title="强类型"></a>强类型</h4><p>拒绝执行无意义的表达式，类型错误会在编译时显示</p>
<h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><p>编译器在编译时便直到所有值和表达式的类型</p>
<h4 id="类型推到"><a href="#类型推到" class="headerlink" title="类型推到"></a>类型推到</h4><p>编译器自动推断出所有表达式类型</p>
<h3 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t &quot;asdads&quot;</div><div class="line">&quot;asdads&quot; :: [Char]</div><div class="line"></div><div class="line">Prelude&gt; :t (123,&quot;asd&quot;,[1,2,3])</div><div class="line">(123,&quot;asd&quot;,[1,2,3]) :: (Num t, Num t1) =&gt; (t, [Char], [t1])</div></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; lines &quot;lalala\nlalala\nlalala\tlalala\n&quot;</div><div class="line">[&quot;lalala&quot;,&quot;lalala&quot;,&quot;lalala\tlalala&quot;]</div><div class="line">it :: [String]</div><div class="line">Prelude&gt; :t lines</div><div class="line">lines :: String -&gt; [String]</div></pre></td></tr></table></figure>
<p>这里的<code>-&gt;</code>可以读作映射</p>
<p>类型a是个类型变量，指的是可以取任意类型</p>
<p>fst将两个类型作为参数，返回第一个项的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t fst</div><div class="line">fst :: (a, b) -&gt; a</div></pre></td></tr></table></figure></p>
<p>不纯函数（受环境变量影响的函数）的类型以IO开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t readFile</div><div class="line">readFile :: FilePath -&gt; IO String</div></pre></td></tr></table></figure></p>
<p>在定义函数前声明类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">testCase :: Bool -&gt; Bool </div><div class="line">testCase value =</div><div class="line">    case value of</div><div class="line">        True -&gt; False</div><div class="line">        False -&gt; True</div></pre></td></tr></table></figure></p>
<h3 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h3><p>只有属于响应的类型类才能使用相应的方法</p>
<p>Eq：判断相等<br>Ord：比较大小<br>Show：可用字符串表示<br>Read：字符串转化为一个类型<br>Enum：可枚举<br>Bounded：成员有上下限<br>Num：数字<br>Intergral：数字<br>Floating：浮点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*Main&gt; read &quot;12&quot; :: Int</div><div class="line">12</div><div class="line">*Main&gt; read &quot;12&quot; :: Float</div><div class="line">12.0</div></pre></td></tr></table></figure>
<p>使用逗号可以给函数添加多个约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">checkReverse :: (Eq a,Num a) =&gt; [a] -&gt; Bool</div><div class="line">checkReverse xs = if null xs</div><div class="line">    then True</div><div class="line">    else if xs == (reverse xs)</div><div class="line">        then True</div><div class="line">        else False</div></pre></td></tr></table></figure>
<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><p>Int：表示整数，有上限<br>Integer：无边界整数<br>Float ：浮点数<br>Double：双精度浮点数<br>Bool：布尔值<br>Char：一个字符<br>Haskell有个特殊的类型：<code>()</code>表示一个空元组</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Haskell里变量不能多次赋值</p>
<p>文件：test.hs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x=20</div><div class="line">x=10</div></pre></td></tr></table></figure></p>
<p>导入出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :t readFile</div><div class="line">readFile :: FilePath -&gt; IO String</div><div class="line">Prelude&gt; :l test.hs</div><div class="line">[1 of 1] Compiling Main             ( test.hs, interpreted )</div><div class="line"></div><div class="line">test.hs:2:1:</div><div class="line">    Multiple declarations of `x&apos;</div><div class="line">    Declared at: test.hs:1:1</div><div class="line">                 test.hs:2:1</div><div class="line">Failed, modules loaded: none.</div></pre></td></tr></table></figure></p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>在Haskell中，代码缩进预示着一个定义的延续，非常重要</p>
<p>不同分支的类型必须相同，否则会出错<br>同样的，也不能省略分支</p>
<p>自定义一个drop函数，null用于检查列表是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">myDrop n xs = if n&lt;=0 || null xs</div><div class="line">    then xs</div><div class="line">    else myDrop (n-1) (tail xs)</div><div class="line"></div><div class="line">*Main&gt; myDrop 2 [1,2,3,4,5,6]</div><div class="line">[3,4,5,6]</div></pre></td></tr></table></figure></p>
<p>用Python实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def myDrop(n,xs):</div><div class="line">    if n&lt;=0 or len(xs)==0:</div><div class="line">        return xs</div><div class="line">    else:</div><div class="line">        return myDrop(n-1,xs[1:])</div><div class="line"></div><div class="line">print myDrop(2,[1,2,3,4])</div></pre></td></tr></table></figure></p>
<h1 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h1><h2 id="自定义新的数据类型"><a href="#自定义新的数据类型" class="headerlink" title="自定义新的数据类型"></a>自定义新的数据类型</h2><p>使用<code>data</code>关键字定义新的数据类型</p>
<p><code>BookInfo</code>是类型名，<code>Book</code>是值构造器的名字<br>类型名和值构造器命名不会冲突</p>
<p>之后的是类型的组成部分</p>
<p>注意：相同结构的不同类型也是区别对待的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">data BookInfo = Book Int String [String]</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">myBook = Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]</div><div class="line"></div><div class="line">*Main&gt; myBook</div><div class="line">Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]</div><div class="line"></div><div class="line">*Main&gt; :t myBook</div><div class="line">myBook :: BookInfo</div><div class="line"></div><div class="line">*Main&gt; :info BookInfo</div><div class="line">data BookInfo = Book Int String [String]    -- Defined at test.hs:9:6</div><div class="line">instance Show BookInfo -- Defined at test.hs:10:14</div><div class="line"></div><div class="line">*Main&gt; :t Book</div><div class="line">Book :: Int -&gt; String -&gt; [String] -&gt; BookInfo</div></pre></td></tr></table></figure></p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><code>type</code>关键字给<strong>已存在</strong>的类型添加别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type CustomerID = Int</div><div class="line">type ReviewBody = String</div><div class="line"></div><div class="line">data BookReview = BookReview BookInfo CustomerID ReviewBody</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">myBookReview = BookReview myBook 3 &quot;hello harryx&quot;</div><div class="line"></div><div class="line">*Main&gt; myBookReview</div><div class="line">BookReview (Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]) 3 &quot;hello harryx&quot;</div></pre></td></tr></table></figure>
<h2 id="代数数据类型"><a href="#代数数据类型" class="headerlink" title="代数数据类型"></a>代数数据类型</h2><p>Bool类型是代数数据类型<strong>（algebraic data type）</strong>最简单的例子</p>
<p><code>Bool</code>有两个值构造器，分别是<code>False</code>和<code>True</code>，用 <code>|</code> 分为两个分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data Bool = False | True</div></pre></td></tr></table></figure>
<p><code>BookPay</code>类型提供三种值构造器</p>
<p>分别对应信用卡、支付宝、现金三种方式</p>
<p>不同值构造器所需的参数可能不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">type CardNumber = String</div><div class="line">type AlipayNumber = String</div><div class="line">type  Address = [String]</div><div class="line">data BookPay = Card CardNumber</div><div class="line">    | Alipay AlipayNumber</div><div class="line">    | Cash Address</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">*Main&gt; :info BookPay</div><div class="line">data BookPay = Card CardNumber | Alipay AlipayNumber | Cash Address</div><div class="line">    -- Defined at test.hs:21:6</div><div class="line">instance Show BookPay -- Defined at test.hs:24:14</div><div class="line"></div><div class="line">*Main&gt; :t Cash</div><div class="line">Cash :: Address -&gt; BookPay</div><div class="line"></div><div class="line">*Main&gt; let myPay = Cash [&quot;China&quot;,&quot;JS&quot;]</div><div class="line">*Main&gt; myPay</div><div class="line">Cash [&quot;China&quot;,&quot;JS&quot;]</div></pre></td></tr></table></figure>
<h3 id="元组和代数数据类型"><a href="#元组和代数数据类型" class="headerlink" title="元组和代数数据类型"></a>元组和代数数据类型</h3><p>和代数类型不同，如果元组的结构相同，那么元组的类型也相同</p>
<p>使用上面的例子，即使结构都是一个String，类型名都是Book，仍然区分为不同类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">type CardNumber = String</div><div class="line">type AlipayNumber = String</div><div class="line">type  Address = [String]</div><div class="line">data BookPay = Card CardNumber</div><div class="line">    | Alipay AlipayNumber</div><div class="line">    | Cash Address</div><div class="line">    deriving(Eq,Show)</div><div class="line"></div><div class="line">myPay = Alipay &quot;123&quot;</div><div class="line">yourPay = Alipay &quot;123&quot;</div><div class="line">hisPay = Card &quot;123&quot;</div><div class="line"></div><div class="line">*Main&gt; myPay == yourPay</div><div class="line">True</div><div class="line">*Main&gt; myPay == hisPay</div><div class="line">False</div><div class="line"></div><div class="line">*Main&gt; :t myPay</div><div class="line">myPay :: BookPay</div><div class="line"></div><div class="line">*Main&gt; :t hisPay</div><div class="line">hisPay :: BookPay</div></pre></td></tr></table></figure>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配时，会从上到下依次检查</p>
<p>myNot分别定义了函数对于不同输入参数的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">myNot :: Bool -&gt; Bool</div><div class="line">myNot True = False</div><div class="line">myNot False = True</div><div class="line"></div><div class="line">*Main&gt; myNot (1/=1)</div><div class="line">True</div><div class="line">*Main&gt; myNot (1==1)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>递归求和</p>
<p>这里约束类型为<code>Num</code>，只要是<code>Num</code>类型都可以<br>如果约束为<code>Integral</code>，只能输入整数</p>
<p>其中，数组会被分解为<code>x``xs</code>两部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mySum :: Num a =&gt; [a] -&gt; a</div><div class="line">mySum (x:xs) = x + mySum xs</div><div class="line">mySum [] = 0</div></pre></td></tr></table></figure>
<p>匹配自定义的代数类型<br>必须指定相应类型构造器才能匹配成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bookId  (Book id title  authors) = id</div><div class="line">bookTitle (Book id title  authors) = title</div><div class="line">bookAuthors (Book id title  authors) = authors</div><div class="line"></div><div class="line">*Main&gt; bookId myBook</div><div class="line">1234</div><div class="line">*Main&gt; bookTitle myBook</div><div class="line">&quot;my book&quot;</div><div class="line">*Main&gt; bookAuthors myBook</div><div class="line">[&quot;harryx&quot;,&quot;herui&quot;]</div></pre></td></tr></table></figure>
<p><code>as</code>模式可以保留对整体的引用</p>
<p>当匹配到最后一个模式时，会把整体赋值为all</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tell :: Show a =&gt; [a] -&gt; [Char]</div><div class="line">tell [] = &quot;none&quot;</div><div class="line">tell (x:[]) = show x</div><div class="line">tell (x:y:[]) = show x ++ &quot; and &quot; ++ show y</div><div class="line">tell all@(x:y:_) = &quot;long &quot; ++ show  all</div><div class="line"></div><div class="line">*Main&gt; tell [1,2,3,4,4]</div><div class="line">&quot;long [1,2,3,4,4]&quot;</div></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>当不需要使用某个接收的参数时，可以使用通配符，编译器也不会因为参数没有使用而报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bookId  (Book id _  _) = id</div><div class="line">bookTitle (Book _ title  _) = title</div><div class="line">bookAuthors (Book _ _  authors) = authors</div></pre></td></tr></table></figure>
<p>在模式匹配时使用通配符，可以定义一个默认行为<br>如果之前都没匹配成功，会匹配后面的通配符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mySum (x:xs) = x + mySum xs</div><div class="line">mySum _ = 0</div><div class="line"></div><div class="line">*Main&gt; mySum [1,2,3]</div><div class="line">6</div><div class="line">*Main&gt; mySum []</div><div class="line">0</div></pre></td></tr></table></figure>
<h3 id="记录语法"><a href="#记录语法" class="headerlink" title="记录语法"></a>记录语法</h3><p>在创建一个数据类型时，可以指定字段名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data BookInfo = Book&#123;</div><div class="line">    bookId :: Int,</div><div class="line">    bookTitle :: String,</div><div class="line">    bookAuthors :: [String]</div><div class="line">&#125;deriving(Eq,Show)</div></pre></td></tr></table></figure>
<p>在创建值时可以指定字段名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myBook = Book 1234 &quot;my book&quot; [&quot;harryx&quot;,&quot;herui&quot;]</div><div class="line"></div><div class="line">yourBook = Book&#123;</div><div class="line">    bookId = 2345,</div><div class="line">    bookTitle = &quot;your book&quot;,</div><div class="line">    bookAuthors = [&quot;someone&quot;,&quot;the others&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用自带的访问器函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*Main&gt; bookId myBook</div><div class="line">1234</div><div class="line">*Main&gt; bookTitle yourBook</div><div class="line">&quot;your book&quot;</div></pre></td></tr></table></figure>
<h3 id="递归类型"><a href="#递归类型" class="headerlink" title="递归类型"></a>递归类型</h3><p>其中it为上一个求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">data List a = Cons a (List a)</div><div class="line">    | Nil</div><div class="line">    deriving(Show)</div><div class="line"></div><div class="line">*Main&gt; Cons 0 Nil</div><div class="line">Cons 0 Nil</div><div class="line"></div><div class="line">*Main&gt; Cons 1 it</div><div class="line">Cons 1 (Cons 0 Nil)</div><div class="line"></div><div class="line">*Main&gt; Cons 2 it</div><div class="line">Cons 2 (Cons 1 (Cons 0 Nil))</div></pre></td></tr></table></figure>
<p>List和list的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fromList (x:xs) = Cons x (fromList xs)</div><div class="line">fromList []     = Nil</div><div class="line"></div><div class="line">fromCons (Cons a x) = a : (fromCons x)</div><div class="line">fromCons Nil = []</div><div class="line"></div><div class="line">*Main&gt; fromList &quot;asdasd&quot;</div><div class="line">Cons &apos;a&apos; (Cons &apos;s&apos; (Cons &apos;d&apos; (Cons &apos;a&apos; (Cons &apos;s&apos; (Cons &apos;d&apos; Nil)))))</div><div class="line"></div><div class="line">*Main&gt; fromCons (fromList &quot;asdasd&quot;)</div><div class="line">&quot;asdasd&quot;</div></pre></td></tr></table></figure>
<p>使用模式匹配和递归<br>返回数组最大值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">maxXs :: (Num a,Ord a) =&gt; [a] -&gt; a</div><div class="line">maxXs [] = error &quot;empty&quot;</div><div class="line">maxXs [x] = x</div><div class="line">maxXs (x:xs)</div><div class="line">    | x &gt; (maxXs xs) = x</div><div class="line">    | otherwise = (maxXs xs)</div></pre></td></tr></table></figure>
<p>Python实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def maxLis(lis):</div><div class="line">    if  len(lis) == 0:</div><div class="line">        return 0</div><div class="line">    if len(lis) == 1:</div><div class="line">        return lis[0]</div><div class="line">    if lis[0] &gt; maxLis(lis[1:]):</div><div class="line">        return lis[0]</div><div class="line">    else:</div><div class="line">        return maxLis(lis[1:])</div><div class="line"></div><div class="line">print maxLis([1,2,3,4,5,3,2,5,7,4,2,3])</div></pre></td></tr></table></figure>
<p>排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mySort :: (Ord a) =&gt; [a] -&gt; [a]</div><div class="line">mySort [] = []</div><div class="line">mySort (x:xs) = </div><div class="line">    let &#123;</div><div class="line">    smallone = mySort [a | a &lt;- xs, a &lt;= x];</div><div class="line">    bigone = mySort [a | a &lt;- xs, a &gt; x];</div><div class="line">&#125;</div><div class="line">    in smallone ++ [x] ++ bigone</div></pre></td></tr></table></figure>
<p>使用Python实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def mySort(lis):</div><div class="line">    if lis == []:</div><div class="line">        return []</div><div class="line">    else:</div><div class="line">        return mySort([i for i in lis[1:] if i &lt;= lis[0]]) \</div><div class="line">            + [lis[0]] \</div><div class="line">            + mySort([i for i in lis[1:] if i &gt; lis[0]])</div><div class="line"></div><div class="line">print mySort([1,3,2,5,4,5,23,24,1,14,2,4124,12,21,1])</div></pre></td></tr></table></figure>
<h3 id="报告错误"><a href="#报告错误" class="headerlink" title="报告错误"></a>报告错误</h3><p>定义一个返回数组倒数第二个值，如果数组长度太短返回错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lastButOne xs = if null xs || (length xs) == 1</div><div class="line">    then error &quot;list too short&quot;</div><div class="line">    else head (drop ((length xs) -2) xs)</div><div class="line"></div><div class="line">*Main&gt; lastButOne [1,2,3,4,5,6,7]</div><div class="line">6</div><div class="line"></div><div class="line">*Main&gt; lastButOne [1]</div><div class="line">*** Exception: list too short</div><div class="line">*Main&gt; lastButOne []</div><div class="line">*** Exception: list too short</div></pre></td></tr></table></figure>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数内部，<code>let</code>把变量限制在<code>in</code>后面的表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo = let x=1</div><div class="line">    in ((let x = &quot;asd&quot; in x),x)</div><div class="line"></div><div class="line">*Main&gt; foo</div><div class="line">(&quot;asd&quot;,1)</div></pre></td></tr></table></figure>
<p>where和let类似，不同的是，语句定义在主句后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo = a</div><div class="line">    where a=1</div></pre></td></tr></table></figure>
<p>where语句中可以进行模式匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">initials :: String -&gt; String -&gt; String   </div><div class="line">initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot;   </div><div class="line">    where (f:_) = firstname   </div><div class="line">          (l:_) = lastname</div></pre></td></tr></table></figure>
<h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><p><code>Case</code>语句</p>
<p>case后面是一个表达式，表达式的值为匹配目标<br>of后面是匹配区的开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">testCase value =</div><div class="line">    case value of</div><div class="line">        True -&gt; False</div><div class="line">        False -&gt; True</div></pre></td></tr></table></figure>
<h3 id="门卫"><a href="#门卫" class="headerlink" title="门卫"></a>门卫</h3><p>类似功能的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String   </div><div class="line">bmiTell weight height   </div><div class="line">    | weight / height ^ 2 &lt;= 18.5 </div><div class="line">        = &quot;You&apos;re underweight, you emo, you!&quot;   </div><div class="line">    | weight / height ^ 2 &lt;= 25.0 </div><div class="line">        = &quot;You&apos;re supposedly normal. Pffft, I bet you&apos;re ugly!&quot;   </div><div class="line">    | weight / height ^ 2 &lt;= 30.0 </div><div class="line">        = &quot;You&apos;re fat! Lose some weight, fatty!&quot;   </div><div class="line">    | otherwise                 </div><div class="line">        = &quot;You&apos;re a whale, congratulations!&quot;</div></pre></td></tr></table></figure>
<p>使用局部变量改进函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String   </div><div class="line">bmiTell weight height   </div><div class="line">    | bmi &lt;= skinny</div><div class="line">        = &quot;You&apos;re underweight, you emo, you!&quot;   </div><div class="line">    | bmi &lt;= normal</div><div class="line">        = &quot;You&apos;re supposedly normal. Pffft, I bet you&apos;re ugly!&quot;   </div><div class="line">    | bmi &lt;= fat</div><div class="line">        = &quot;You&apos;re fat! Lose some weight, fatty!&quot;   </div><div class="line">    | otherwise                 </div><div class="line">        = &quot;You&apos;re a whale, congratulations!&quot;  </div><div class="line">    where &#123;</div><div class="line">        bmi = weight / height ^ 2;</div><div class="line">        (skinny, normal, fat) = (18.5, 25.0, 30.0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中缀函数"><a href="#中缀函数" class="headerlink" title="中缀函数"></a>中缀函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a `myplus` b = a+b</div><div class="line"></div><div class="line">*MyModule&gt; 1 `myplus` 2</div><div class="line">3</div><div class="line">*MyModule&gt; myplus 1 2</div><div class="line">3</div></pre></td></tr></table></figure>
<h1 id="柯里函数"><a href="#柯里函数" class="headerlink" title="柯里函数"></a>柯里函数</h1><p>使用参数不完全的函数定义新函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; let conpTen = max 10</div><div class="line">Prelude&gt; conpTen 9</div><div class="line">10</div></pre></td></tr></table></figure>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>将函数作为参数调用或返回</p>
<p>这里将函数f递归调用，作用在两个数组</p>
<p>真正调用的函数类型可以和函数参数不同<br>不一定是 a -&gt; b -&gt; c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">myCons :: a -&gt; a -&gt; [a]</div><div class="line">myCons x y = x:[y]</div><div class="line"></div><div class="line">myZip :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</div><div class="line">myZip _ _ [] = []</div><div class="line">myZip _ [] _ = []</div><div class="line">myZip f (x1:x1s) (x2:x2s) = (f x1 x2) : (myZip f x1s x2s)</div><div class="line"></div><div class="line">*Main&gt; myZip myCons [1,2,3,4] [3,4,5,6]</div><div class="line">[[1,3],[2,4],[3,5],[4,6]]</div></pre></td></tr></table></figure>
<p>Python实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def myZip(f,lis1,lis2):</div><div class="line">    if lis1 == [] or lis2 == []:</div><div class="line">        return []</div><div class="line">    else:</div><div class="line">        return [f(lis1[0],lis2[0])] + myZip(f,lis1[1:],lis2[1:])</div><div class="line"></div><div class="line">lis1=[1,1,2,3]</div><div class="line">lis2=[2,2,4,5]</div><div class="line"></div><div class="line">def myCons(a,b):</div><div class="line">    return [a,b]</div><div class="line"></div><div class="line">print myZip(myCons,lis1,lis2)</div></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Haskell的lambda用\表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myFlip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</div><div class="line">myFlip f x y = f y x </div><div class="line"></div><div class="line">*Main&gt; myFlip (\a b -&gt; a:[b]) 1 2</div><div class="line">[2,1]</div></pre></td></tr></table></figure>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p><code>foldl</code>实现左折叠<br><code>foldr</code>右折叠<br>将一个二元函数作为参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myFoldlSum :: Num a =&gt; [a] -&gt; a</div><div class="line">myFoldlSum xs = foldl (\acc x -&gt; acc + x) 0 xs</div></pre></td></tr></table></figure>
<p>柯里化可以省略参数<br><code>\acc x -&gt; acc + x</code>和<code>+</code>是等价的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myFoldlSum :: Num a =&gt; [a] -&gt; a</div><div class="line">myFoldlSum = foldl (+) 0</div></pre></td></tr></table></figure>
<p>使用<code>:</code>将数组反向拼接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myFoldlRev :: [a] -&gt; [a]</div><div class="line">myFoldlRev = foldl (\acc x -&gt; x:acc) []</div><div class="line"></div><div class="line">*Main&gt; myFoldlRev [1,2,3]</div><div class="line">[3,2,1]</div></pre></td></tr></table></figure>
<p><code>foldl1``foldr1</code>把折叠的第一个值作为初始值(数值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myFoldlSum :: Num a =&gt; [a] -&gt; a</div><div class="line">myFoldlSum = foldl1 (+)</div></pre></td></tr></table></figure>
<h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a><code>$</code>符号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">($) :: (a -&gt; b) -&gt; a -&gt; b   </div><div class="line">f $ x = f x</div></pre></td></tr></table></figure>
<p><code>$</code>相当于在后面添加了括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*Main&gt; sum $ map (+1) [1,2,3,4]</div><div class="line">14</div><div class="line">*Main&gt; sum ( map (+1) [1,2,3,4])</div><div class="line">14</div></pre></td></tr></table></figure>
<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c   </div><div class="line">f . g = \x -&gt; f (g x)</div></pre></td></tr></table></figure>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="装载模块"><a href="#装载模块" class="headerlink" title="装载模块"></a>装载模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; import Data.List</div><div class="line">Prelude Data.List&gt;</div></pre></td></tr></table></figure>
<p>在ghci命令行也可以使用<code>:m</code>装载模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Prelude&gt; :m Data.List</div><div class="line">Prelude Data.List&gt;</div></pre></td></tr></table></figure>
<p>只装载某个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Data.List  (nub)</div></pre></td></tr></table></figure></p>
<p>去除某个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Data.List  hiding (nub)</div></pre></td></tr></table></figure></p>
<p>避免命名冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import qualified Data.List</div><div class="line"></div><div class="line">*Main&gt; Data.List.nub [1,2,12,1]</div><div class="line">[1,2,12]</div></pre></td></tr></table></figure></p>
<p>自定义模块名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import qualified Data.List as L</div><div class="line"></div><div class="line">*Main&gt; L.nub [1,2,3,3,2]</div><div class="line">[1,2,3]</div></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import Data.List  </div><div class="line"></div><div class="line">numUniques :: (Eq a) =&gt; [a] -&gt; Int   </div><div class="line">numUniques = length . nub</div><div class="line"></div><div class="line">*Main Data.List&gt; numUniques [1,2,3,2,1,3]</div><div class="line">3</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/24/Haskell/" data-id="cj5c7k37t000bm0u4kkayiqk6" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/haskell/">haskell</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acg/">acg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/basic/">basic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bb/">bb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haskell/">haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jquery/">jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sicp/">sicp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/soket/">soket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spider/">spider</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/acg/" style="font-size: 10px;">acg</a> <a href="/tags/basic/" style="font-size: 10px;">basic</a> <a href="/tags/bb/" style="font-size: 10px;">bb</a> <a href="/tags/c/" style="font-size: 12.86px;">c++</a> <a href="/tags/django/" style="font-size: 12.86px;">django</a> <a href="/tags/flask/" style="font-size: 20px;">flask</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/haskell/" style="font-size: 10px;">haskell</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/javascript/" style="font-size: 17.14px;">javascript</a> <a href="/tags/jquery/" style="font-size: 15.71px;">jquery</a> <a href="/tags/linux/" style="font-size: 11.43px;">linux</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mysql/" style="font-size: 12.86px;">mysql</a> <a href="/tags/python/" style="font-size: 18.57px;">python</a> <a href="/tags/sicp/" style="font-size: 10px;">sicp</a> <a href="/tags/socket/" style="font-size: 11.43px;">socket</a> <a href="/tags/soket/" style="font-size: 10px;">soket</a> <a href="/tags/spider/" style="font-size: 14.29px;">spider</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/03/effective-C/">effective_C++</a>
          </li>
        
          <li>
            <a href="/2017/04/01/traceback/">异常处理</a>
          </li>
        
          <li>
            <a href="/2017/04/01/logging/">打印日志</a>
          </li>
        
          <li>
            <a href="/2017/04/01/construct/">二进制数据处理</a>
          </li>
        
          <li>
            <a href="/2017/03/29/Csharp/">C#面向对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 HeRui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>